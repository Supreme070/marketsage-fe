{"version":3,"sources":["/Users/supreme/Desktop/marketsage/src/lib/ai/mandatory-approval-system.ts"],"sourcesContent":["/**\n * Mandatory Approval System - Production Safety Implementation\n * ===========================================================\n * Implements mandatory human approval for ALL external actions with a trust-building\n * system that gradually enables autonomous execution based on patterns and thresholds.\n * \n * Key Safety Principles:\n * - ALL external actions require approval by default\n * - 12-week trust building period OR 600 approved tasks\n * - Permanent approval for high-impact actions (campaigns, data changes, budget)\n * - Graduated autonomy based on historical trust patterns\n */\n\nimport { logger } from '@/lib/logger';\nimport { safetyApprovalSystem } from './safety-approval-system';\nimport { taskExecutionMonitor } from './task-execution-monitor';\nimport prisma from '@/lib/db/prisma';\n\ninterface TaskApprovalRequest {\n  id: string;\n  userId: string;\n  userRole: string;\n  organizationId: string;\n  taskType: string;\n  actionType: 'campaign_send' | 'data_modification' | 'api_call' | 'integration_setup' | 'budget_action' | 'system_config';\n  description: string;\n  parameters: Record<string, any>;\n  estimatedImpact: {\n    recordsAffected: number;\n    potentialRevenue: number;\n    riskLevel: 'low' | 'medium' | 'high' | 'critical';\n    reversible: boolean;\n  };\n  urgency: 'low' | 'medium' | 'high' | 'emergency';\n  requestedAt: Date;\n  expiresAt: Date;\n  status: 'pending' | 'approved' | 'rejected' | 'expired' | 'executed' | 'cancelled';\n  approverRequired: string; // Role or specific user ID\n  approvedBy?: string;\n  approvedAt?: Date;\n  rejectedBy?: string;\n  rejectedAt?: Date;\n  rejectionReason?: string;\n  executedAt?: Date;\n  rollbackData?: any;\n  metadata: {\n    trustScore: number;\n    previousSimilarTasks: number;\n    successRate: number;\n    autoApprovalEligible: boolean;\n    deploymentPhase: 'trust_building' | 'graduated' | 'autonomous';\n  };\n}\n\ninterface TrustMetrics {\n  organizationId: string;\n  userId: string;\n  totalApprovedTasks: number;\n  successfulExecutions: number;\n  failedExecutions: number;\n  successRate: number;\n  deploymentDate: Date;\n  weeksActive: number;\n  trustScore: number;\n  autoApprovalEnabled: boolean;\n  eligibleTaskTypes: string[];\n  permanentApprovalRequired: string[]; // Always require approval\n  lastEvaluated: Date;\n}\n\ninterface DeploymentConfiguration {\n  organizationId: string;\n  deploymentDate: Date;\n  phase: 'trust_building' | 'graduated' | 'autonomous';\n  mandatoryApprovalWeeks: number; // Default: 12\n  trustTaskThreshold: number; // Default: 600\n  permanentApprovalActions: string[];\n  autoApprovalRules: {\n    enabled: boolean;\n    maxImpactLevel: 'low' | 'medium' | 'high';\n    maxRecordsAffected: number;\n    maxRevenue: number;\n    requiredSuccessRate: number;\n    minHistoricalTasks: number;\n  };\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nclass MandatoryApprovalSystem {\n  private pendingApprovals: Map<string, TaskApprovalRequest> = new Map();\n  private trustMetrics: Map<string, TrustMetrics> = new Map();\n  private deploymentConfigs: Map<string, DeploymentConfiguration> = new Map();\n  private readonly TRUST_BUILDING_WEEKS = 12;\n  private readonly TRUST_TASK_THRESHOLD = 600;\n  private readonly APPROVAL_TIMEOUT_HOURS = 24;\n\n  // Actions that ALWAYS require approval regardless of trust level\n  private readonly PERMANENT_APPROVAL_ACTIONS = [\n    'campaign_send',        // Email/SMS/WhatsApp campaigns\n    'data_modification',    // Customer data changes\n    'budget_action',        // Financial decisions\n    'integration_setup',    // External API configurations\n    'system_config'         // System-level changes\n  ];\n\n  constructor() {\n    this.initializeSystem();\n    this.startApprovalMonitoring();\n  }\n\n  /**\n   * Initialize the mandatory approval system\n   */\n  private async initializeSystem(): Promise<void> {\n    // Load existing configurations from database\n    await this.loadDeploymentConfigurations();\n    await this.loadTrustMetrics();\n    \n    logger.info('Mandatory Approval System initialized', {\n      trustBuildingWeeks: this.TRUST_BUILDING_WEEKS,\n      taskThreshold: this.TRUST_TASK_THRESHOLD,\n      permanentApprovalActions: this.PERMANENT_APPROVAL_ACTIONS\n    });\n  }\n\n  /**\n   * Check if an action requires approval based on current deployment phase and trust metrics\n   */\n  async requiresApproval(\n    userId: string,\n    organizationId: string,\n    actionType: string,\n    parameters: Record<string, any>\n  ): Promise<{\n    required: boolean;\n    reason: string;\n    phase: string;\n    trustScore: number;\n    autoApprovalEligible: boolean;\n  }> {\n    try {\n      // Get deployment configuration\n      const config = await this.getDeploymentConfiguration(organizationId);\n      const trustMetrics = await this.getTrustMetrics(userId, organizationId);\n\n      // ALWAYS require approval for permanent approval actions\n      if (this.PERMANENT_APPROVAL_ACTIONS.includes(actionType)) {\n        return {\n          required: true,\n          reason: 'High-impact action requires permanent human approval',\n          phase: config.phase,\n          trustScore: trustMetrics.trustScore,\n          autoApprovalEligible: false\n        };\n      }\n\n      // Check deployment phase\n      switch (config.phase) {\n        case 'trust_building':\n          return {\n            required: true,\n            reason: `Trust building phase: ${config.weeksActive}/${config.mandatoryApprovalWeeks} weeks, ${trustMetrics.totalApprovedTasks}/${config.trustTaskThreshold} approved tasks`,\n            phase: config.phase,\n            trustScore: trustMetrics.trustScore,\n            autoApprovalEligible: false\n          };\n\n        case 'graduated':\n          // Check if specific action type is eligible for auto-approval\n          const eligible = await this.isAutoApprovalEligible(\n            userId,\n            organizationId,\n            actionType,\n            parameters,\n            trustMetrics,\n            config\n          );\n\n          if (eligible.eligible) {\n            return {\n              required: false,\n              reason: `Auto-approved: ${eligible.reason}`,\n              phase: config.phase,\n              trustScore: trustMetrics.trustScore,\n              autoApprovalEligible: true\n            };\n          } else {\n            return {\n              required: true,\n              reason: `Approval required: ${eligible.reason}`,\n              phase: config.phase,\n              trustScore: trustMetrics.trustScore,\n              autoApprovalEligible: false\n            };\n          }\n\n        case 'autonomous':\n          // Even in autonomous phase, check specific action requirements\n          const autoApprovalCheck = await this.isAutoApprovalEligible(\n            userId,\n            organizationId,\n            actionType,\n            parameters,\n            trustMetrics,\n            config\n          );\n\n          return {\n            required: !autoApprovalCheck.eligible,\n            reason: autoApprovalCheck.reason,\n            phase: config.phase,\n            trustScore: trustMetrics.trustScore,\n            autoApprovalEligible: autoApprovalCheck.eligible\n          };\n\n        default:\n          return {\n            required: true,\n            reason: 'Unknown deployment phase, defaulting to approval required',\n            phase: 'unknown',\n            trustScore: 0,\n            autoApprovalEligible: false\n          };\n      }\n\n    } catch (error) {\n      logger.error('Error checking approval requirement', {\n        userId,\n        organizationId,\n        actionType,\n        error: error instanceof Error ? error.message : String(error)\n      });\n\n      // Default to requiring approval on error\n      return {\n        required: true,\n        reason: 'System error, defaulting to approval required for safety',\n        phase: 'error',\n        trustScore: 0,\n        autoApprovalEligible: false\n      };\n    }\n  }\n\n  /**\n   * Create a new approval request for an external action\n   */\n  async createApprovalRequest(\n    userId: string,\n    userRole: string,\n    organizationId: string,\n    taskType: string,\n    actionType: TaskApprovalRequest['actionType'],\n    description: string,\n    parameters: Record<string, any>,\n    estimatedImpact: TaskApprovalRequest['estimatedImpact'],\n    urgency: TaskApprovalRequest['urgency'] = 'medium'\n  ): Promise<string> {\n    const requestId = `approval_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    // Get trust metrics for metadata\n    const trustMetrics = await this.getTrustMetrics(userId, organizationId);\n    const config = await this.getDeploymentConfiguration(organizationId);\n\n    // Calculate expiration based on urgency\n    const expirationHours = urgency === 'emergency' ? 2 : \n                           urgency === 'high' ? 8 : \n                           urgency === 'medium' ? 24 : 72;\n\n    const approvalRequest: TaskApprovalRequest = {\n      id: requestId,\n      userId,\n      userRole,\n      organizationId,\n      taskType,\n      actionType,\n      description: description.substring(0, 500),\n      parameters,\n      estimatedImpact,\n      urgency,\n      requestedAt: new Date(),\n      expiresAt: new Date(Date.now() + expirationHours * 60 * 60 * 1000),\n      status: 'pending',\n      approverRequired: this.getRequiredApprover(actionType, userRole, estimatedImpact),\n      metadata: {\n        trustScore: trustMetrics.trustScore,\n        previousSimilarTasks: await this.countSimilarTasks(userId, taskType),\n        successRate: trustMetrics.successRate,\n        autoApprovalEligible: false, // Always false for new requests\n        deploymentPhase: config.phase\n      }\n    };\n\n    // Store the request\n    this.pendingApprovals.set(requestId, approvalRequest);\n    await this.persistApprovalRequest(approvalRequest);\n\n    // Send notifications to approvers\n    await this.notifyApprovers(approvalRequest);\n\n    logger.info('Approval request created', {\n      requestId,\n      userId,\n      actionType,\n      urgency,\n      expiresAt: approvalRequest.expiresAt.toISOString(),\n      approverRequired: approvalRequest.approverRequired\n    });\n\n    return requestId;\n  }\n\n  /**\n   * Process an approval decision from a human approver\n   */\n  async processApprovalDecision(\n    requestId: string,\n    approverId: string,\n    decision: 'approve' | 'reject',\n    reason?: string\n  ): Promise<{\n    success: boolean;\n    request: TaskApprovalRequest;\n    message: string;\n  }> {\n    const request = this.pendingApprovals.get(requestId) || await this.loadApprovalRequest(requestId);\n    \n    if (!request) {\n      throw new Error(`Approval request ${requestId} not found`);\n    }\n\n    if (request.status !== 'pending') {\n      throw new Error(`Request ${requestId} is already ${request.status}`);\n    }\n\n    if (new Date() > request.expiresAt) {\n      request.status = 'expired';\n      await this.persistApprovalRequest(request);\n      throw new Error(`Request ${requestId} has expired`);\n    }\n\n    const now = new Date();\n\n    if (decision === 'approve') {\n      request.status = 'approved';\n      request.approvedBy = approverId;\n      request.approvedAt = now;\n\n      // Update trust metrics\n      await this.updateTrustMetrics(request.userId, request.organizationId, 'approved');\n\n      logger.info('Approval request approved', {\n        requestId,\n        approverId,\n        actionType: request.actionType,\n        userId: request.userId\n      });\n\n    } else {\n      request.status = 'rejected';\n      request.rejectedBy = approverId;\n      request.rejectedAt = now;\n      request.rejectionReason = reason || 'No reason provided';\n\n      logger.info('Approval request rejected', {\n        requestId,\n        approverId,\n        actionType: request.actionType,\n        userId: request.userId,\n        reason\n      });\n    }\n\n    // Update stored request\n    this.pendingApprovals.set(requestId, request);\n    await this.persistApprovalRequest(request);\n\n    return {\n      success: true,\n      request,\n      message: decision === 'approve' ? 'Request approved' : 'Request rejected'\n    };\n  }\n\n  /**\n   * Execute an approved action and track the result\n   */\n  async executeApprovedAction(\n    requestId: string,\n    executionResult: {\n      success: boolean;\n      result?: any;\n      error?: string;\n      rollbackData?: any;\n    }\n  ): Promise<void> {\n    const request = this.pendingApprovals.get(requestId) || await this.loadApprovalRequest(requestId);\n    \n    if (!request) {\n      throw new Error(`Approval request ${requestId} not found`);\n    }\n\n    if (request.status !== 'approved') {\n      throw new Error(`Request ${requestId} is not approved (status: ${request.status})`);\n    }\n\n    request.status = 'executed';\n    request.executedAt = new Date();\n    request.rollbackData = executionResult.rollbackData;\n\n    // Update trust metrics based on execution result\n    await this.updateTrustMetrics(\n      request.userId,\n      request.organizationId,\n      executionResult.success ? 'executed_success' : 'executed_failure'\n    );\n\n    // Check if we should update deployment phase\n    await this.evaluatePhaseTransition(request.organizationId);\n\n    this.pendingApprovals.set(requestId, request);\n    await this.persistApprovalRequest(request);\n\n    logger.info('Approved action executed', {\n      requestId,\n      actionType: request.actionType,\n      success: executionResult.success,\n      userId: request.userId\n    });\n  }\n\n  /**\n   * Get pending approval requests for a user or organization\n   */\n  async getPendingApprovals(\n    organizationId: string,\n    approverId?: string,\n    limit = 50\n  ): Promise<TaskApprovalRequest[]> {\n    const allRequests = Array.from(this.pendingApprovals.values())\n      .filter(request => \n        request.organizationId === organizationId &&\n        request.status === 'pending' &&\n        new Date() <= request.expiresAt\n      );\n\n    // Filter by approver if specified\n    let filteredRequests = allRequests;\n    if (approverId) {\n      // Check if approver has permission for these requests\n      filteredRequests = allRequests.filter(request => \n        this.canUserApprove(approverId, request)\n      );\n    }\n\n    // Sort by urgency and creation time\n    return filteredRequests\n      .sort((a, b) => {\n        const urgencyOrder = { emergency: 4, high: 3, medium: 2, low: 1 };\n        const urgencyDiff = urgencyOrder[b.urgency] - urgencyOrder[a.urgency];\n        if (urgencyDiff !== 0) return urgencyDiff;\n        return a.requestedAt.getTime() - b.requestedAt.getTime();\n      })\n      .slice(0, limit);\n  }\n\n  /**\n   * Get trust metrics for a user\n   */\n  async getTrustMetrics(userId: string, organizationId: string): Promise<TrustMetrics> {\n    const key = `${organizationId}_${userId}`;\n    let metrics = this.trustMetrics.get(key);\n\n    if (!metrics) {\n      // Calculate metrics from database\n      metrics = await this.calculateTrustMetrics(userId, organizationId);\n      this.trustMetrics.set(key, metrics);\n    }\n\n    return metrics;\n  }\n\n  /**\n   * Get deployment configuration for an organization\n   */\n  async getDeploymentConfiguration(organizationId: string): Promise<DeploymentConfiguration> {\n    let config = this.deploymentConfigs.get(organizationId);\n\n    if (!config) {\n      // Create default configuration\n      config = await this.createDefaultDeploymentConfig(organizationId);\n      this.deploymentConfigs.set(organizationId, config);\n    }\n\n    return config;\n  }\n\n  /**\n   * Private helper methods\n   */\n  private async isAutoApprovalEligible(\n    userId: string,\n    organizationId: string,\n    actionType: string,\n    parameters: Record<string, any>,\n    trustMetrics: TrustMetrics,\n    config: DeploymentConfiguration\n  ): Promise<{ eligible: boolean; reason: string }> {\n    // Check if auto-approval is enabled\n    if (!config.autoApprovalRules.enabled) {\n      return { eligible: false, reason: 'Auto-approval disabled for organization' };\n    }\n\n    // Check trust score threshold\n    if (trustMetrics.trustScore < 0.8) {\n      return { eligible: false, reason: `Trust score too low: ${trustMetrics.trustScore.toFixed(2)}` };\n    }\n\n    // Check success rate\n    if (trustMetrics.successRate < config.autoApprovalRules.requiredSuccessRate) {\n      return { eligible: false, reason: `Success rate too low: ${(trustMetrics.successRate * 100).toFixed(1)}%` };\n    }\n\n    // Check minimum historical tasks\n    if (trustMetrics.totalApprovedTasks < config.autoApprovalRules.minHistoricalTasks) {\n      return { eligible: false, reason: `Insufficient task history: ${trustMetrics.totalApprovedTasks} tasks` };\n    }\n\n    // Check if action type is in eligible list\n    if (!trustMetrics.eligibleTaskTypes.includes(actionType)) {\n      return { eligible: false, reason: `Action type ${actionType} not eligible for auto-approval` };\n    }\n\n    // Check estimated impact limits\n    const estimatedRecords = parameters.recordsAffected || 0;\n    const estimatedRevenue = parameters.potentialRevenue || 0;\n\n    if (estimatedRecords > config.autoApprovalRules.maxRecordsAffected) {\n      return { eligible: false, reason: `Too many records affected: ${estimatedRecords}` };\n    }\n\n    if (estimatedRevenue > config.autoApprovalRules.maxRevenue) {\n      return { eligible: false, reason: `Revenue impact too high: ${estimatedRevenue}` };\n    }\n\n    return { eligible: true, reason: 'All auto-approval criteria met' };\n  }\n\n  private getRequiredApprover(\n    actionType: string,\n    userRole: string,\n    estimatedImpact: TaskApprovalRequest['estimatedImpact']\n  ): string {\n    // High-impact actions require admin approval\n    if (estimatedImpact.riskLevel === 'critical' || estimatedImpact.potentialRevenue > 10000) {\n      return 'ADMIN';\n    }\n\n    // Campaign actions require marketing manager approval\n    if (actionType === 'campaign_send') {\n      return 'MARKETING_MANAGER';\n    }\n\n    // Data modifications require data manager approval\n    if (actionType === 'data_modification') {\n      return 'DATA_MANAGER';\n    }\n\n    // Default to supervisor approval\n    return 'SUPERVISOR';\n  }\n\n  private async countSimilarTasks(userId: string, taskType: string): Promise<number> {\n    try {\n      const count = await prisma.taskExecution.count({\n        where: {\n          userId,\n          taskType,\n          status: 'completed',\n          createdAt: {\n            gte: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000) // Last 90 days\n          }\n        }\n      });\n      return count;\n    } catch (error) {\n      logger.warn('Failed to count similar tasks', { userId, taskType, error });\n      return 0;\n    }\n  }\n\n  private async calculateTrustMetrics(userId: string, organizationId: string): Promise<TrustMetrics> {\n    try {\n      // Get approval history from database\n      const approvalHistory = await prisma.taskApprovalRequest.findMany({\n        where: {\n          userId,\n          organizationId,\n          status: { in: ['approved', 'executed'] }\n        },\n        orderBy: { requestedAt: 'desc' },\n        take: 1000 // Limit for performance\n      });\n\n      const totalApproved = approvalHistory.length;\n      const executed = approvalHistory.filter(r => r.status === 'executed');\n      const successful = executed.filter(r => r.executionSuccess === true);\n\n      const successRate = executed.length > 0 ? successful.length / executed.length : 0;\n      \n      // Calculate trust score based on multiple factors\n      const volumeScore = Math.min(totalApproved / 100, 1); // Max at 100 approved tasks\n      const consistencyScore = successRate;\n      const recentActivityScore = this.calculateRecentActivityScore(approvalHistory);\n      \n      const trustScore = (volumeScore * 0.3 + consistencyScore * 0.5 + recentActivityScore * 0.2);\n\n      // Get deployment config to determine phase\n      const config = await this.getDeploymentConfiguration(organizationId);\n      const weeksActive = Math.floor((Date.now() - config.deploymentDate.getTime()) / (7 * 24 * 60 * 60 * 1000));\n\n      // Determine eligible task types based on history\n      const eligibleTaskTypes = this.determineEligibleTaskTypes(approvalHistory, trustScore);\n\n      return {\n        organizationId,\n        userId,\n        totalApprovedTasks: totalApproved,\n        successfulExecutions: successful.length,\n        failedExecutions: executed.length - successful.length,\n        successRate,\n        deploymentDate: config.deploymentDate,\n        weeksActive,\n        trustScore,\n        autoApprovalEnabled: config.autoApprovalRules.enabled && trustScore >= 0.8,\n        eligibleTaskTypes,\n        permanentApprovalRequired: [...this.PERMANENT_APPROVAL_ACTIONS],\n        lastEvaluated: new Date()\n      };\n\n    } catch (error) {\n      logger.error('Failed to calculate trust metrics', { userId, organizationId, error });\n      \n      // Return safe defaults\n      return {\n        organizationId,\n        userId,\n        totalApprovedTasks: 0,\n        successfulExecutions: 0,\n        failedExecutions: 0,\n        successRate: 0,\n        deploymentDate: new Date(),\n        weeksActive: 0,\n        trustScore: 0,\n        autoApprovalEnabled: false,\n        eligibleTaskTypes: [],\n        permanentApprovalRequired: [...this.PERMANENT_APPROVAL_ACTIONS],\n        lastEvaluated: new Date()\n      };\n    }\n  }\n\n  private calculateRecentActivityScore(approvalHistory: any[]): number {\n    const recentTasks = approvalHistory.filter(task => \n      task.requestedAt > new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // Last 30 days\n    );\n    \n    if (recentTasks.length === 0) return 0;\n    \n    const successfulRecent = recentTasks.filter(task => task.executionSuccess === true);\n    return successfulRecent.length / recentTasks.length;\n  }\n\n  private determineEligibleTaskTypes(approvalHistory: any[], trustScore: number): string[] {\n    const eligibleTypes: string[] = [];\n    \n    // Only allow auto-approval for task types with high success rates\n    const taskTypeStats = approvalHistory.reduce((acc, task) => {\n      if (!acc[task.taskType]) {\n        acc[task.taskType] = { total: 0, successful: 0 };\n      }\n      acc[task.taskType].total++;\n      if (task.executionSuccess) {\n        acc[task.taskType].successful++;\n      }\n      return acc;\n    }, {});\n\n    for (const [taskType, stats] of Object.entries(taskTypeStats)) {\n      const successRate = stats.successful / stats.total;\n      const minTasks = 10; // Minimum tasks needed for eligibility\n      \n      if (stats.total >= minTasks && successRate >= 0.9 && trustScore >= 0.8) {\n        // Only allow low-risk task types for auto-approval\n        if (['reporting', 'analytics', 'data_export', 'contact_enrichment'].includes(taskType)) {\n          eligibleTypes.push(taskType);\n        }\n      }\n    }\n\n    return eligibleTypes;\n  }\n\n  private async createDefaultDeploymentConfig(organizationId: string): Promise<DeploymentConfiguration> {\n    const config: DeploymentConfiguration = {\n      organizationId,\n      deploymentDate: new Date(),\n      phase: 'trust_building',\n      mandatoryApprovalWeeks: this.TRUST_BUILDING_WEEKS,\n      trustTaskThreshold: this.TRUST_TASK_THRESHOLD,\n      permanentApprovalActions: [...this.PERMANENT_APPROVAL_ACTIONS],\n      autoApprovalRules: {\n        enabled: false, // Disabled during trust building\n        maxImpactLevel: 'low',\n        maxRecordsAffected: 100,\n        maxRevenue: 1000,\n        requiredSuccessRate: 0.95,\n        minHistoricalTasks: 50\n      },\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n\n    await this.persistDeploymentConfig(config);\n    return config;\n  }\n\n  private async evaluatePhaseTransition(organizationId: string): Promise<void> {\n    const config = await this.getDeploymentConfiguration(organizationId);\n    const now = new Date();\n    const weeksActive = Math.floor((now.getTime() - config.deploymentDate.getTime()) / (7 * 24 * 60 * 60 * 1000));\n\n    // Get organization-wide metrics\n    const orgMetrics = await this.getOrganizationTrustMetrics(organizationId);\n\n    let newPhase = config.phase;\n\n    if (config.phase === 'trust_building') {\n      // Check if we can transition to graduated phase\n      if ((weeksActive >= config.mandatoryApprovalWeeks || orgMetrics.totalApprovedTasks >= config.trustTaskThreshold) &&\n          orgMetrics.averageSuccessRate >= 0.9) {\n        newPhase = 'graduated';\n        config.autoApprovalRules.enabled = true;\n        \n        logger.info('Organization transitioning to graduated autonomy phase', {\n          organizationId,\n          weeksActive,\n          totalApprovedTasks: orgMetrics.totalApprovedTasks,\n          successRate: orgMetrics.averageSuccessRate\n        });\n      }\n    } else if (config.phase === 'graduated') {\n      // Check if we can transition to autonomous phase (additional criteria)\n      if (weeksActive >= 24 && // 6 months minimum\n          orgMetrics.totalApprovedTasks >= 1000 &&\n          orgMetrics.averageSuccessRate >= 0.95) {\n        newPhase = 'autonomous';\n        \n        // Expand auto-approval rules for autonomous phase\n        config.autoApprovalRules.maxRecordsAffected = 1000;\n        config.autoApprovalRules.maxRevenue = 5000;\n        \n        logger.info('Organization transitioning to autonomous phase', {\n          organizationId,\n          weeksActive,\n          totalApprovedTasks: orgMetrics.totalApprovedTasks,\n          successRate: orgMetrics.averageSuccessRate\n        });\n      }\n    }\n\n    if (newPhase !== config.phase) {\n      config.phase = newPhase;\n      config.updatedAt = new Date();\n      this.deploymentConfigs.set(organizationId, config);\n      await this.persistDeploymentConfig(config);\n    }\n  }\n\n  private async getOrganizationTrustMetrics(organizationId: string): Promise<{\n    totalApprovedTasks: number;\n    averageSuccessRate: number;\n    activeUsers: number;\n  }> {\n    try {\n      const stats = await prisma.taskApprovalRequest.aggregate({\n        where: {\n          organizationId,\n          status: { in: ['approved', 'executed'] }\n        },\n        _count: { id: true },\n        _avg: { executionSuccess: true }\n      });\n\n      const userCount = await prisma.taskApprovalRequest.findMany({\n        where: { organizationId },\n        select: { userId: true },\n        distinct: ['userId']\n      });\n\n      return {\n        totalApprovedTasks: stats._count.id || 0,\n        averageSuccessRate: stats._avg.executionSuccess || 0,\n        activeUsers: userCount.length\n      };\n    } catch (error) {\n      logger.error('Failed to get organization trust metrics', { organizationId, error });\n      return { totalApprovedTasks: 0, averageSuccessRate: 0, activeUsers: 0 };\n    }\n  }\n\n  private canUserApprove(approverId: string, request: TaskApprovalRequest): boolean {\n    // Implement role-based approval logic\n    // This would check user roles and permissions\n    return true; // Simplified for now\n  }\n\n  private async updateTrustMetrics(\n    userId: string,\n    organizationId: string,\n    eventType: 'approved' | 'executed_success' | 'executed_failure'\n  ): Promise<void> {\n    // Update in-memory cache\n    const key = `${organizationId}_${userId}`;\n    const metrics = await this.getTrustMetrics(userId, organizationId);\n    \n    if (eventType === 'approved') {\n      metrics.totalApprovedTasks++;\n    } else if (eventType === 'executed_success') {\n      metrics.successfulExecutions++;\n    } else if (eventType === 'executed_failure') {\n      metrics.failedExecutions++;\n    }\n\n    // Recalculate derived metrics\n    const totalExecutions = metrics.successfulExecutions + metrics.failedExecutions;\n    metrics.successRate = totalExecutions > 0 ? metrics.successfulExecutions / totalExecutions : 0;\n    \n    // Recalculate trust score\n    const volumeScore = Math.min(metrics.totalApprovedTasks / 100, 1);\n    const consistencyScore = metrics.successRate;\n    metrics.trustScore = (volumeScore * 0.4 + consistencyScore * 0.6);\n    \n    metrics.lastEvaluated = new Date();\n    this.trustMetrics.set(key, metrics);\n  }\n\n  private async notifyApprovers(request: TaskApprovalRequest): Promise<void> {\n    // Implementation would send notifications via email, Slack, etc.\n    logger.info('Approval request notification sent', {\n      requestId: request.id,\n      actionType: request.actionType,\n      urgency: request.urgency,\n      approverRequired: request.approverRequired\n    });\n  }\n\n  private startApprovalMonitoring(): void {\n    // Check for expired approvals every 10 minutes\n    setInterval(async () => {\n      await this.handleExpiredApprovals();\n    }, 10 * 60 * 1000);\n\n    // Update trust metrics every hour\n    setInterval(async () => {\n      await this.updateAllTrustMetrics();\n    }, 60 * 60 * 1000);\n  }\n\n  private async handleExpiredApprovals(): Promise<void> {\n    const now = new Date();\n    let expiredCount = 0;\n\n    for (const [id, request] of this.pendingApprovals.entries()) {\n      if (request.status === 'pending' && now > request.expiresAt) {\n        request.status = 'expired';\n        await this.persistApprovalRequest(request);\n        expiredCount++;\n      }\n    }\n\n    if (expiredCount > 0) {\n      logger.info('Handled expired approval requests', { expiredCount });\n    }\n  }\n\n  private async updateAllTrustMetrics(): Promise<void> {\n    // Update trust metrics for all active users\n    for (const config of this.deploymentConfigs.values()) {\n      await this.evaluatePhaseTransition(config.organizationId);\n    }\n  }\n\n  /**\n   * Database persistence methods\n   */\n  private async persistApprovalRequest(request: TaskApprovalRequest): Promise<void> {\n    try {\n      await prisma.taskApprovalRequest.upsert({\n        where: { id: request.id },\n        update: {\n          status: request.status,\n          approvedBy: request.approvedBy,\n          approvedAt: request.approvedAt,\n          rejectedBy: request.rejectedBy,\n          rejectedAt: request.rejectedAt,\n          rejectionReason: request.rejectionReason,\n          executedAt: request.executedAt,\n          rollbackData: request.rollbackData,\n          metadata: request.metadata\n        },\n        create: {\n          id: request.id,\n          userId: request.userId,\n          organizationId: request.organizationId,\n          taskType: request.taskType,\n          actionType: request.actionType,\n          description: request.description,\n          parameters: request.parameters,\n          estimatedImpact: request.estimatedImpact,\n          urgency: request.urgency,\n          requestedAt: request.requestedAt,\n          expiresAt: request.expiresAt,\n          status: request.status,\n          approverRequired: request.approverRequired,\n          metadata: request.metadata\n        }\n      });\n    } catch (error) {\n      logger.error('Failed to persist approval request', { \n        requestId: request.id, \n        error: error instanceof Error ? error.message : String(error) \n      });\n    }\n  }\n\n  private async persistDeploymentConfig(config: DeploymentConfiguration): Promise<void> {\n    try {\n      await prisma.deploymentConfiguration.upsert({\n        where: { organizationId: config.organizationId },\n        update: {\n          phase: config.phase,\n          mandatoryApprovalWeeks: config.mandatoryApprovalWeeks,\n          trustTaskThreshold: config.trustTaskThreshold,\n          permanentApprovalActions: config.permanentApprovalActions,\n          autoApprovalRules: config.autoApprovalRules,\n          updatedAt: config.updatedAt\n        },\n        create: {\n          organizationId: config.organizationId,\n          deploymentDate: config.deploymentDate,\n          phase: config.phase,\n          mandatoryApprovalWeeks: config.mandatoryApprovalWeeks,\n          trustTaskThreshold: config.trustTaskThreshold,\n          permanentApprovalActions: config.permanentApprovalActions,\n          autoApprovalRules: config.autoApprovalRules,\n          createdAt: config.createdAt,\n          updatedAt: config.updatedAt\n        }\n      });\n    } catch (error) {\n      logger.error('Failed to persist deployment config', { \n        organizationId: config.organizationId, \n        error: error instanceof Error ? error.message : String(error) \n      });\n    }\n  }\n\n  private async loadApprovalRequest(requestId: string): Promise<TaskApprovalRequest | null> {\n    try {\n      const request = await prisma.taskApprovalRequest.findUnique({\n        where: { id: requestId }\n      });\n      return request as TaskApprovalRequest | null;\n    } catch (error) {\n      logger.error('Failed to load approval request', { requestId, error });\n      return null;\n    }\n  }\n\n  private async loadDeploymentConfigurations(): Promise<void> {\n    try {\n      const configs = await prisma.deploymentConfiguration.findMany();\n      configs.forEach(config => {\n        this.deploymentConfigs.set(config.organizationId, config as DeploymentConfiguration);\n      });\n    } catch (error) {\n      logger.error('Failed to load deployment configurations', { error });\n    }\n  }\n\n  private async loadTrustMetrics(): Promise<void> {\n    // Trust metrics are calculated on-demand to ensure freshness\n    logger.info('Trust metrics will be calculated on-demand');\n  }\n\n  /**\n   * Public API methods\n   */\n  async getSystemStatus(organizationId: string): Promise<{\n    phase: string;\n    weeksActive: number;\n    tasksApproved: number;\n    successRate: number;\n    autoApprovalEnabled: boolean;\n    pendingApprovals: number;\n  }> {\n    const config = await this.getDeploymentConfiguration(organizationId);\n    const orgMetrics = await this.getOrganizationTrustMetrics(organizationId);\n    const pendingCount = await this.getPendingApprovals(organizationId);\n\n    const now = new Date();\n    const weeksActive = Math.floor((now.getTime() - config.deploymentDate.getTime()) / (7 * 24 * 60 * 60 * 1000));\n\n    return {\n      phase: config.phase,\n      weeksActive,\n      tasksApproved: orgMetrics.totalApprovedTasks,\n      successRate: orgMetrics.averageSuccessRate,\n      autoApprovalEnabled: config.autoApprovalRules.enabled,\n      pendingApprovals: pendingCount.length\n    };\n  }\n}\n\n// Export singleton instance\nexport const mandatoryApprovalSystem = new MandatoryApprovalSystem();\n\n// Export types\nexport type {\n  TaskApprovalRequest,\n  TrustMetrics,\n  DeploymentConfiguration\n};"],"names":["mandatoryApprovalSystem","MandatoryApprovalSystem","constructor","pendingApprovals","Map","trustMetrics","deploymentConfigs","TRUST_BUILDING_WEEKS","TRUST_TASK_THRESHOLD","APPROVAL_TIMEOUT_HOURS","PERMANENT_APPROVAL_ACTIONS","initializeSystem","startApprovalMonitoring","loadDeploymentConfigurations","loadTrustMetrics","logger","info","trustBuildingWeeks","taskThreshold","permanentApprovalActions","requiresApproval","userId","organizationId","actionType","parameters","config","getDeploymentConfiguration","getTrustMetrics","includes","required","reason","phase","trustScore","autoApprovalEligible","weeksActive","mandatoryApprovalWeeks","totalApprovedTasks","trustTaskThreshold","eligible","isAutoApprovalEligible","autoApprovalCheck","error","Error","message","String","createApprovalRequest","userRole","taskType","description","estimatedImpact","urgency","requestId","Date","now","Math","random","toString","substr","expirationHours","approvalRequest","id","substring","requestedAt","expiresAt","status","approverRequired","getRequiredApprover","metadata","previousSimilarTasks","countSimilarTasks","successRate","deploymentPhase","set","persistApprovalRequest","notifyApprovers","toISOString","processApprovalDecision","approverId","decision","request","get","loadApprovalRequest","approvedBy","approvedAt","updateTrustMetrics","rejectedBy","rejectedAt","rejectionReason","success","executeApprovedAction","executionResult","executedAt","rollbackData","evaluatePhaseTransition","getPendingApprovals","limit","allRequests","Array","from","values","filter","filteredRequests","canUserApprove","sort","a","b","urgencyOrder","emergency","high","medium","low","urgencyDiff","getTime","slice","key","metrics","calculateTrustMetrics","createDefaultDeploymentConfig","autoApprovalRules","enabled","toFixed","requiredSuccessRate","minHistoricalTasks","eligibleTaskTypes","estimatedRecords","recordsAffected","estimatedRevenue","potentialRevenue","maxRecordsAffected","maxRevenue","riskLevel","count","prisma","taskExecution","where","createdAt","gte","warn","approvalHistory","taskApprovalRequest","findMany","in","orderBy","take","totalApproved","length","executed","r","successful","executionSuccess","volumeScore","min","consistencyScore","recentActivityScore","calculateRecentActivityScore","floor","deploymentDate","determineEligibleTaskTypes","successfulExecutions","failedExecutions","autoApprovalEnabled","permanentApprovalRequired","lastEvaluated","recentTasks","task","successfulRecent","eligibleTypes","taskTypeStats","reduce","acc","total","stats","Object","entries","minTasks","push","maxImpactLevel","updatedAt","persistDeploymentConfig","orgMetrics","getOrganizationTrustMetrics","newPhase","averageSuccessRate","aggregate","_count","_avg","userCount","select","distinct","activeUsers","eventType","totalExecutions","setInterval","handleExpiredApprovals","updateAllTrustMetrics","expiredCount","upsert","update","create","deploymentConfiguration","findUnique","configs","forEach","getSystemStatus","pendingCount","tasksApproved"],"mappings":"AAAA;;;;;;;;;;;CAWC;;;;+BAw/BYA;;;eAAAA;;;wBAt/BU;+DAGJ;;;;;;AAyEnB,MAAMC;IAiBJC,aAAc;aAhBNC,mBAAqD,IAAIC;aACzDC,eAA0C,IAAID;aAC9CE,oBAA0D,IAAIF;aACrDG,uBAAuB;aACvBC,uBAAuB;aACvBC,yBAAyB;QAE1C,iEAAiE;aAChDC,6BAA6B;YAC5C;YACA;YACA;YACA;YACA,gBAAwB,uBAAuB;SAChD;QAGC,IAAI,CAACC,gBAAgB;QACrB,IAAI,CAACC,uBAAuB;IAC9B;IAEA;;GAEC,GACD,MAAcD,mBAAkC;QAC9C,6CAA6C;QAC7C,MAAM,IAAI,CAACE,4BAA4B;QACvC,MAAM,IAAI,CAACC,gBAAgB;QAE3BC,cAAM,CAACC,IAAI,CAAC,yCAAyC;YACnDC,oBAAoB,IAAI,CAACV,oBAAoB;YAC7CW,eAAe,IAAI,CAACV,oBAAoB;YACxCW,0BAA0B,IAAI,CAACT,0BAA0B;QAC3D;IACF;IAEA;;GAEC,GACD,MAAMU,iBACJC,MAAc,EACdC,cAAsB,EACtBC,UAAkB,EAClBC,UAA+B,EAO9B;QACD,IAAI;YACF,+BAA+B;YAC/B,MAAMC,SAAS,MAAM,IAAI,CAACC,0BAA0B,CAACJ;YACrD,MAAMjB,eAAe,MAAM,IAAI,CAACsB,eAAe,CAACN,QAAQC;YAExD,yDAAyD;YACzD,IAAI,IAAI,CAACZ,0BAA0B,CAACkB,QAAQ,CAACL,aAAa;gBACxD,OAAO;oBACLM,UAAU;oBACVC,QAAQ;oBACRC,OAAON,OAAOM,KAAK;oBACnBC,YAAY3B,aAAa2B,UAAU;oBACnCC,sBAAsB;gBACxB;YACF;YAEA,yBAAyB;YACzB,OAAQR,OAAOM,KAAK;gBAClB,KAAK;oBACH,OAAO;wBACLF,UAAU;wBACVC,QAAQ,CAAC,sBAAsB,EAAEL,OAAOS,WAAW,CAAC,CAAC,EAAET,OAAOU,sBAAsB,CAAC,QAAQ,EAAE9B,aAAa+B,kBAAkB,CAAC,CAAC,EAAEX,OAAOY,kBAAkB,CAAC,eAAe,CAAC;wBAC5KN,OAAON,OAAOM,KAAK;wBACnBC,YAAY3B,aAAa2B,UAAU;wBACnCC,sBAAsB;oBACxB;gBAEF,KAAK;oBACH,8DAA8D;oBAC9D,MAAMK,WAAW,MAAM,IAAI,CAACC,sBAAsB,CAChDlB,QACAC,gBACAC,YACAC,YACAnB,cACAoB;oBAGF,IAAIa,SAASA,QAAQ,EAAE;wBACrB,OAAO;4BACLT,UAAU;4BACVC,QAAQ,CAAC,eAAe,EAAEQ,SAASR,MAAM,EAAE;4BAC3CC,OAAON,OAAOM,KAAK;4BACnBC,YAAY3B,aAAa2B,UAAU;4BACnCC,sBAAsB;wBACxB;oBACF,OAAO;wBACL,OAAO;4BACLJ,UAAU;4BACVC,QAAQ,CAAC,mBAAmB,EAAEQ,SAASR,MAAM,EAAE;4BAC/CC,OAAON,OAAOM,KAAK;4BACnBC,YAAY3B,aAAa2B,UAAU;4BACnCC,sBAAsB;wBACxB;oBACF;gBAEF,KAAK;oBACH,+DAA+D;oBAC/D,MAAMO,oBAAoB,MAAM,IAAI,CAACD,sBAAsB,CACzDlB,QACAC,gBACAC,YACAC,YACAnB,cACAoB;oBAGF,OAAO;wBACLI,UAAU,CAACW,kBAAkBF,QAAQ;wBACrCR,QAAQU,kBAAkBV,MAAM;wBAChCC,OAAON,OAAOM,KAAK;wBACnBC,YAAY3B,aAAa2B,UAAU;wBACnCC,sBAAsBO,kBAAkBF,QAAQ;oBAClD;gBAEF;oBACE,OAAO;wBACLT,UAAU;wBACVC,QAAQ;wBACRC,OAAO;wBACPC,YAAY;wBACZC,sBAAsB;oBACxB;YACJ;QAEF,EAAE,OAAOQ,OAAO;YACd1B,cAAM,CAAC0B,KAAK,CAAC,uCAAuC;gBAClDpB;gBACAC;gBACAC;gBACAkB,OAAOA,iBAAiBC,QAAQD,MAAME,OAAO,GAAGC,OAAOH;YACzD;YAEA,yCAAyC;YACzC,OAAO;gBACLZ,UAAU;gBACVC,QAAQ;gBACRC,OAAO;gBACPC,YAAY;gBACZC,sBAAsB;YACxB;QACF;IACF;IAEA;;GAEC,GACD,MAAMY,sBACJxB,MAAc,EACdyB,QAAgB,EAChBxB,cAAsB,EACtByB,QAAgB,EAChBxB,UAA6C,EAC7CyB,WAAmB,EACnBxB,UAA+B,EAC/ByB,eAAuD,EACvDC,UAA0C,QAAQ,EACjC;QACjB,MAAMC,YAAY,CAAC,SAAS,EAAEC,KAAKC,GAAG,GAAG,CAAC,EAAEC,KAAKC,MAAM,GAAGC,QAAQ,CAAC,IAAIC,MAAM,CAAC,GAAG,IAAI;QAErF,iCAAiC;QACjC,MAAMpD,eAAe,MAAM,IAAI,CAACsB,eAAe,CAACN,QAAQC;QACxD,MAAMG,SAAS,MAAM,IAAI,CAACC,0BAA0B,CAACJ;QAErD,wCAAwC;QACxC,MAAMoC,kBAAkBR,YAAY,cAAc,IAC3BA,YAAY,SAAS,IACrBA,YAAY,WAAW,KAAK;QAEnD,MAAMS,kBAAuC;YAC3CC,IAAIT;YACJ9B;YACAyB;YACAxB;YACAyB;YACAxB;YACAyB,aAAaA,YAAYa,SAAS,CAAC,GAAG;YACtCrC;YACAyB;YACAC;YACAY,aAAa,IAAIV;YACjBW,WAAW,IAAIX,KAAKA,KAAKC,GAAG,KAAKK,kBAAkB,KAAK,KAAK;YAC7DM,QAAQ;YACRC,kBAAkB,IAAI,CAACC,mBAAmB,CAAC3C,YAAYuB,UAAUG;YACjEkB,UAAU;gBACRnC,YAAY3B,aAAa2B,UAAU;gBACnCoC,sBAAsB,MAAM,IAAI,CAACC,iBAAiB,CAAChD,QAAQ0B;gBAC3DuB,aAAajE,aAAaiE,WAAW;gBACrCrC,sBAAsB;gBACtBsC,iBAAiB9C,OAAOM,KAAK;YAC/B;QACF;QAEA,oBAAoB;QACpB,IAAI,CAAC5B,gBAAgB,CAACqE,GAAG,CAACrB,WAAWQ;QACrC,MAAM,IAAI,CAACc,sBAAsB,CAACd;QAElC,kCAAkC;QAClC,MAAM,IAAI,CAACe,eAAe,CAACf;QAE3B5C,cAAM,CAACC,IAAI,CAAC,4BAA4B;YACtCmC;YACA9B;YACAE;YACA2B;YACAa,WAAWJ,gBAAgBI,SAAS,CAACY,WAAW;YAChDV,kBAAkBN,gBAAgBM,gBAAgB;QACpD;QAEA,OAAOd;IACT;IAEA;;GAEC,GACD,MAAMyB,wBACJzB,SAAiB,EACjB0B,UAAkB,EAClBC,QAA8B,EAC9BhD,MAAe,EAKd;QACD,MAAMiD,UAAU,IAAI,CAAC5E,gBAAgB,CAAC6E,GAAG,CAAC7B,cAAc,MAAM,IAAI,CAAC8B,mBAAmB,CAAC9B;QAEvF,IAAI,CAAC4B,SAAS;YACZ,MAAM,IAAIrC,MAAM,CAAC,iBAAiB,EAAES,UAAU,UAAU,CAAC;QAC3D;QAEA,IAAI4B,QAAQf,MAAM,KAAK,WAAW;YAChC,MAAM,IAAItB,MAAM,CAAC,QAAQ,EAAES,UAAU,YAAY,EAAE4B,QAAQf,MAAM,EAAE;QACrE;QAEA,IAAI,IAAIZ,SAAS2B,QAAQhB,SAAS,EAAE;YAClCgB,QAAQf,MAAM,GAAG;YACjB,MAAM,IAAI,CAACS,sBAAsB,CAACM;YAClC,MAAM,IAAIrC,MAAM,CAAC,QAAQ,EAAES,UAAU,YAAY,CAAC;QACpD;QAEA,MAAME,MAAM,IAAID;QAEhB,IAAI0B,aAAa,WAAW;YAC1BC,QAAQf,MAAM,GAAG;YACjBe,QAAQG,UAAU,GAAGL;YACrBE,QAAQI,UAAU,GAAG9B;YAErB,uBAAuB;YACvB,MAAM,IAAI,CAAC+B,kBAAkB,CAACL,QAAQ1D,MAAM,EAAE0D,QAAQzD,cAAc,EAAE;YAEtEP,cAAM,CAACC,IAAI,CAAC,6BAA6B;gBACvCmC;gBACA0B;gBACAtD,YAAYwD,QAAQxD,UAAU;gBAC9BF,QAAQ0D,QAAQ1D,MAAM;YACxB;QAEF,OAAO;YACL0D,QAAQf,MAAM,GAAG;YACjBe,QAAQM,UAAU,GAAGR;YACrBE,QAAQO,UAAU,GAAGjC;YACrB0B,QAAQQ,eAAe,GAAGzD,UAAU;YAEpCf,cAAM,CAACC,IAAI,CAAC,6BAA6B;gBACvCmC;gBACA0B;gBACAtD,YAAYwD,QAAQxD,UAAU;gBAC9BF,QAAQ0D,QAAQ1D,MAAM;gBACtBS;YACF;QACF;QAEA,wBAAwB;QACxB,IAAI,CAAC3B,gBAAgB,CAACqE,GAAG,CAACrB,WAAW4B;QACrC,MAAM,IAAI,CAACN,sBAAsB,CAACM;QAElC,OAAO;YACLS,SAAS;YACTT;YACApC,SAASmC,aAAa,YAAY,qBAAqB;QACzD;IACF;IAEA;;GAEC,GACD,MAAMW,sBACJtC,SAAiB,EACjBuC,eAKC,EACc;QACf,MAAMX,UAAU,IAAI,CAAC5E,gBAAgB,CAAC6E,GAAG,CAAC7B,cAAc,MAAM,IAAI,CAAC8B,mBAAmB,CAAC9B;QAEvF,IAAI,CAAC4B,SAAS;YACZ,MAAM,IAAIrC,MAAM,CAAC,iBAAiB,EAAES,UAAU,UAAU,CAAC;QAC3D;QAEA,IAAI4B,QAAQf,MAAM,KAAK,YAAY;YACjC,MAAM,IAAItB,MAAM,CAAC,QAAQ,EAAES,UAAU,0BAA0B,EAAE4B,QAAQf,MAAM,CAAC,CAAC,CAAC;QACpF;QAEAe,QAAQf,MAAM,GAAG;QACjBe,QAAQY,UAAU,GAAG,IAAIvC;QACzB2B,QAAQa,YAAY,GAAGF,gBAAgBE,YAAY;QAEnD,iDAAiD;QACjD,MAAM,IAAI,CAACR,kBAAkB,CAC3BL,QAAQ1D,MAAM,EACd0D,QAAQzD,cAAc,EACtBoE,gBAAgBF,OAAO,GAAG,qBAAqB;QAGjD,6CAA6C;QAC7C,MAAM,IAAI,CAACK,uBAAuB,CAACd,QAAQzD,cAAc;QAEzD,IAAI,CAACnB,gBAAgB,CAACqE,GAAG,CAACrB,WAAW4B;QACrC,MAAM,IAAI,CAACN,sBAAsB,CAACM;QAElChE,cAAM,CAACC,IAAI,CAAC,4BAA4B;YACtCmC;YACA5B,YAAYwD,QAAQxD,UAAU;YAC9BiE,SAASE,gBAAgBF,OAAO;YAChCnE,QAAQ0D,QAAQ1D,MAAM;QACxB;IACF;IAEA;;GAEC,GACD,MAAMyE,oBACJxE,cAAsB,EACtBuD,UAAmB,EACnBkB,QAAQ,EAAE,EACsB;QAChC,MAAMC,cAAcC,MAAMC,IAAI,CAAC,IAAI,CAAC/F,gBAAgB,CAACgG,MAAM,IACxDC,MAAM,CAACrB,CAAAA,UACNA,QAAQzD,cAAc,KAAKA,kBAC3ByD,QAAQf,MAAM,KAAK,aACnB,IAAIZ,UAAU2B,QAAQhB,SAAS;QAGnC,kCAAkC;QAClC,IAAIsC,mBAAmBL;QACvB,IAAInB,YAAY;YACd,sDAAsD;YACtDwB,mBAAmBL,YAAYI,MAAM,CAACrB,CAAAA,UACpC,IAAI,CAACuB,cAAc,CAACzB,YAAYE;QAEpC;QAEA,oCAAoC;QACpC,OAAOsB,iBACJE,IAAI,CAAC,CAACC,GAAGC;YACR,MAAMC,eAAe;gBAAEC,WAAW;gBAAGC,MAAM;gBAAGC,QAAQ;gBAAGC,KAAK;YAAE;YAChE,MAAMC,cAAcL,YAAY,CAACD,EAAEvD,OAAO,CAAC,GAAGwD,YAAY,CAACF,EAAEtD,OAAO,CAAC;YACrE,IAAI6D,gBAAgB,GAAG,OAAOA;YAC9B,OAAOP,EAAE1C,WAAW,CAACkD,OAAO,KAAKP,EAAE3C,WAAW,CAACkD,OAAO;QACxD,GACCC,KAAK,CAAC,GAAGlB;IACd;IAEA;;GAEC,GACD,MAAMpE,gBAAgBN,MAAc,EAAEC,cAAsB,EAAyB;QACnF,MAAM4F,MAAM,GAAG5F,eAAe,CAAC,EAAED,QAAQ;QACzC,IAAI8F,UAAU,IAAI,CAAC9G,YAAY,CAAC2E,GAAG,CAACkC;QAEpC,IAAI,CAACC,SAAS;YACZ,kCAAkC;YAClCA,UAAU,MAAM,IAAI,CAACC,qBAAqB,CAAC/F,QAAQC;YACnD,IAAI,CAACjB,YAAY,CAACmE,GAAG,CAAC0C,KAAKC;QAC7B;QAEA,OAAOA;IACT;IAEA;;GAEC,GACD,MAAMzF,2BAA2BJ,cAAsB,EAAoC;QACzF,IAAIG,SAAS,IAAI,CAACnB,iBAAiB,CAAC0E,GAAG,CAAC1D;QAExC,IAAI,CAACG,QAAQ;YACX,+BAA+B;YAC/BA,SAAS,MAAM,IAAI,CAAC4F,6BAA6B,CAAC/F;YAClD,IAAI,CAAChB,iBAAiB,CAACkE,GAAG,CAAClD,gBAAgBG;QAC7C;QAEA,OAAOA;IACT;IAEA;;GAEC,GACD,MAAcc,uBACZlB,MAAc,EACdC,cAAsB,EACtBC,UAAkB,EAClBC,UAA+B,EAC/BnB,YAA0B,EAC1BoB,MAA+B,EACiB;QAChD,oCAAoC;QACpC,IAAI,CAACA,OAAO6F,iBAAiB,CAACC,OAAO,EAAE;YACrC,OAAO;gBAAEjF,UAAU;gBAAOR,QAAQ;YAA0C;QAC9E;QAEA,8BAA8B;QAC9B,IAAIzB,aAAa2B,UAAU,GAAG,KAAK;YACjC,OAAO;gBAAEM,UAAU;gBAAOR,QAAQ,CAAC,qBAAqB,EAAEzB,aAAa2B,UAAU,CAACwF,OAAO,CAAC,IAAI;YAAC;QACjG;QAEA,qBAAqB;QACrB,IAAInH,aAAaiE,WAAW,GAAG7C,OAAO6F,iBAAiB,CAACG,mBAAmB,EAAE;YAC3E,OAAO;gBAAEnF,UAAU;gBAAOR,QAAQ,CAAC,sBAAsB,EAAE,AAACzB,CAAAA,aAAaiE,WAAW,GAAG,GAAE,EAAGkD,OAAO,CAAC,GAAG,CAAC,CAAC;YAAC;QAC5G;QAEA,iCAAiC;QACjC,IAAInH,aAAa+B,kBAAkB,GAAGX,OAAO6F,iBAAiB,CAACI,kBAAkB,EAAE;YACjF,OAAO;gBAAEpF,UAAU;gBAAOR,QAAQ,CAAC,2BAA2B,EAAEzB,aAAa+B,kBAAkB,CAAC,MAAM,CAAC;YAAC;QAC1G;QAEA,2CAA2C;QAC3C,IAAI,CAAC/B,aAAasH,iBAAiB,CAAC/F,QAAQ,CAACL,aAAa;YACxD,OAAO;gBAAEe,UAAU;gBAAOR,QAAQ,CAAC,YAAY,EAAEP,WAAW,+BAA+B,CAAC;YAAC;QAC/F;QAEA,gCAAgC;QAChC,MAAMqG,mBAAmBpG,WAAWqG,eAAe,IAAI;QACvD,MAAMC,mBAAmBtG,WAAWuG,gBAAgB,IAAI;QAExD,IAAIH,mBAAmBnG,OAAO6F,iBAAiB,CAACU,kBAAkB,EAAE;YAClE,OAAO;gBAAE1F,UAAU;gBAAOR,QAAQ,CAAC,2BAA2B,EAAE8F,kBAAkB;YAAC;QACrF;QAEA,IAAIE,mBAAmBrG,OAAO6F,iBAAiB,CAACW,UAAU,EAAE;YAC1D,OAAO;gBAAE3F,UAAU;gBAAOR,QAAQ,CAAC,yBAAyB,EAAEgG,kBAAkB;YAAC;QACnF;QAEA,OAAO;YAAExF,UAAU;YAAMR,QAAQ;QAAiC;IACpE;IAEQoC,oBACN3C,UAAkB,EAClBuB,QAAgB,EAChBG,eAAuD,EAC/C;QACR,6CAA6C;QAC7C,IAAIA,gBAAgBiF,SAAS,KAAK,cAAcjF,gBAAgB8E,gBAAgB,GAAG,OAAO;YACxF,OAAO;QACT;QAEA,sDAAsD;QACtD,IAAIxG,eAAe,iBAAiB;YAClC,OAAO;QACT;QAEA,mDAAmD;QACnD,IAAIA,eAAe,qBAAqB;YACtC,OAAO;QACT;QAEA,iCAAiC;QACjC,OAAO;IACT;IAEA,MAAc8C,kBAAkBhD,MAAc,EAAE0B,QAAgB,EAAmB;QACjF,IAAI;YACF,MAAMoF,QAAQ,MAAMC,eAAM,CAACC,aAAa,CAACF,KAAK,CAAC;gBAC7CG,OAAO;oBACLjH;oBACA0B;oBACAiB,QAAQ;oBACRuE,WAAW;wBACTC,KAAK,IAAIpF,KAAKA,KAAKC,GAAG,KAAK,KAAK,KAAK,KAAK,KAAK,MAAM,eAAe;oBACtE;gBACF;YACF;YACA,OAAO8E;QACT,EAAE,OAAO1F,OAAO;YACd1B,cAAM,CAAC0H,IAAI,CAAC,iCAAiC;gBAAEpH;gBAAQ0B;gBAAUN;YAAM;YACvE,OAAO;QACT;IACF;IAEA,MAAc2E,sBAAsB/F,MAAc,EAAEC,cAAsB,EAAyB;QACjG,IAAI;YACF,qCAAqC;YACrC,MAAMoH,kBAAkB,MAAMN,eAAM,CAACO,mBAAmB,CAACC,QAAQ,CAAC;gBAChEN,OAAO;oBACLjH;oBACAC;oBACA0C,QAAQ;wBAAE6E,IAAI;4BAAC;4BAAY;yBAAW;oBAAC;gBACzC;gBACAC,SAAS;oBAAEhF,aAAa;gBAAO;gBAC/BiF,MAAM,KAAK,wBAAwB;YACrC;YAEA,MAAMC,gBAAgBN,gBAAgBO,MAAM;YAC5C,MAAMC,WAAWR,gBAAgBtC,MAAM,CAAC+C,CAAAA,IAAKA,EAAEnF,MAAM,KAAK;YAC1D,MAAMoF,aAAaF,SAAS9C,MAAM,CAAC+C,CAAAA,IAAKA,EAAEE,gBAAgB,KAAK;YAE/D,MAAM/E,cAAc4E,SAASD,MAAM,GAAG,IAAIG,WAAWH,MAAM,GAAGC,SAASD,MAAM,GAAG;YAEhF,kDAAkD;YAClD,MAAMK,cAAchG,KAAKiG,GAAG,CAACP,gBAAgB,KAAK,IAAI,4BAA4B;YAClF,MAAMQ,mBAAmBlF;YACzB,MAAMmF,sBAAsB,IAAI,CAACC,4BAA4B,CAAChB;YAE9D,MAAM1G,aAAcsH,cAAc,MAAME,mBAAmB,MAAMC,sBAAsB;YAEvF,2CAA2C;YAC3C,MAAMhI,SAAS,MAAM,IAAI,CAACC,0BAA0B,CAACJ;YACrD,MAAMY,cAAcoB,KAAKqG,KAAK,CAAC,AAACvG,CAAAA,KAAKC,GAAG,KAAK5B,OAAOmI,cAAc,CAAC5C,OAAO,EAAC,IAAM,CAAA,IAAI,KAAK,KAAK,KAAK,IAAG;YAEvG,iDAAiD;YACjD,MAAMW,oBAAoB,IAAI,CAACkC,0BAA0B,CAACnB,iBAAiB1G;YAE3E,OAAO;gBACLV;gBACAD;gBACAe,oBAAoB4G;gBACpBc,sBAAsBV,WAAWH,MAAM;gBACvCc,kBAAkBb,SAASD,MAAM,GAAGG,WAAWH,MAAM;gBACrD3E;gBACAsF,gBAAgBnI,OAAOmI,cAAc;gBACrC1H;gBACAF;gBACAgI,qBAAqBvI,OAAO6F,iBAAiB,CAACC,OAAO,IAAIvF,cAAc;gBACvE2F;gBACAsC,2BAA2B;uBAAI,IAAI,CAACvJ,0BAA0B;iBAAC;gBAC/DwJ,eAAe,IAAI9G;YACrB;QAEF,EAAE,OAAOX,OAAO;YACd1B,cAAM,CAAC0B,KAAK,CAAC,qCAAqC;gBAAEpB;gBAAQC;gBAAgBmB;YAAM;YAElF,uBAAuB;YACvB,OAAO;gBACLnB;gBACAD;gBACAe,oBAAoB;gBACpB0H,sBAAsB;gBACtBC,kBAAkB;gBAClBzF,aAAa;gBACbsF,gBAAgB,IAAIxG;gBACpBlB,aAAa;gBACbF,YAAY;gBACZgI,qBAAqB;gBACrBrC,mBAAmB,EAAE;gBACrBsC,2BAA2B;uBAAI,IAAI,CAACvJ,0BAA0B;iBAAC;gBAC/DwJ,eAAe,IAAI9G;YACrB;QACF;IACF;IAEQsG,6BAA6BhB,eAAsB,EAAU;QACnE,MAAMyB,cAAczB,gBAAgBtC,MAAM,CAACgE,CAAAA,OACzCA,KAAKtG,WAAW,GAAG,IAAIV,KAAKA,KAAKC,GAAG,KAAK,KAAK,KAAK,KAAK,KAAK,MAAM,eAAe;;QAGpF,IAAI8G,YAAYlB,MAAM,KAAK,GAAG,OAAO;QAErC,MAAMoB,mBAAmBF,YAAY/D,MAAM,CAACgE,CAAAA,OAAQA,KAAKf,gBAAgB,KAAK;QAC9E,OAAOgB,iBAAiBpB,MAAM,GAAGkB,YAAYlB,MAAM;IACrD;IAEQY,2BAA2BnB,eAAsB,EAAE1G,UAAkB,EAAY;QACvF,MAAMsI,gBAA0B,EAAE;QAElC,kEAAkE;QAClE,MAAMC,gBAAgB7B,gBAAgB8B,MAAM,CAAC,CAACC,KAAKL;YACjD,IAAI,CAACK,GAAG,CAACL,KAAKrH,QAAQ,CAAC,EAAE;gBACvB0H,GAAG,CAACL,KAAKrH,QAAQ,CAAC,GAAG;oBAAE2H,OAAO;oBAAGtB,YAAY;gBAAE;YACjD;YACAqB,GAAG,CAACL,KAAKrH,QAAQ,CAAC,CAAC2H,KAAK;YACxB,IAAIN,KAAKf,gBAAgB,EAAE;gBACzBoB,GAAG,CAACL,KAAKrH,QAAQ,CAAC,CAACqG,UAAU;YAC/B;YACA,OAAOqB;QACT,GAAG,CAAC;QAEJ,KAAK,MAAM,CAAC1H,UAAU4H,MAAM,IAAIC,OAAOC,OAAO,CAACN,eAAgB;YAC7D,MAAMjG,cAAcqG,MAAMvB,UAAU,GAAGuB,MAAMD,KAAK;YAClD,MAAMI,WAAW,IAAI,uCAAuC;YAE5D,IAAIH,MAAMD,KAAK,IAAII,YAAYxG,eAAe,OAAOtC,cAAc,KAAK;gBACtE,mDAAmD;gBACnD,IAAI;oBAAC;oBAAa;oBAAa;oBAAe;iBAAqB,CAACJ,QAAQ,CAACmB,WAAW;oBACtFuH,cAAcS,IAAI,CAAChI;gBACrB;YACF;QACF;QAEA,OAAOuH;IACT;IAEA,MAAcjD,8BAA8B/F,cAAsB,EAAoC;QACpG,MAAMG,SAAkC;YACtCH;YACAsI,gBAAgB,IAAIxG;YACpBrB,OAAO;YACPI,wBAAwB,IAAI,CAAC5B,oBAAoB;YACjD8B,oBAAoB,IAAI,CAAC7B,oBAAoB;YAC7CW,0BAA0B;mBAAI,IAAI,CAACT,0BAA0B;aAAC;YAC9D4G,mBAAmB;gBACjBC,SAAS;gBACTyD,gBAAgB;gBAChBhD,oBAAoB;gBACpBC,YAAY;gBACZR,qBAAqB;gBACrBC,oBAAoB;YACtB;YACAa,WAAW,IAAInF;YACf6H,WAAW,IAAI7H;QACjB;QAEA,MAAM,IAAI,CAAC8H,uBAAuB,CAACzJ;QACnC,OAAOA;IACT;IAEA,MAAcoE,wBAAwBvE,cAAsB,EAAiB;QAC3E,MAAMG,SAAS,MAAM,IAAI,CAACC,0BAA0B,CAACJ;QACrD,MAAM+B,MAAM,IAAID;QAChB,MAAMlB,cAAcoB,KAAKqG,KAAK,CAAC,AAACtG,CAAAA,IAAI2D,OAAO,KAAKvF,OAAOmI,cAAc,CAAC5C,OAAO,EAAC,IAAM,CAAA,IAAI,KAAK,KAAK,KAAK,IAAG;QAE1G,gCAAgC;QAChC,MAAMmE,aAAa,MAAM,IAAI,CAACC,2BAA2B,CAAC9J;QAE1D,IAAI+J,WAAW5J,OAAOM,KAAK;QAE3B,IAAIN,OAAOM,KAAK,KAAK,kBAAkB;YACrC,gDAAgD;YAChD,IAAI,AAACG,CAAAA,eAAeT,OAAOU,sBAAsB,IAAIgJ,WAAW/I,kBAAkB,IAAIX,OAAOY,kBAAkB,AAAD,KAC1G8I,WAAWG,kBAAkB,IAAI,KAAK;gBACxCD,WAAW;gBACX5J,OAAO6F,iBAAiB,CAACC,OAAO,GAAG;gBAEnCxG,cAAM,CAACC,IAAI,CAAC,0DAA0D;oBACpEM;oBACAY;oBACAE,oBAAoB+I,WAAW/I,kBAAkB;oBACjDkC,aAAa6G,WAAWG,kBAAkB;gBAC5C;YACF;QACF,OAAO,IAAI7J,OAAOM,KAAK,KAAK,aAAa;YACvC,uEAAuE;YACvE,IAAIG,eAAe,MAAM,mBAAmB;YACxCiJ,WAAW/I,kBAAkB,IAAI,QACjC+I,WAAWG,kBAAkB,IAAI,MAAM;gBACzCD,WAAW;gBAEX,kDAAkD;gBAClD5J,OAAO6F,iBAAiB,CAACU,kBAAkB,GAAG;gBAC9CvG,OAAO6F,iBAAiB,CAACW,UAAU,GAAG;gBAEtClH,cAAM,CAACC,IAAI,CAAC,kDAAkD;oBAC5DM;oBACAY;oBACAE,oBAAoB+I,WAAW/I,kBAAkB;oBACjDkC,aAAa6G,WAAWG,kBAAkB;gBAC5C;YACF;QACF;QAEA,IAAID,aAAa5J,OAAOM,KAAK,EAAE;YAC7BN,OAAOM,KAAK,GAAGsJ;YACf5J,OAAOwJ,SAAS,GAAG,IAAI7H;YACvB,IAAI,CAAC9C,iBAAiB,CAACkE,GAAG,CAAClD,gBAAgBG;YAC3C,MAAM,IAAI,CAACyJ,uBAAuB,CAACzJ;QACrC;IACF;IAEA,MAAc2J,4BAA4B9J,cAAsB,EAI7D;QACD,IAAI;YACF,MAAMqJ,QAAQ,MAAMvC,eAAM,CAACO,mBAAmB,CAAC4C,SAAS,CAAC;gBACvDjD,OAAO;oBACLhH;oBACA0C,QAAQ;wBAAE6E,IAAI;4BAAC;4BAAY;yBAAW;oBAAC;gBACzC;gBACA2C,QAAQ;oBAAE5H,IAAI;gBAAK;gBACnB6H,MAAM;oBAAEpC,kBAAkB;gBAAK;YACjC;YAEA,MAAMqC,YAAY,MAAMtD,eAAM,CAACO,mBAAmB,CAACC,QAAQ,CAAC;gBAC1DN,OAAO;oBAAEhH;gBAAe;gBACxBqK,QAAQ;oBAAEtK,QAAQ;gBAAK;gBACvBuK,UAAU;oBAAC;iBAAS;YACtB;YAEA,OAAO;gBACLxJ,oBAAoBuI,MAAMa,MAAM,CAAC5H,EAAE,IAAI;gBACvC0H,oBAAoBX,MAAMc,IAAI,CAACpC,gBAAgB,IAAI;gBACnDwC,aAAaH,UAAUzC,MAAM;YAC/B;QACF,EAAE,OAAOxG,OAAO;YACd1B,cAAM,CAAC0B,KAAK,CAAC,4CAA4C;gBAAEnB;gBAAgBmB;YAAM;YACjF,OAAO;gBAAEL,oBAAoB;gBAAGkJ,oBAAoB;gBAAGO,aAAa;YAAE;QACxE;IACF;IAEQvF,eAAezB,UAAkB,EAAEE,OAA4B,EAAW;QAChF,sCAAsC;QACtC,8CAA8C;QAC9C,OAAO,MAAM,qBAAqB;IACpC;IAEA,MAAcK,mBACZ/D,MAAc,EACdC,cAAsB,EACtBwK,SAA+D,EAChD;QACf,yBAAyB;QACzB,MAAM5E,MAAM,GAAG5F,eAAe,CAAC,EAAED,QAAQ;QACzC,MAAM8F,UAAU,MAAM,IAAI,CAACxF,eAAe,CAACN,QAAQC;QAEnD,IAAIwK,cAAc,YAAY;YAC5B3E,QAAQ/E,kBAAkB;QAC5B,OAAO,IAAI0J,cAAc,oBAAoB;YAC3C3E,QAAQ2C,oBAAoB;QAC9B,OAAO,IAAIgC,cAAc,oBAAoB;YAC3C3E,QAAQ4C,gBAAgB;QAC1B;QAEA,8BAA8B;QAC9B,MAAMgC,kBAAkB5E,QAAQ2C,oBAAoB,GAAG3C,QAAQ4C,gBAAgB;QAC/E5C,QAAQ7C,WAAW,GAAGyH,kBAAkB,IAAI5E,QAAQ2C,oBAAoB,GAAGiC,kBAAkB;QAE7F,0BAA0B;QAC1B,MAAMzC,cAAchG,KAAKiG,GAAG,CAACpC,QAAQ/E,kBAAkB,GAAG,KAAK;QAC/D,MAAMoH,mBAAmBrC,QAAQ7C,WAAW;QAC5C6C,QAAQnF,UAAU,GAAIsH,cAAc,MAAME,mBAAmB;QAE7DrC,QAAQ+C,aAAa,GAAG,IAAI9G;QAC5B,IAAI,CAAC/C,YAAY,CAACmE,GAAG,CAAC0C,KAAKC;IAC7B;IAEA,MAAczC,gBAAgBK,OAA4B,EAAiB;QACzE,iEAAiE;QACjEhE,cAAM,CAACC,IAAI,CAAC,sCAAsC;YAChDmC,WAAW4B,QAAQnB,EAAE;YACrBrC,YAAYwD,QAAQxD,UAAU;YAC9B2B,SAAS6B,QAAQ7B,OAAO;YACxBe,kBAAkBc,QAAQd,gBAAgB;QAC5C;IACF;IAEQrD,0BAAgC;QACtC,+CAA+C;QAC/CoL,YAAY;YACV,MAAM,IAAI,CAACC,sBAAsB;QACnC,GAAG,KAAK,KAAK;QAEb,kCAAkC;QAClCD,YAAY;YACV,MAAM,IAAI,CAACE,qBAAqB;QAClC,GAAG,KAAK,KAAK;IACf;IAEA,MAAcD,yBAAwC;QACpD,MAAM5I,MAAM,IAAID;QAChB,IAAI+I,eAAe;QAEnB,KAAK,MAAM,CAACvI,IAAImB,QAAQ,IAAI,IAAI,CAAC5E,gBAAgB,CAAC0K,OAAO,GAAI;YAC3D,IAAI9F,QAAQf,MAAM,KAAK,aAAaX,MAAM0B,QAAQhB,SAAS,EAAE;gBAC3DgB,QAAQf,MAAM,GAAG;gBACjB,MAAM,IAAI,CAACS,sBAAsB,CAACM;gBAClCoH;YACF;QACF;QAEA,IAAIA,eAAe,GAAG;YACpBpL,cAAM,CAACC,IAAI,CAAC,qCAAqC;gBAAEmL;YAAa;QAClE;IACF;IAEA,MAAcD,wBAAuC;QACnD,4CAA4C;QAC5C,KAAK,MAAMzK,UAAU,IAAI,CAACnB,iBAAiB,CAAC6F,MAAM,GAAI;YACpD,MAAM,IAAI,CAACN,uBAAuB,CAACpE,OAAOH,cAAc;QAC1D;IACF;IAEA;;GAEC,GACD,MAAcmD,uBAAuBM,OAA4B,EAAiB;QAChF,IAAI;YACF,MAAMqD,eAAM,CAACO,mBAAmB,CAACyD,MAAM,CAAC;gBACtC9D,OAAO;oBAAE1E,IAAImB,QAAQnB,EAAE;gBAAC;gBACxByI,QAAQ;oBACNrI,QAAQe,QAAQf,MAAM;oBACtBkB,YAAYH,QAAQG,UAAU;oBAC9BC,YAAYJ,QAAQI,UAAU;oBAC9BE,YAAYN,QAAQM,UAAU;oBAC9BC,YAAYP,QAAQO,UAAU;oBAC9BC,iBAAiBR,QAAQQ,eAAe;oBACxCI,YAAYZ,QAAQY,UAAU;oBAC9BC,cAAcb,QAAQa,YAAY;oBAClCzB,UAAUY,QAAQZ,QAAQ;gBAC5B;gBACAmI,QAAQ;oBACN1I,IAAImB,QAAQnB,EAAE;oBACdvC,QAAQ0D,QAAQ1D,MAAM;oBACtBC,gBAAgByD,QAAQzD,cAAc;oBACtCyB,UAAUgC,QAAQhC,QAAQ;oBAC1BxB,YAAYwD,QAAQxD,UAAU;oBAC9ByB,aAAa+B,QAAQ/B,WAAW;oBAChCxB,YAAYuD,QAAQvD,UAAU;oBAC9ByB,iBAAiB8B,QAAQ9B,eAAe;oBACxCC,SAAS6B,QAAQ7B,OAAO;oBACxBY,aAAaiB,QAAQjB,WAAW;oBAChCC,WAAWgB,QAAQhB,SAAS;oBAC5BC,QAAQe,QAAQf,MAAM;oBACtBC,kBAAkBc,QAAQd,gBAAgB;oBAC1CE,UAAUY,QAAQZ,QAAQ;gBAC5B;YACF;QACF,EAAE,OAAO1B,OAAO;YACd1B,cAAM,CAAC0B,KAAK,CAAC,sCAAsC;gBACjDU,WAAW4B,QAAQnB,EAAE;gBACrBnB,OAAOA,iBAAiBC,QAAQD,MAAME,OAAO,GAAGC,OAAOH;YACzD;QACF;IACF;IAEA,MAAcyI,wBAAwBzJ,MAA+B,EAAiB;QACpF,IAAI;YACF,MAAM2G,eAAM,CAACmE,uBAAuB,CAACH,MAAM,CAAC;gBAC1C9D,OAAO;oBAAEhH,gBAAgBG,OAAOH,cAAc;gBAAC;gBAC/C+K,QAAQ;oBACNtK,OAAON,OAAOM,KAAK;oBACnBI,wBAAwBV,OAAOU,sBAAsB;oBACrDE,oBAAoBZ,OAAOY,kBAAkB;oBAC7ClB,0BAA0BM,OAAON,wBAAwB;oBACzDmG,mBAAmB7F,OAAO6F,iBAAiB;oBAC3C2D,WAAWxJ,OAAOwJ,SAAS;gBAC7B;gBACAqB,QAAQ;oBACNhL,gBAAgBG,OAAOH,cAAc;oBACrCsI,gBAAgBnI,OAAOmI,cAAc;oBACrC7H,OAAON,OAAOM,KAAK;oBACnBI,wBAAwBV,OAAOU,sBAAsB;oBACrDE,oBAAoBZ,OAAOY,kBAAkB;oBAC7ClB,0BAA0BM,OAAON,wBAAwB;oBACzDmG,mBAAmB7F,OAAO6F,iBAAiB;oBAC3CiB,WAAW9G,OAAO8G,SAAS;oBAC3B0C,WAAWxJ,OAAOwJ,SAAS;gBAC7B;YACF;QACF,EAAE,OAAOxI,OAAO;YACd1B,cAAM,CAAC0B,KAAK,CAAC,uCAAuC;gBAClDnB,gBAAgBG,OAAOH,cAAc;gBACrCmB,OAAOA,iBAAiBC,QAAQD,MAAME,OAAO,GAAGC,OAAOH;YACzD;QACF;IACF;IAEA,MAAcwC,oBAAoB9B,SAAiB,EAAuC;QACxF,IAAI;YACF,MAAM4B,UAAU,MAAMqD,eAAM,CAACO,mBAAmB,CAAC6D,UAAU,CAAC;gBAC1DlE,OAAO;oBAAE1E,IAAIT;gBAAU;YACzB;YACA,OAAO4B;QACT,EAAE,OAAOtC,OAAO;YACd1B,cAAM,CAAC0B,KAAK,CAAC,mCAAmC;gBAAEU;gBAAWV;YAAM;YACnE,OAAO;QACT;IACF;IAEA,MAAc5B,+BAA8C;QAC1D,IAAI;YACF,MAAM4L,UAAU,MAAMrE,eAAM,CAACmE,uBAAuB,CAAC3D,QAAQ;YAC7D6D,QAAQC,OAAO,CAACjL,CAAAA;gBACd,IAAI,CAACnB,iBAAiB,CAACkE,GAAG,CAAC/C,OAAOH,cAAc,EAAEG;YACpD;QACF,EAAE,OAAOgB,OAAO;YACd1B,cAAM,CAAC0B,KAAK,CAAC,4CAA4C;gBAAEA;YAAM;QACnE;IACF;IAEA,MAAc3B,mBAAkC;QAC9C,6DAA6D;QAC7DC,cAAM,CAACC,IAAI,CAAC;IACd;IAEA;;GAEC,GACD,MAAM2L,gBAAgBrL,cAAsB,EAOzC;QACD,MAAMG,SAAS,MAAM,IAAI,CAACC,0BAA0B,CAACJ;QACrD,MAAM6J,aAAa,MAAM,IAAI,CAACC,2BAA2B,CAAC9J;QAC1D,MAAMsL,eAAe,MAAM,IAAI,CAAC9G,mBAAmB,CAACxE;QAEpD,MAAM+B,MAAM,IAAID;QAChB,MAAMlB,cAAcoB,KAAKqG,KAAK,CAAC,AAACtG,CAAAA,IAAI2D,OAAO,KAAKvF,OAAOmI,cAAc,CAAC5C,OAAO,EAAC,IAAM,CAAA,IAAI,KAAK,KAAK,KAAK,IAAG;QAE1G,OAAO;YACLjF,OAAON,OAAOM,KAAK;YACnBG;YACA2K,eAAe1B,WAAW/I,kBAAkB;YAC5CkC,aAAa6G,WAAWG,kBAAkB;YAC1CtB,qBAAqBvI,OAAO6F,iBAAiB,CAACC,OAAO;YACrDpH,kBAAkByM,aAAa3D,MAAM;QACvC;IACF;AACF;AAGO,MAAMjJ,0BAA0B,IAAIC"}