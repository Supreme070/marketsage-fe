{"version":3,"sources":["/Users/supreme/Desktop/marketsage/src/lib/ai/safety-approval-system.ts"],"sourcesContent":["/**\n * Safety & Approval Workflow System\n * =================================\n * Comprehensive safety system that evaluates, approves, and monitors dangerous operations\n * Prevents unauthorized actions and provides rollback capabilities\n */\n\nimport { logger } from '@/lib/logger';\nimport prisma from '@/lib/db/prisma';\nimport { recordTaskExecution } from './task-execution-monitor';\nimport { AuthorizationService, Permission } from '@/lib/security/authorization';\nimport { TransactionManager } from '@/lib/security/transaction-manager';\nimport { SecurityValidator } from '@/lib/security/input-validation';\n\nexport interface SafetyRule {\n  id: string;\n  name: string;\n  description: string;\n  category: 'user_management' | 'data_destruction' | 'system_config' | 'financial' | 'bulk_operations';\n  riskLevel: 'low' | 'medium' | 'high' | 'critical';\n  condition: (operation: OperationRequest) => boolean;\n  requiredRole: 'USER' | 'IT_ADMIN' | 'ADMIN' | 'SUPER_ADMIN';\n  requiresApproval: boolean;\n  maxRetries: number;\n  cooldownPeriod: number; // minutes\n}\n\nexport interface OperationRequest {\n  id: string;\n  userId: string;\n  userRole: string;\n  operationType: string;\n  entity: string;\n  action: string;\n  parameters: Record<string, any>;\n  affectedRecords?: number;\n  context: {\n    sessionId: string;\n    timestamp: Date;\n    ipAddress?: string;\n    userAgent?: string;\n  };\n}\n\nexport interface ApprovalRequest {\n  id: string;\n  operationId: string;\n  requesterId: string;\n  requesterRole: string;\n  approvalLevel: 'admin' | 'super_admin' | 'multi_admin';\n  operation: OperationRequest;\n  justification: string;\n  expiresAt: Date;\n  status: 'pending' | 'approved' | 'rejected' | 'expired';\n  approvedBy?: string;\n  approvedAt?: Date;\n  rejectionReason?: string;\n  autoRollbackScheduled?: boolean;\n}\n\nexport interface SafetyAssessment {\n  operationId: string;\n  riskLevel: 'low' | 'medium' | 'high' | 'critical';\n  violatedRules: string[];\n  requiredApprovals: string[];\n  canProceed: boolean;\n  warnings: string[];\n  restrictions: string[];\n  rollbackStrategy?: RollbackStrategy;\n  estimatedImpact: {\n    affectedUsers: number;\n    affectedRecords: number;\n    systemDowntime: number; // minutes\n    reversibility: 'full' | 'partial' | 'none';\n  };\n}\n\nexport interface RollbackStrategy {\n  id: string;\n  operationId: string;\n  strategy: 'automatic' | 'manual' | 'impossible';\n  backupData?: any;\n  rollbackSteps: RollbackStep[];\n  timeLimit: number; // minutes\n  dependencies: string[];\n}\n\nexport interface RollbackStep {\n  id: string;\n  description: string;\n  action: string;\n  parameters: Record<string, any>;\n  order: number;\n  critical: boolean;\n}\n\ninterface SmartApprovalMetrics {\n  userTrustScore: number;\n  operationSuccessRate: number;\n  averageRiskLevel: number;\n  autoApprovalEligible: boolean;\n  historicalPatterns: {\n    commonOperations: string[];\n    typicalRiskLevel: string;\n    averageApprovalTime: number;\n    rejectionRate: number;\n  };\n}\n\ninterface LearningPattern {\n  operationType: string;\n  entity: string;\n  action: string;\n  userRole: string;\n  riskLevel: string;\n  approved: boolean;\n  approvalTime: number;\n  outcome: 'success' | 'failure' | 'rollback';\n  timestamp: Date;\n}\n\nclass SafetyApprovalSystem {\n  private safetyRules: Map<string, SafetyRule> = new Map();\n  private pendingApprovals: Map<string, ApprovalRequest> = new Map();\n  private operationHistory: Map<string, OperationRequest[]> = new Map();\n  private learningPatterns: Map<string, LearningPattern[]> = new Map();\n  private userTrustScores: Map<string, number> = new Map();\n  private smartApprovalThresholds = {\n    trustScoreMinimum: 0.8,\n    successRateMinimum: 0.95,\n    maxAutoApprovalRisk: 'medium' as const,\n    learningPeriodDays: 30,\n    patternConfidenceThreshold: 0.9\n  };\n\n  constructor() {\n    this.initializeSafetyRules();\n    this.startApprovalCleanup();\n    this.startLearningEngine();\n    this.loadHistoricalPatterns();\n  }\n\n  /**\n   * Initialize comprehensive safety rules\n   */\n  private initializeSafetyRules() {\n    // User Management Safety Rules\n    this.addSafetyRule({\n      id: 'prevent_self_deletion',\n      name: 'Prevent Self-Deletion',\n      description: 'Users cannot delete their own accounts',\n      category: 'user_management',\n      riskLevel: 'high',\n      condition: (op) => op.action === 'DELETE' && op.entity === 'USER' && op.parameters.userId === op.userId,\n      requiredRole: 'SUPER_ADMIN',\n      requiresApproval: true,\n      maxRetries: 0,\n      cooldownPeriod: 60\n    });\n\n    this.addSafetyRule({\n      id: 'prevent_last_admin_deletion',\n      name: 'Prevent Last Admin Deletion',\n      description: 'Cannot delete the last admin user',\n      category: 'user_management',\n      riskLevel: 'critical',\n      condition: (op) => op.action === 'DELETE' && op.entity === 'USER' && op.parameters.role === 'SUPER_ADMIN',\n      requiredRole: 'SUPER_ADMIN',\n      requiresApproval: true,\n      maxRetries: 0,\n      cooldownPeriod: 1440 // 24 hours\n    });\n\n    this.addSafetyRule({\n      id: 'role_escalation_control',\n      name: 'Role Escalation Control',\n      description: 'Only SUPER_ADMIN can create ADMIN or SUPER_ADMIN users',\n      category: 'user_management',\n      riskLevel: 'high',\n      condition: (op) => op.action === 'CREATE' && op.entity === 'USER' && \n                         ['ADMIN', 'SUPER_ADMIN'].includes(op.parameters.role) && \n                         op.userRole !== 'SUPER_ADMIN',\n      requiredRole: 'SUPER_ADMIN',\n      requiresApproval: true,\n      maxRetries: 1,\n      cooldownPeriod: 30\n    });\n\n    // Data Destruction Safety Rules\n    this.addSafetyRule({\n      id: 'bulk_deletion_limit',\n      name: 'Bulk Deletion Limit',\n      description: 'Bulk deletions affecting >100 records require approval',\n      category: 'bulk_operations',\n      riskLevel: 'high',\n      condition: (op) => op.action === 'DELETE' && (op.affectedRecords || 0) > 100,\n      requiredRole: 'ADMIN',\n      requiresApproval: true,\n      maxRetries: 1,\n      cooldownPeriod: 60\n    });\n\n    this.addSafetyRule({\n      id: 'organization_deletion',\n      name: 'Organization Deletion',\n      description: 'Organization deletion requires multi-admin approval',\n      category: 'system_config',\n      riskLevel: 'critical',\n      condition: (op) => op.action === 'DELETE' && op.entity === 'ORGANIZATION',\n      requiredRole: 'SUPER_ADMIN',\n      requiresApproval: true,\n      maxRetries: 0,\n      cooldownPeriod: 10080 // 7 days\n    });\n\n    // Financial Safety Rules\n    this.addSafetyRule({\n      id: 'high_value_transaction',\n      name: 'High Value Transaction',\n      description: 'Transactions over $10,000 require approval',\n      category: 'financial',\n      riskLevel: 'high',\n      condition: (op) => op.operationType === 'payment' && (op.parameters.amount || 0) > 10000,\n      requiredRole: 'ADMIN',\n      requiresApproval: true,\n      maxRetries: 2,\n      cooldownPeriod: 120\n    });\n\n    // System Configuration Safety Rules\n    this.addSafetyRule({\n      id: 'integration_modification',\n      name: 'Integration Modification',\n      description: 'Critical integration changes require approval',\n      category: 'system_config',\n      riskLevel: 'medium',\n      condition: (op) => op.entity === 'INTEGRATION' && ['UPDATE', 'DELETE'].includes(op.action),\n      requiredRole: 'IT_ADMIN',\n      requiresApproval: true,\n      maxRetries: 2,\n      cooldownPeriod: 30\n    });\n\n    // Rate limiting for sensitive operations\n    this.addSafetyRule({\n      id: 'rapid_user_creation',\n      name: 'Rapid User Creation',\n      description: 'Creating >5 users in 10 minutes requires cooling down',\n      category: 'user_management',\n      riskLevel: 'medium',\n      condition: (op) => {\n        if (op.action !== 'CREATE' || op.entity !== 'USER') return false;\n        const userHistory = this.operationHistory.get(op.userId) || [];\n        const recentCreations = userHistory.filter(\n          hist => hist.action === 'CREATE' && \n                  hist.entity === 'USER' && \n                  Date.now() - hist.context.timestamp.getTime() < 10 * 60 * 1000\n        );\n        return recentCreations.length >= 5;\n      },\n      requiredRole: 'ADMIN',\n      requiresApproval: false,\n      maxRetries: 0,\n      cooldownPeriod: 10\n    });\n  }\n\n  /**\n   * Add a safety rule to the system\n   */\n  private addSafetyRule(rule: SafetyRule) {\n    this.safetyRules.set(rule.id, rule);\n  }\n\n  /**\n   * Get smart approval metrics for a user\n   */\n  async getSmartApprovalMetrics(userId: string): Promise<SmartApprovalMetrics> {\n    const userPatterns = this.learningPatterns.get(userId) || [];\n    const recentPatterns = userPatterns.filter(p => \n      p.timestamp > new Date(Date.now() - this.smartApprovalThresholds.learningPeriodDays * 24 * 60 * 60 * 1000)\n    );\n\n    const trustScore = this.userTrustScores.get(userId) || 0.5;\n    const successfulOps = recentPatterns.filter(p => p.outcome === 'success').length;\n    const totalOps = recentPatterns.length;\n    const successRate = totalOps > 0 ? successfulOps / totalOps : 0;\n\n    const riskLevels = recentPatterns.map(p => p.riskLevel);\n    const avgRiskValue = this.calculateAverageRiskLevel(riskLevels);\n\n    const operationTypes = recentPatterns.map(p => `${p.operationType}:${p.entity}:${p.action}`);\n    const commonOperations = this.getMostCommonItems(operationTypes, 5);\n\n    const approvedPatterns = recentPatterns.filter(p => p.approved);\n    const avgApprovalTime = approvedPatterns.length > 0 \n      ? approvedPatterns.reduce((sum, p) => sum + p.approvalTime, 0) / approvedPatterns.length \n      : 0;\n\n    const rejectionRate = totalOps > 0 \n      ? recentPatterns.filter(p => !p.approved).length / totalOps \n      : 0;\n\n    const autoApprovalEligible = \n      trustScore >= this.smartApprovalThresholds.trustScoreMinimum &&\n      successRate >= this.smartApprovalThresholds.successRateMinimum &&\n      avgRiskValue <= this.getRiskLevelValue(this.smartApprovalThresholds.maxAutoApprovalRisk) &&\n      rejectionRate < 0.1;\n\n    return {\n      userTrustScore: trustScore,\n      operationSuccessRate: successRate,\n      averageRiskLevel: avgRiskValue,\n      autoApprovalEligible,\n      historicalPatterns: {\n        commonOperations,\n        typicalRiskLevel: this.getTypicalRiskLevel(riskLevels),\n        averageApprovalTime: avgApprovalTime,\n        rejectionRate\n      }\n    };\n  }\n\n  /**\n   * Smart approval decision based on patterns and trust\n   */\n  async makeSmartApprovalDecision(\n    operation: OperationRequest, \n    assessment: SafetyAssessment\n  ): Promise<{ \n    autoApprove: boolean; \n    confidence: number; \n    reasoning: string[]; \n    suggestedApprovalLevel?: string;\n  }> {\n    const metrics = await this.getSmartApprovalMetrics(operation.userId);\n    const reasoning: string[] = [];\n    let confidence = 0;\n    let autoApprove = false;\n\n    // Check if operation matches common patterns\n    const operationSignature = `${operation.operationType}:${operation.entity}:${operation.action}`;\n    const isCommonOperation = metrics.historicalPatterns.commonOperations.includes(operationSignature);\n\n    if (isCommonOperation) {\n      confidence += 0.3;\n      reasoning.push('Operation matches user\\'s common patterns');\n    }\n\n    // Check trust score\n    if (metrics.userTrustScore >= this.smartApprovalThresholds.trustScoreMinimum) {\n      confidence += 0.3;\n      reasoning.push(`High user trust score: ${(metrics.userTrustScore * 100).toFixed(1)}%`);\n    }\n\n    // Check success rate\n    if (metrics.operationSuccessRate >= this.smartApprovalThresholds.successRateMinimum) {\n      confidence += 0.2;\n      reasoning.push(`Excellent operation success rate: ${(metrics.operationSuccessRate * 100).toFixed(1)}%`);\n    }\n\n    // Check risk level\n    if (assessment.riskLevel === 'low' || \n        (assessment.riskLevel === 'medium' && metrics.autoApprovalEligible)) {\n      confidence += 0.2;\n      reasoning.push(`Acceptable risk level: ${assessment.riskLevel}`);\n    }\n\n    // Final decision\n    autoApprove = \n      confidence >= this.smartApprovalThresholds.patternConfidenceThreshold &&\n      metrics.autoApprovalEligible &&\n      assessment.riskLevel !== 'critical' &&\n      assessment.riskLevel !== 'high';\n\n    if (!autoApprove && confidence > 0.7) {\n      reasoning.push('Recommend expedited manual review due to high confidence');\n    }\n\n    // Learn from this assessment\n    this.recordLearningPattern(operation, assessment, autoApprove);\n\n    return {\n      autoApprove,\n      confidence,\n      reasoning,\n      suggestedApprovalLevel: this.suggestApprovalLevel(assessment.riskLevel, confidence)\n    };\n  }\n\n  /**\n   * Assess safety of an operation with smart approval\n   */\n  async assessOperation(operation: OperationRequest): Promise<SafetyAssessment> {\n    try {\n      logger.info('Assessing operation safety', {\n        operationId: operation.id,\n        userId: operation.userId,\n        action: operation.action,\n        entity: operation.entity\n      });\n\n      const violatedRules: string[] = [];\n      const warnings: string[] = [];\n      const restrictions: string[] = [];\n      const requiredApprovals: string[] = [];\n      let highestRiskLevel: 'low' | 'medium' | 'high' | 'critical' = 'low';\n\n      // Check each safety rule\n      for (const [ruleId, rule] of this.safetyRules.entries()) {\n        try {\n          if (rule.condition(operation)) {\n            violatedRules.push(ruleId);\n            \n            if (this.getRiskLevelValue(rule.riskLevel) > this.getRiskLevelValue(highestRiskLevel)) {\n              highestRiskLevel = rule.riskLevel;\n            }\n\n            if (rule.requiresApproval) {\n              requiredApprovals.push(ruleId);\n            }\n\n            warnings.push(`${rule.name}: ${rule.description}`);\n\n            // Check role requirements\n            if (!this.hasRequiredRole(operation.userRole, rule.requiredRole)) {\n              restrictions.push(`Requires ${rule.requiredRole} role or higher`);\n            }\n\n            // Check cooldown period\n            if (await this.isInCooldown(operation.userId, ruleId, rule.cooldownPeriod)) {\n              restrictions.push(`Operation is in cooldown period for ${rule.cooldownPeriod} minutes`);\n            }\n          }\n        } catch (ruleError) {\n          logger.warn('Safety rule evaluation failed', {\n            ruleId,\n            error: ruleError instanceof Error ? ruleError.message : String(ruleError)\n          });\n        }\n      }\n\n      // Estimate impact\n      const estimatedImpact = await this.estimateImpact(operation);\n\n      // Create rollback strategy if needed\n      const rollbackStrategy = this.createRollbackStrategy(operation, highestRiskLevel);\n\n      const assessment: SafetyAssessment = {\n        operationId: operation.id,\n        riskLevel: highestRiskLevel,\n        violatedRules,\n        requiredApprovals,\n        canProceed: restrictions.length === 0 && requiredApprovals.length === 0,\n        warnings,\n        restrictions,\n        rollbackStrategy,\n        estimatedImpact\n      };\n\n      // Record the assessment\n      await this.recordAssessment(operation, assessment);\n\n      // Check for smart approval if assessment requires approval\n      if (requiredApprovals.length > 0 && restrictions.length === 0) {\n        const smartDecision = await this.makeSmartApprovalDecision(operation, assessment);\n        \n        if (smartDecision.autoApprove) {\n          // Auto-approve low-risk operations for trusted users\n          assessment.canProceed = true;\n          assessment.requiredApprovals = [];\n          assessment.warnings.push('Auto-approved based on user trust and patterns');\n          assessment.warnings.push(...smartDecision.reasoning);\n          \n          // Record auto-approval\n          await this.recordAutoApproval(operation, assessment, smartDecision);\n          \n          logger.info('Operation auto-approved by smart system', {\n            operationId: operation.id,\n            userId: operation.userId,\n            confidence: smartDecision.confidence,\n            reasoning: smartDecision.reasoning\n          });\n        } else if (smartDecision.confidence > 0.7) {\n          // Add recommendation for expedited review\n          assessment.warnings.push('High confidence for approval - expedited review recommended');\n          assessment.warnings.push(...smartDecision.reasoning);\n        }\n      }\n\n      return assessment;\n\n    } catch (error) {\n      logger.error('Safety assessment failed', {\n        operationId: operation.id,\n        error: error instanceof Error ? error.message : String(error)\n      });\n\n      return {\n        operationId: operation.id,\n        riskLevel: 'critical',\n        violatedRules: ['assessment_failed'],\n        requiredApprovals: ['manual_review'],\n        canProceed: false,\n        warnings: ['Safety assessment failed - manual review required'],\n        restrictions: ['Operation blocked due to assessment failure'],\n        estimatedImpact: {\n          affectedUsers: 0,\n          affectedRecords: 0,\n          systemDowntime: 0,\n          reversibility: 'none'\n        }\n      };\n    }\n  }\n\n  /**\n   * Request approval for a dangerous operation\n   */\n  async requestApproval(\n    operation: OperationRequest,\n    assessment: SafetyAssessment,\n    justification: string\n  ): Promise<ApprovalRequest> {\n    const approvalId = this.generateApprovalId();\n    \n    // Determine approval level based on risk\n    let approvalLevel: 'admin' | 'super_admin' | 'multi_admin';\n    if (assessment.riskLevel === 'critical') {\n      approvalLevel = 'multi_admin';\n    } else if (assessment.riskLevel === 'high') {\n      approvalLevel = 'super_admin';\n    } else {\n      approvalLevel = 'admin';\n    }\n\n    const approvalRequest: ApprovalRequest = {\n      id: approvalId,\n      operationId: operation.id,\n      requesterId: operation.userId,\n      requesterRole: operation.userRole,\n      approvalLevel,\n      operation,\n      justification,\n      expiresAt: new Date(Date.now() + this.getApprovalTimeout(assessment.riskLevel)),\n      status: 'pending',\n      autoRollbackScheduled: assessment.riskLevel === 'critical'\n    };\n\n    // Store the approval request\n    this.pendingApprovals.set(approvalId, approvalRequest);\n\n    // Save to database\n    await prisma.approvalRequest.create({\n      data: {\n        id: approvalId,\n        operationId: operation.id,\n        requesterId: operation.userId,\n        approvalLevel,\n        operationData: operation,\n        justification,\n        expiresAt: approvalRequest.expiresAt,\n        status: 'pending'\n      }\n    });\n\n    // Send notifications to approvers\n    await this.notifyApprovers(approvalRequest);\n\n    logger.info('Approval request created', {\n      approvalId,\n      operationId: operation.id,\n      approvalLevel,\n      riskLevel: assessment.riskLevel\n    });\n\n    return approvalRequest;\n  }\n\n  /**\n   * Approve an operation\n   */\n  async approveOperation(\n    approvalId: string,\n    approverId: string,\n    approverRole: string\n  ): Promise<{ success: boolean; message: string }> {\n    const approval = this.pendingApprovals.get(approvalId);\n    if (!approval) {\n      return { success: false, message: 'Approval request not found' };\n    }\n\n    if (approval.status !== 'pending') {\n      return { success: false, message: 'Approval request is no longer pending' };\n    }\n\n    if (approval.expiresAt < new Date()) {\n      approval.status = 'expired';\n      return { success: false, message: 'Approval request has expired' };\n    }\n\n    // Check if approver has sufficient role\n    const hasPermission = this.canApprove(approverRole, approval.approvalLevel);\n    if (!hasPermission) {\n      return { success: false, message: 'Insufficient permissions to approve this operation' };\n    }\n\n    // Update approval\n    approval.status = 'approved';\n    approval.approvedBy = approverId;\n    approval.approvedAt = new Date();\n\n    // Update database\n    await prisma.approvalRequest.update({\n      where: { id: approvalId },\n      data: {\n        status: 'approved',\n        approvedBy: approverId,\n        approvedAt: new Date()\n      }\n    });\n\n    // Schedule auto-rollback if needed\n    if (approval.autoRollbackScheduled) {\n      await this.scheduleAutoRollback(approval);\n    }\n\n    logger.info('Operation approved', {\n      approvalId,\n      operationId: approval.operationId,\n      approverId,\n      approverRole\n    });\n\n    return { success: true, message: 'Operation approved successfully' };\n  }\n\n  /**\n   * Reject an operation\n   */\n  async rejectOperation(\n    approvalId: string,\n    approverId: string,\n    reason: string\n  ): Promise<{ success: boolean; message: string }> {\n    const approval = this.pendingApprovals.get(approvalId);\n    if (!approval) {\n      return { success: false, message: 'Approval request not found' };\n    }\n\n    if (approval.status !== 'pending') {\n      return { success: false, message: 'Approval request is no longer pending' };\n    }\n\n    // Update approval\n    approval.status = 'rejected';\n    approval.rejectionReason = reason;\n\n    // Update database\n    await prisma.approvalRequest.update({\n      where: { id: approvalId },\n      data: {\n        status: 'rejected',\n        rejectionReason: reason\n      }\n    });\n\n    logger.info('Operation rejected', {\n      approvalId,\n      operationId: approval.operationId,\n      approverId,\n      reason\n    });\n\n    return { success: true, message: 'Operation rejected' };\n  }\n\n  /**\n   * Check if an operation is approved\n   */\n  async isOperationApproved(operationId: string): Promise<boolean> {\n    const approval = Array.from(this.pendingApprovals.values())\n      .find(a => a.operationId === operationId);\n    \n    return approval?.status === 'approved' || false;\n  }\n\n  /**\n   * Create rollback strategy\n   */\n  private createRollbackStrategy(operation: OperationRequest, riskLevel: string): RollbackStrategy | undefined {\n    if (operation.action === 'DELETE' || riskLevel === 'critical') {\n      const rollbackId = this.generateRollbackId();\n      \n      return {\n        id: rollbackId,\n        operationId: operation.id,\n        strategy: operation.action === 'DELETE' ? 'impossible' : 'manual',\n        rollbackSteps: this.generateRollbackSteps(operation),\n        timeLimit: this.getRollbackTimeLimit(riskLevel),\n        dependencies: []\n      };\n    }\n    \n    return undefined;\n  }\n\n  /**\n   * Generate rollback steps\n   */\n  private generateRollbackSteps(operation: OperationRequest): RollbackStep[] {\n    const steps: RollbackStep[] = [];\n    \n    switch (operation.action) {\n      case 'CREATE':\n        steps.push({\n          id: 'rollback_create',\n          description: `Delete created ${operation.entity.toLowerCase()}`,\n          action: 'DELETE',\n          parameters: { id: operation.parameters.id },\n          order: 1,\n          critical: true\n        });\n        break;\n        \n      case 'UPDATE':\n        steps.push({\n          id: 'rollback_update',\n          description: `Restore previous ${operation.entity.toLowerCase()} state`,\n          action: 'UPDATE',\n          parameters: { id: operation.parameters.id, previousState: 'TO_BE_CAPTURED' },\n          order: 1,\n          critical: true\n        });\n        break;\n    }\n    \n    return steps;\n  }\n\n  /**\n   * Helper methods\n   */\n  private getRiskLevelValue(level: string): number {\n    const values = { low: 1, medium: 2, high: 3, critical: 4 };\n    return values[level] || 1;\n  }\n\n  private hasRequiredRole(userRole: string, requiredRole: string): boolean {\n    const hierarchy = ['USER', 'IT_ADMIN', 'ADMIN', 'SUPER_ADMIN'];\n    const userIndex = hierarchy.indexOf(userRole);\n    const requiredIndex = hierarchy.indexOf(requiredRole);\n    return userIndex >= requiredIndex;\n  }\n\n  private async isInCooldown(userId: string, ruleId: string, cooldownMinutes: number): Promise<boolean> {\n    const lastViolation = await prisma.safetyViolation.findFirst({\n      where: {\n        userId,\n        ruleId,\n        createdAt: {\n          gte: new Date(Date.now() - cooldownMinutes * 60 * 1000)\n        }\n      },\n      orderBy: { createdAt: 'desc' }\n    });\n    \n    return !!lastViolation;\n  }\n\n  private async estimateImpact(operation: OperationRequest): Promise<SafetyAssessment['estimatedImpact']> {\n    // Mock implementation - in production, this would analyze actual data\n    return {\n      affectedUsers: operation.affectedRecords || 1,\n      affectedRecords: operation.affectedRecords || 1,\n      systemDowntime: 0,\n      reversibility: operation.action === 'DELETE' ? 'none' : 'full'\n    };\n  }\n\n  private async recordAssessment(operation: OperationRequest, assessment: SafetyAssessment): Promise<void> {\n    if (assessment.violatedRules.length > 0) {\n      await prisma.safetyViolation.create({\n        data: {\n          userId: operation.userId,\n          ruleId: assessment.violatedRules[0],\n          operationId: operation.id,\n          riskLevel: assessment.riskLevel,\n          details: {\n            operation,\n            assessment\n          }\n        }\n      });\n    }\n  }\n\n  private canApprove(approverRole: string, requiredLevel: string): boolean {\n    if (requiredLevel === 'multi_admin') {\n      return approverRole === 'SUPER_ADMIN'; // For now, only SUPER_ADMIN can approve critical\n    }\n    if (requiredLevel === 'super_admin') {\n      return ['SUPER_ADMIN'].includes(approverRole);\n    }\n    return ['ADMIN', 'SUPER_ADMIN'].includes(approverRole);\n  }\n\n  private getApprovalTimeout(riskLevel: string): number {\n    const timeouts = {\n      low: 60 * 60 * 1000,      // 1 hour\n      medium: 30 * 60 * 1000,   // 30 minutes\n      high: 15 * 60 * 1000,     // 15 minutes\n      critical: 5 * 60 * 1000   // 5 minutes\n    };\n    return timeouts[riskLevel] || timeouts.medium;\n  }\n\n  private getRollbackTimeLimit(riskLevel: string): number {\n    const limits = { low: 1440, medium: 720, high: 180, critical: 60 }; // minutes\n    return limits[riskLevel] || limits.medium;\n  }\n\n  private async notifyApprovers(approval: ApprovalRequest): Promise<void> {\n    // In production, this would send notifications to appropriate approvers\n    logger.info('Approval notification sent', {\n      approvalId: approval.id,\n      approvalLevel: approval.approvalLevel\n    });\n  }\n\n  private async scheduleAutoRollback(approval: ApprovalRequest): Promise<void> {\n    // In production, this would schedule automatic rollback\n    logger.info('Auto-rollback scheduled', {\n      approvalId: approval.id,\n      operationId: approval.operationId\n    });\n  }\n\n  private startApprovalCleanup(): void {\n    // Clean up expired approvals every 5 minutes\n    setInterval(async () => {\n      const now = new Date();\n      for (const [id, approval] of this.pendingApprovals.entries()) {\n        if (approval.expiresAt < now && approval.status === 'pending') {\n          approval.status = 'expired';\n          await prisma.approvalRequest.update({\n            where: { id },\n            data: { status: 'expired' }\n          });\n          this.pendingApprovals.delete(id);\n        }\n      }\n    }, 5 * 60 * 1000);\n  }\n\n  private generateApprovalId(): string {\n    return `approval_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generateRollbackId(): string {\n    return `rollback_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Smart approval helper methods\n   */\n  private calculateAverageRiskLevel(riskLevels: string[]): number {\n    if (riskLevels.length === 0) return 0;\n    \n    const sum = riskLevels.reduce((acc, level) => acc + this.getRiskLevelValue(level), 0);\n    return sum / riskLevels.length;\n  }\n\n  private getMostCommonItems(items: string[], limit: number): string[] {\n    const counts = items.reduce((acc, item) => {\n      acc[item] = (acc[item] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    return Object.entries(counts)\n      .sort(([,a], [,b]) => b - a)\n      .slice(0, limit)\n      .map(([item]) => item);\n  }\n\n  private getTypicalRiskLevel(riskLevels: string[]): string {\n    const counts = riskLevels.reduce((acc, level) => {\n      acc[level] = (acc[level] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    const sorted = Object.entries(counts).sort(([,a], [,b]) => b - a);\n    return sorted.length > 0 ? sorted[0][0] : 'medium';\n  }\n\n  private suggestApprovalLevel(riskLevel: string, confidence: number): string {\n    if (riskLevel === 'critical') return 'multi_admin';\n    if (riskLevel === 'high') return 'super_admin';\n    if (confidence < 0.5) return 'super_admin';\n    if (confidence < 0.7) return 'admin';\n    return 'auto';\n  }\n\n  private async recordLearningPattern(\n    operation: OperationRequest, \n    assessment: SafetyAssessment, \n    autoApproved: boolean\n  ): Promise<void> {\n    const pattern: LearningPattern = {\n      operationType: operation.operationType,\n      entity: operation.entity,\n      action: operation.action,\n      userRole: operation.userRole,\n      riskLevel: assessment.riskLevel,\n      approved: autoApproved || assessment.canProceed,\n      approvalTime: 0, // Will be updated when approval completes\n      outcome: 'success', // Will be updated based on execution\n      timestamp: new Date()\n    };\n\n    const userPatterns = this.learningPatterns.get(operation.userId) || [];\n    userPatterns.push(pattern);\n    \n    // Keep only recent patterns\n    const cutoff = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000); // 90 days\n    const recentPatterns = userPatterns.filter(p => p.timestamp > cutoff);\n    \n    this.learningPatterns.set(operation.userId, recentPatterns);\n\n    // Update trust score\n    await this.updateUserTrustScore(operation.userId);\n  }\n\n  private async updateUserTrustScore(userId: string): Promise<void> {\n    const patterns = this.learningPatterns.get(userId) || [];\n    const recentPatterns = patterns.filter(p => \n      p.timestamp > new Date(Date.now() - this.smartApprovalThresholds.learningPeriodDays * 24 * 60 * 60 * 1000)\n    );\n\n    if (recentPatterns.length < 5) {\n      // Not enough data for trust score\n      this.userTrustScores.set(userId, 0.5);\n      return;\n    }\n\n    const successCount = recentPatterns.filter(p => p.outcome === 'success').length;\n    const rollbackCount = recentPatterns.filter(p => p.outcome === 'rollback').length;\n    const failureCount = recentPatterns.filter(p => p.outcome === 'failure').length;\n    \n    const successRate = successCount / recentPatterns.length;\n    const rollbackPenalty = rollbackCount * 0.1;\n    const failurePenalty = failureCount * 0.2;\n    \n    const trustScore = Math.max(0, Math.min(1, successRate - rollbackPenalty - failurePenalty));\n    \n    this.userTrustScores.set(userId, trustScore);\n  }\n\n  private async recordAutoApproval(\n    operation: OperationRequest,\n    assessment: SafetyAssessment,\n    decision: any\n  ): Promise<void> {\n    try {\n      await prisma.approvalRequest.create({\n        data: {\n          id: `auto_${operation.id}`,\n          operationId: operation.id,\n          requesterId: operation.userId,\n          approvalLevel: 'auto',\n          operationData: operation,\n          justification: 'Auto-approved by smart approval system',\n          expiresAt: new Date(Date.now() + 5 * 60 * 1000), // 5 minutes\n          status: 'approved',\n          approvedBy: 'SMART_APPROVAL_SYSTEM',\n          approvedAt: new Date()\n        }\n      });\n    } catch (error) {\n      logger.warn('Failed to record auto-approval', { error });\n    }\n  }\n\n  /**\n   * Learning engine methods\n   */\n  private startLearningEngine(): void {\n    // Update trust scores periodically\n    setInterval(() => {\n      this.updateAllUserTrustScores();\n    }, 60 * 60 * 1000); // Every hour\n\n    // Clean up old patterns\n    setInterval(() => {\n      this.cleanupOldPatterns();\n    }, 24 * 60 * 60 * 1000); // Daily\n  }\n\n  private async updateAllUserTrustScores(): Promise<void> {\n    for (const userId of this.learningPatterns.keys()) {\n      await this.updateUserTrustScore(userId);\n    }\n    \n    logger.info('Updated user trust scores', {\n      totalUsers: this.userTrustScores.size,\n      averageTrustScore: Array.from(this.userTrustScores.values())\n        .reduce((sum, score) => sum + score, 0) / Math.max(1, this.userTrustScores.size)\n    });\n  }\n\n  private cleanupOldPatterns(): void {\n    const cutoff = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000); // 90 days\n    \n    for (const [userId, patterns] of this.learningPatterns.entries()) {\n      const recentPatterns = patterns.filter(p => p.timestamp > cutoff);\n      if (recentPatterns.length === 0) {\n        this.learningPatterns.delete(userId);\n        this.userTrustScores.delete(userId);\n      } else {\n        this.learningPatterns.set(userId, recentPatterns);\n      }\n    }\n  }\n\n  private async loadHistoricalPatterns(): Promise<void> {\n    try {\n      // Load recent approval patterns from database\n      const recentApprovals = await prisma.approvalRequest.findMany({\n        where: {\n          createdAt: {\n            gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // Last 30 days\n          }\n        },\n        take: 1000,\n        orderBy: { createdAt: 'desc' }\n      });\n\n      // Convert to learning patterns\n      for (const approval of recentApprovals) {\n        const operation = approval.operationData as OperationRequest;\n        if (operation) {\n          const pattern: LearningPattern = {\n            operationType: operation.operationType,\n            entity: operation.entity,\n            action: operation.action,\n            userRole: operation.userRole,\n            riskLevel: 'medium', // Default if not stored\n            approved: approval.status === 'approved',\n            approvalTime: approval.approvedAt ? \n              approval.approvedAt.getTime() - approval.createdAt.getTime() : 0,\n            outcome: 'success', // Default, will be updated from execution logs\n            timestamp: approval.createdAt\n          };\n\n          const userId = approval.requesterId;\n          const userPatterns = this.learningPatterns.get(userId) || [];\n          userPatterns.push(pattern);\n          this.learningPatterns.set(userId, userPatterns);\n        }\n      }\n\n      // Initial trust score calculation\n      await this.updateAllUserTrustScores();\n\n      logger.info('Loaded historical approval patterns', {\n        totalPatterns: Array.from(this.learningPatterns.values())\n          .reduce((sum, patterns) => sum + patterns.length, 0),\n        totalUsers: this.learningPatterns.size\n      });\n\n    } catch (error) {\n      logger.warn('Failed to load historical patterns', { error });\n    }\n  }\n\n  /**\n   * Update learning outcome after task execution\n   */\n  async updateLearningOutcome(\n    operationId: string,\n    userId: string,\n    outcome: 'success' | 'failure' | 'rollback'\n  ): Promise<void> {\n    const patterns = this.learningPatterns.get(userId) || [];\n    const pattern = patterns.find(p => \n      // Find pattern by matching operation characteristics and timing\n      Math.abs(p.timestamp.getTime() - Date.now()) < 24 * 60 * 60 * 1000\n    );\n\n    if (pattern) {\n      pattern.outcome = outcome;\n      await this.updateUserTrustScore(userId);\n      \n      logger.info('Updated learning pattern outcome', {\n        userId,\n        operationId,\n        outcome,\n        newTrustScore: this.userTrustScores.get(userId)\n      });\n    }\n  }\n\n  /**\n   * Add operation to user history for rate limiting\n   */\n  addToHistory(operation: OperationRequest): void {\n    const userHistory = this.operationHistory.get(operation.userId) || [];\n    userHistory.push(operation);\n    \n    // Keep only last 100 operations\n    if (userHistory.length > 100) {\n      userHistory.shift();\n    }\n    \n    this.operationHistory.set(operation.userId, userHistory);\n  }\n\n  /**\n   * Get pending approvals for a user\n   */\n  getPendingApprovals(userId: string): ApprovalRequest[] {\n    return Array.from(this.pendingApprovals.values())\n      .filter(approval => approval.requesterId === userId);\n  }\n\n  /**\n   * Get approvals requiring action from a specific role\n   */\n  getApprovalsForRole(role: string): ApprovalRequest[] {\n    return Array.from(this.pendingApprovals.values())\n      .filter(approval => \n        approval.status === 'pending' && \n        this.canApprove(role, approval.approvalLevel)\n      );\n  }\n}\n\n// Export singleton instance\nexport const safetyApprovalSystem = new SafetyApprovalSystem();\n\n// Export types\nexport type { SafetyApprovalSystem };"],"names":["safetyApprovalSystem","SafetyApprovalSystem","constructor","safetyRules","Map","pendingApprovals","operationHistory","learningPatterns","userTrustScores","smartApprovalThresholds","trustScoreMinimum","successRateMinimum","maxAutoApprovalRisk","learningPeriodDays","patternConfidenceThreshold","initializeSafetyRules","startApprovalCleanup","startLearningEngine","loadHistoricalPatterns","addSafetyRule","id","name","description","category","riskLevel","condition","op","action","entity","parameters","userId","requiredRole","requiresApproval","maxRetries","cooldownPeriod","role","includes","userRole","affectedRecords","operationType","amount","userHistory","get","recentCreations","filter","hist","Date","now","context","timestamp","getTime","length","rule","set","getSmartApprovalMetrics","userPatterns","recentPatterns","p","trustScore","successfulOps","outcome","totalOps","successRate","riskLevels","map","avgRiskValue","calculateAverageRiskLevel","operationTypes","commonOperations","getMostCommonItems","approvedPatterns","approved","avgApprovalTime","reduce","sum","approvalTime","rejectionRate","autoApprovalEligible","getRiskLevelValue","userTrustScore","operationSuccessRate","averageRiskLevel","historicalPatterns","typicalRiskLevel","getTypicalRiskLevel","averageApprovalTime","makeSmartApprovalDecision","operation","assessment","metrics","reasoning","confidence","autoApprove","operationSignature","isCommonOperation","push","toFixed","recordLearningPattern","suggestedApprovalLevel","suggestApprovalLevel","assessOperation","logger","info","operationId","violatedRules","warnings","restrictions","requiredApprovals","highestRiskLevel","ruleId","entries","hasRequiredRole","isInCooldown","ruleError","warn","error","Error","message","String","estimatedImpact","estimateImpact","rollbackStrategy","createRollbackStrategy","canProceed","recordAssessment","smartDecision","recordAutoApproval","affectedUsers","systemDowntime","reversibility","requestApproval","justification","approvalId","generateApprovalId","approvalLevel","approvalRequest","requesterId","requesterRole","expiresAt","getApprovalTimeout","status","autoRollbackScheduled","prisma","create","data","operationData","notifyApprovers","approveOperation","approverId","approverRole","approval","success","hasPermission","canApprove","approvedBy","approvedAt","update","where","scheduleAutoRollback","rejectOperation","reason","rejectionReason","isOperationApproved","Array","from","values","find","a","rollbackId","generateRollbackId","strategy","rollbackSteps","generateRollbackSteps","timeLimit","getRollbackTimeLimit","dependencies","undefined","steps","toLowerCase","order","critical","previousState","level","low","medium","high","hierarchy","userIndex","indexOf","requiredIndex","cooldownMinutes","lastViolation","safetyViolation","findFirst","createdAt","gte","orderBy","details","requiredLevel","timeouts","limits","setInterval","delete","Math","random","toString","substr","acc","items","limit","counts","item","Object","sort","b","slice","sorted","autoApproved","pattern","cutoff","updateUserTrustScore","patterns","successCount","rollbackCount","failureCount","rollbackPenalty","failurePenalty","max","min","decision","updateAllUserTrustScores","cleanupOldPatterns","keys","totalUsers","size","averageTrustScore","score","recentApprovals","findMany","take","totalPatterns","updateLearningOutcome","abs","newTrustScore","addToHistory","shift","getPendingApprovals","getApprovalsForRole"],"mappings":"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"}