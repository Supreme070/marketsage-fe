{"version":3,"sources":["/Users/supreme/Desktop/marketsage/src/lib/enhanced-conversions.ts"],"sourcesContent":["/**\n * Enhanced Conversion Tracking & Attribution\n * \n * This module provides advanced functionality for tracking conversions,\n * implementing different attribution models, and analyzing funnel performance.\n */\n\nimport {\n  AttributionModel,\n  type ConversionCategory,\n  type ConversionValueType,\n  type EntityType,\n} from '@prisma/client';\nimport prisma from '@/lib/db/prisma';\nimport { logger } from '@/lib/logger';\nimport { randomUUID } from 'crypto';\n\n// Types for conversion tracking\nexport interface ConversionEventData {\n  name: string;\n  description?: string;\n  eventType: string;\n  category: ConversionCategory;\n  valueType: ConversionValueType;\n  isSystem?: boolean;\n}\n\nexport interface ConversionTrackingData {\n  eventId: string;\n  entityType: EntityType;\n  entityId: string;\n  contactId?: string;\n  value?: number;\n  metadata?: Record<string, any>;\n  attributionModel?: AttributionModel;\n  touchPoints?: TouchPoint[];\n}\n\nexport interface TouchPoint {\n  entityType: EntityType;\n  entityId: string;\n  timestamp: Date;\n  type: string;\n  weight?: number;\n}\n\nexport interface FunnelStage {\n  eventId: string;\n  name: string;\n  count: number;\n  dropOffRate?: number;\n  conversionRate?: number;\n  totalValue?: number;\n}\n\nexport interface FunnelData {\n  name: string;\n  totalEntries: number;\n  totalConversions: number;\n  conversionRate: number;\n  totalValue: number;\n  stages: FunnelStage[];\n  startDate: Date;\n  endDate: Date;\n}\n\n// Standard conversion event types\nexport const ConversionEventTypes = {\n  // Email events\n  EMAIL_OPEN: 'email_open',\n  EMAIL_CLICK: 'email_click',\n  EMAIL_REPLY: 'email_reply',\n  \n  // SMS events\n  SMS_DELIVERY: 'sms_delivery',\n  SMS_REPLY: 'sms_reply',\n  \n  // WhatsApp events\n  WHATSAPP_DELIVERY: 'whatsapp_delivery',\n  WHATSAPP_READ: 'whatsapp_read',\n  WHATSAPP_REPLY: 'whatsapp_reply',\n  \n  // Web events\n  PAGE_VIEW: 'page_view',\n  CONTENT_VIEW: 'content_view',\n  FORM_START: 'form_start',\n  FORM_SUBMIT: 'form_submit',\n  \n  // E-commerce events\n  PRODUCT_VIEW: 'product_view',\n  ADD_TO_CART: 'add_to_cart',\n  CHECKOUT_START: 'checkout_start',\n  PURCHASE: 'purchase',\n  \n  // Custom event prefix\n  CUSTOM: 'custom_'\n};\n\n/**\n * Create a new conversion event type\n */\nexport async function createConversionEvent(\n  data: ConversionEventData,\n  userId: string\n): Promise<string> {\n  try {\n    const event = await prisma.conversionEvent.create({\n      data: {\n        id: randomUUID(),\n        name: data.name,\n        description: data.description,\n        eventType: data.eventType,\n        category: data.category,\n        valueType: data.valueType,\n        isSystem: data.isSystem || false,\n        createdById: userId,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      },\n    });\n    \n    logger.info(`Created conversion event: ${event.id}`, { eventId: event.id, name: data.name });\n    \n    return event.id;\n  } catch (error) {\n    logger.error('Error creating conversion event', error);\n    throw error;\n  }\n}\n\n/**\n * Track a conversion with the specified attribution model\n */\nexport async function trackConversion(data: ConversionTrackingData): Promise<boolean> {\n  try {\n    // Get attribution settings for default values\n    const attributionSettings = await getAttributionSettings();\n    \n    // Create the conversion record\n    await prisma.conversionTracking.create({\n      data: {\n        id: randomUUID(),\n        eventId: data.eventId,\n        entityType: data.entityType,\n        entityId: data.entityId,\n        contactId: data.contactId,\n        value: data.value,\n        metadata: data.metadata ? JSON.stringify(data.metadata) : null,\n        attributionModel: data.attributionModel || attributionSettings.defaultModel,\n        touchPoints: data.touchPoints ? JSON.stringify(data.touchPoints) : null,\n        occurredAt: new Date(),\n      },\n    });\n    \n    return true;\n  } catch (error) {\n    logger.error('Error tracking conversion', error);\n    return false;\n  }\n}\n\n/**\n * Get attribution settings\n */\nexport async function getAttributionSettings(): Promise<{\n  defaultModel: AttributionModel;\n  customWeights?: Record<string, number>;\n  lookbackWindow: number;\n}> {\n  try {\n    // Look for existing settings\n    const settings = await prisma.attributionSettings.findFirst();\n    \n    if (settings) {\n      return {\n        defaultModel: settings.defaultModel,\n        customWeights: settings.customWeights ? JSON.parse(settings.customWeights) : undefined,\n        lookbackWindow: settings.lookbackWindow,\n      };\n    }\n    \n    // Create default settings if none exist\n    const defaultSettings = await prisma.attributionSettings.create({\n      data: {\n        id: randomUUID(),\n        defaultModel: AttributionModel.LAST_TOUCH,\n        lookbackWindow: 30,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      },\n    });\n    \n    return {\n      defaultModel: defaultSettings.defaultModel,\n      lookbackWindow: defaultSettings.lookbackWindow,\n    };\n  } catch (error) {\n    logger.error('Error getting attribution settings', error);\n    // Return sensible defaults if there's an error\n    return {\n      defaultModel: AttributionModel.LAST_TOUCH,\n      lookbackWindow: 30,\n    };\n  }\n}\n\n/**\n * Update attribution settings\n */\nexport async function updateAttributionSettings(\n  defaultModel: AttributionModel,\n  lookbackWindow: number,\n  customWeights?: Record<string, number>\n): Promise<boolean> {\n  try {\n    // Look for existing settings\n    const settings = await prisma.attributionSettings.findFirst();\n    \n    const data = {\n      defaultModel,\n      lookbackWindow,\n      customWeights: customWeights ? JSON.stringify(customWeights) : null,\n      updatedAt: new Date(),\n    };\n    \n    if (settings) {\n      // Update existing settings\n      await prisma.attributionSettings.update({\n        where: { id: settings.id },\n        data,\n      });\n    } else {\n      // Create new settings\n      await prisma.attributionSettings.create({\n        data: {\n          id: randomUUID(),\n          ...data,\n          createdAt: new Date(),\n        },\n      });\n    }\n    \n    return true;\n  } catch (error) {\n    logger.error('Error updating attribution settings', error);\n    return false;\n  }\n}\n\n/**\n * Create a conversion funnel\n */\nexport async function createConversionFunnel(\n  name: string,\n  stages: string[], // Array of conversion event IDs\n  userId: string,\n  description?: string\n): Promise<string> {\n  try {\n    const funnel = await prisma.conversionFunnel.create({\n      data: {\n        id: randomUUID(),\n        name,\n        description,\n        stages: JSON.stringify(stages),\n        createdById: userId,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      },\n    });\n    \n    logger.info(`Created conversion funnel: ${funnel.id}`, { funnelId: funnel.id, name });\n    \n    return funnel.id;\n  } catch (error) {\n    logger.error('Error creating conversion funnel', error);\n    throw error;\n  }\n}\n\n/**\n * Generate a funnel report for a specific time period\n */\nexport async function generateFunnelReport(\n  funnelId: string,\n  startDate: Date,\n  endDate: Date\n): Promise<FunnelData | null> {\n  try {\n    // Get the funnel\n    const funnel = await prisma.conversionFunnel.findUnique({\n      where: { id: funnelId },\n    });\n    \n    if (!funnel) {\n      logger.warn(`Funnel not found: ${funnelId}`);\n      return null;\n    }\n    \n    // Parse stages\n    const stageIds = JSON.parse(funnel.stages) as string[];\n    \n    // Get the events for these stages\n    const events = await prisma.conversionEvent.findMany({\n      where: {\n        id: { in: stageIds },\n      },\n      select: {\n        id: true,\n        name: true,\n      },\n    });\n    \n    // Create a map of event IDs to names\n    const eventMap = new Map(events.map(event => [event.id, event.name]));\n    \n    // Get conversion counts for each stage\n    const stageCounts = await Promise.all(\n      stageIds.map(async (eventId) => {\n        const conversions = await prisma.conversionTracking.findMany({\n          where: {\n            eventId,\n            occurredAt: {\n              gte: startDate,\n              lte: endDate,\n            },\n          },\n          select: {\n            id: true,\n            contactId: true,\n            value: true,\n          },\n        });\n        \n        const uniqueContacts = new Set(conversions.map(c => c.contactId).filter(Boolean));\n        const totalValue = conversions.reduce((sum, c) => sum + (c.value || 0), 0);\n        \n        return {\n          eventId,\n          name: eventMap.get(eventId) || 'Unknown Event',\n          count: uniqueContacts.size,\n          totalValue,\n        };\n      })\n    );\n    \n    // Calculate drop-off and conversion rates\n    const stages: FunnelStage[] = [];\n    let previousCount = stageCounts[0]?.count || 0;\n    const totalEntries = previousCount;\n    \n    for (let i = 0; i < stageCounts.length; i++) {\n      const stage = stageCounts[i];\n      const dropOffRate = i > 0 ? (previousCount - stage.count) / previousCount : 0;\n      const conversionRate = totalEntries > 0 ? stage.count / totalEntries : 0;\n      \n      stages.push({\n        eventId: stage.eventId,\n        name: stage.name,\n        count: stage.count,\n        dropOffRate,\n        conversionRate,\n        totalValue: stage.totalValue,\n      });\n      \n      previousCount = stage.count;\n    }\n    \n    // Calculate overall funnel metrics\n    const totalConversions = stages[stages.length - 1]?.count || 0;\n    const conversionRate = totalEntries > 0 ? totalConversions / totalEntries : 0;\n    const totalValue = stages.reduce((sum, stage) => sum + (stage.totalValue || 0), 0);\n    \n    // Create a report record in the database\n    const reportData = {\n      stages,\n      totalEntries,\n      totalConversions,\n      conversionRate,\n      totalValue,\n    };\n    \n    await prisma.conversionFunnelReport.create({\n      data: {\n        id: randomUUID(),\n        funnelId,\n        startDate,\n        endDate,\n        data: JSON.stringify(reportData),\n        createdAt: new Date(),\n      },\n    });\n    \n    return {\n      name: funnel.name,\n      ...reportData,\n      startDate,\n      endDate,\n    };\n  } catch (error) {\n    logger.error(`Error generating funnel report: ${funnelId}`, error);\n    return null;\n  }\n}\n\n/**\n * Apply an attribution model to touch points\n */\nexport function applyAttributionModel(\n  touchPoints: TouchPoint[],\n  model: AttributionModel,\n  customWeights?: Record<string, number>\n): TouchPoint[] {\n  // Sort touch points by timestamp\n  const sortedPoints = [...touchPoints].sort((a, b) => \n    a.timestamp.getTime() - b.timestamp.getTime()\n  );\n  \n  if (sortedPoints.length === 0) {\n    return [];\n  }\n  \n  if (sortedPoints.length === 1) {\n    // If there's only one touch point, it gets 100% credit\n    sortedPoints[0].weight = 1;\n    return sortedPoints;\n  }\n  \n  switch (model) {\n    case AttributionModel.FIRST_TOUCH:\n      // First touch gets 100% credit\n      sortedPoints.forEach((point, index) => {\n        point.weight = index === 0 ? 1 : 0;\n      });\n      break;\n      \n    case AttributionModel.LAST_TOUCH:\n      // Last touch gets 100% credit\n      sortedPoints.forEach((point, index) => {\n        point.weight = index === sortedPoints.length - 1 ? 1 : 0;\n      });\n      break;\n      \n    case AttributionModel.LINEAR:\n      // Equal distribution\n      const equalWeight = 1 / sortedPoints.length;\n      sortedPoints.forEach(point => {\n        point.weight = equalWeight;\n      });\n      break;\n      \n    case AttributionModel.TIME_DECAY:\n      // More recent touches get more credit\n      const halfLifeDays = 7; // 7-day half-life\n      const latestTime = sortedPoints[sortedPoints.length - 1].timestamp.getTime();\n      \n      // Calculate raw weights based on time decay\n      let totalWeight = 0;\n      \n      sortedPoints.forEach(point => {\n        const daysAgo = (latestTime - point.timestamp.getTime()) / (1000 * 60 * 60 * 24);\n        const weight = Math.pow(0.5, daysAgo / halfLifeDays);\n        point.weight = weight;\n        totalWeight += weight;\n      });\n      \n      // Normalize weights to sum to 1\n      sortedPoints.forEach(point => {\n        point.weight = (point.weight || 0) / totalWeight;\n      });\n      break;\n      \n    case AttributionModel.POSITION_BASED:\n      // U-shaped: 40% to first, 40% to last, 20% distributed among middle touches\n      sortedPoints.forEach((point, index) => {\n        if (index === 0) {\n          point.weight = 0.4;\n        } else if (index === sortedPoints.length - 1) {\n          point.weight = 0.4;\n        } else {\n          // Distribute the remaining 20% among middle touch points\n          point.weight = 0.2 / (sortedPoints.length - 2);\n        }\n      });\n      break;\n      \n    case AttributionModel.CUSTOM:\n      // Use custom weights if provided\n      if (customWeights) {\n        sortedPoints.forEach((point, index) => {\n          const position = index === 0 ? 'first' : (index === sortedPoints.length - 1 ? 'last' : 'middle');\n          point.weight = customWeights[position] || 0;\n        });\n        \n        // Normalize weights to sum to 1\n        const totalCustomWeight = sortedPoints.reduce((sum, point) => sum + (point.weight || 0), 0);\n        if (totalCustomWeight > 0) {\n          sortedPoints.forEach(point => {\n            point.weight = (point.weight || 0) / totalCustomWeight;\n          });\n        }\n      } else {\n        // Fall back to position-based if no custom weights\n        return applyAttributionModel(touchPoints, AttributionModel.POSITION_BASED);\n      }\n      break;\n  }\n  \n  return sortedPoints;\n}\n\n/**\n * Get attribution for a specific conversion\n */\nexport async function getConversionAttribution(\n  conversionTrackingId: string\n): Promise<TouchPoint[] | null> {\n  try {\n    const conversion = await prisma.conversionTracking.findUnique({\n      where: { id: conversionTrackingId },\n    });\n    \n    if (!conversion || !conversion.touchPoints) {\n      return null;\n    }\n    \n    const touchPoints = JSON.parse(conversion.touchPoints) as TouchPoint[];\n    const attributionSettings = await getAttributionSettings();\n    \n    // Apply the attribution model\n    const attributedPoints = applyAttributionModel(\n      touchPoints,\n      conversion.attributionModel || attributionSettings.defaultModel,\n      attributionSettings.customWeights\n    );\n    \n    return attributedPoints;\n  } catch (error) {\n    logger.error(`Error getting conversion attribution: ${conversionTrackingId}`, error);\n    return null;\n  }\n}\n\n/**\n * Get all previously defined conversion events\n */\nexport async function getConversionEvents(): Promise<{\n  system: Array<{ id: string; name: string; eventType: string; category: ConversionCategory }>;\n  custom: Array<{ id: string; name: string; eventType: string; category: ConversionCategory }>;\n}> {\n  try {\n    const events = await prisma.conversionEvent.findMany({\n      select: {\n        id: true,\n        name: true,\n        eventType: true,\n        category: true,\n        isSystem: true,\n      },\n      orderBy: {\n        name: 'asc',\n      },\n    });\n    \n    return {\n      system: events.filter(e => e.isSystem).map(({ isSystem, ...rest }) => rest),\n      custom: events.filter(e => !e.isSystem).map(({ isSystem, ...rest }) => rest),\n    };\n  } catch (error) {\n    logger.error('Error getting conversion events', error);\n    return { system: [], custom: [] };\n  }\n}\n\n/**\n * Get conversion data for an entity (campaign, workflow, etc.)\n */\nexport async function getEntityConversions(\n  entityType: EntityType,\n  entityId: string,\n  startDate?: Date,\n  endDate?: Date\n): Promise<Record<string, { count: number; value: number }>> {\n  try {\n    const dateFilter = {};\n    \n    if (startDate || endDate) {\n      dateFilter.occurredAt = {};\n      \n      if (startDate) {\n        dateFilter.occurredAt.gte = startDate;\n      }\n      \n      if (endDate) {\n        dateFilter.occurredAt.lte = endDate;\n      }\n    }\n    \n    const conversions = await prisma.conversionTracking.findMany({\n      where: {\n        entityType,\n        entityId,\n        ...dateFilter,\n      },\n      include: {\n        event: {\n          select: {\n            eventType: true,\n          },\n        },\n      },\n    });\n    \n    // Group by event type\n    const results: Record<string, { count: number; value: number }> = {};\n    \n    conversions.forEach(conversion => {\n      const eventType = conversion.event.eventType;\n      \n      if (!results[eventType]) {\n        results[eventType] = { count: 0, value: 0 };\n      }\n      \n      results[eventType].count += 1;\n      results[eventType].value += conversion.value || 0;\n    });\n    \n    return results;\n  } catch (error) {\n    logger.error(`Error getting entity conversions: ${entityType}/${entityId}`, error);\n    return {};\n  }\n} "],"names":["ConversionEventTypes","applyAttributionModel","createConversionEvent","createConversionFunnel","generateFunnelReport","getAttributionSettings","getConversionAttribution","getConversionEvents","getEntityConversions","trackConversion","updateAttributionSettings","EMAIL_OPEN","EMAIL_CLICK","EMAIL_REPLY","SMS_DELIVERY","SMS_REPLY","WHATSAPP_DELIVERY","WHATSAPP_READ","WHATSAPP_REPLY","PAGE_VIEW","CONTENT_VIEW","FORM_START","FORM_SUBMIT","PRODUCT_VIEW","ADD_TO_CART","CHECKOUT_START","PURCHASE","CUSTOM","data","userId","event","prisma","conversionEvent","create","id","randomUUID","name","description","eventType","category","valueType","isSystem","createdById","createdAt","Date","updatedAt","logger","info","eventId","error","attributionSettings","conversionTracking","entityType","entityId","contactId","value","metadata","JSON","stringify","attributionModel","defaultModel","touchPoints","occurredAt","settings","findFirst","customWeights","parse","undefined","lookbackWindow","defaultSettings","AttributionModel","LAST_TOUCH","update","where","stages","funnel","conversionFunnel","funnelId","startDate","endDate","findUnique","warn","stageIds","events","findMany","in","select","eventMap","Map","map","stageCounts","Promise","all","conversions","gte","lte","uniqueContacts","Set","c","filter","Boolean","totalValue","reduce","sum","get","count","size","previousCount","totalEntries","i","length","stage","dropOffRate","conversionRate","push","totalConversions","reportData","conversionFunnelReport","model","sortedPoints","sort","a","b","timestamp","getTime","weight","FIRST_TOUCH","forEach","point","index","LINEAR","equalWeight","TIME_DECAY","halfLifeDays","latestTime","totalWeight","daysAgo","Math","pow","POSITION_BASED","position","totalCustomWeight","conversionTrackingId","conversion","attributedPoints","orderBy","system","e","rest","custom","dateFilter","include","results"],"mappings":"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"}