{"version":3,"sources":["/Users/supreme/Desktop/marketsage/src/mcp/servers/customer-data-server.ts"],"sourcesContent":["/**\n * Customer Data MCP Server for MarketSage\n * \n * This server provides read-only access to customer data, contact information,\n * and customer segments through the MCP protocol.\n */\n\nimport { z } from 'zod';\nimport { HTTPBaseMCPServer } from './http-base-mcp-server';\nimport { \n  type MCPAuthContext, \n  type MCPServerConfig,\n  CustomerQuerySchema,\n  type CustomerQuery,\n  type CustomerProfile,\n  MCPAuthorizationError,\n  MCPValidationError\n} from '../types/mcp-types';\n\nimport { prisma } from '../../lib/db/prisma';\nimport { defaultMCPConfig } from '../config/mcp-config';\n\nexport class CustomerDataMCPServer extends HTTPBaseMCPServer {\n  constructor(config?: Partial<MCPServerConfig>) {\n    super({\n      ...defaultMCPConfig.servers.customer,\n      ...config\n    });\n  }\n\n  /**\n   * List available customer data resources\n   */\n  protected async listResources(authContext: MCPAuthContext): Promise<any[]> {\n    const resources = [\n      {\n        uri: \"customer://profiles\",\n        name: \"Customer Profiles\",\n        description: \"Access to customer profile information\",\n        mimeType: \"application/json\"\n      },\n      {\n        uri: \"customer://segments\",\n        name: \"Customer Segments\",\n        description: \"Access to customer segmentation data\",\n        mimeType: \"application/json\"\n      },\n      {\n        uri: \"customer://predictions\",\n        name: \"Customer Predictions\",\n        description: \"Access to customer predictive analytics\",\n        mimeType: \"application/json\"\n      }\n    ];\n\n    // Filter resources based on permissions\n    if (!authContext.permissions.includes('*') && !authContext.permissions.includes('read:org')) {\n      // Users can only access their own organization's resources\n      return resources.filter(r => r.uri.includes('profiles'));\n    }\n\n    return resources;\n  }\n\n  /**\n   * Read customer data resource\n   */\n  protected async readResource(uri: string, authContext: MCPAuthContext): Promise<any> {\n    const url = new URL(uri);\n    const path = url.pathname;\n    const searchParams = url.searchParams;\n\n    // Parse query parameters\n    const queryParams = Object.fromEntries(searchParams.entries());\n    const validatedQuery = CustomerQuerySchema.parse({\n      ...queryParams,\n      organizationId: authContext.organizationId, // Always use user's org\n      limit: queryParams.limit ? Number.parseInt(queryParams.limit) : 10,\n      offset: queryParams.offset ? Number.parseInt(queryParams.offset) : 0,\n      includeSegments: queryParams.includeSegments === 'true',\n      includePredictions: queryParams.includePredictions === 'true'\n    });\n\n    switch (path) {\n      case '/profiles':\n        return await this.getCustomerProfiles(validatedQuery, authContext);\n      case '/segments':\n        return await this.getCustomerSegments(validatedQuery, authContext);\n      case '/predictions':\n        return await this.getCustomerPredictions(validatedQuery, authContext);\n      default:\n        throw new MCPValidationError(`Unknown resource path: ${path}`);\n    }\n  }\n\n  /**\n   * List available customer data tools\n   */\n  protected async listTools(authContext: MCPAuthContext): Promise<any[]> {\n    const tools = [\n      {\n        name: \"search_customers\",\n        description: \"Search for customers by email, phone, or other criteria\",\n        inputSchema: {\n          type: \"object\",\n          properties: {\n            query: {\n              type: \"string\",\n              description: \"Search query (email, phone, name)\"\n            },\n            limit: {\n              type: \"number\",\n              description: \"Maximum number of results (1-100)\",\n              minimum: 1,\n              maximum: 100,\n              default: 10\n            },\n            includeSegments: {\n              type: \"boolean\",\n              description: \"Include customer segments in results\",\n              default: false\n            },\n            includePredictions: {\n              type: \"boolean\",\n              description: \"Include predictive analytics in results\",\n              default: false\n            }\n          },\n          required: [\"query\"]\n        }\n      },\n      {\n        name: \"get_customer_profile\",\n        description: \"Get detailed profile information for a specific customer\",\n        inputSchema: {\n          type: \"object\",\n          properties: {\n            customerId: {\n              type: \"string\",\n              description: \"Customer ID\"\n            },\n            includeSegments: {\n              type: \"boolean\",\n              description: \"Include customer segments\",\n              default: true\n            },\n            includePredictions: {\n              type: \"boolean\",\n              description: \"Include predictive analytics\",\n              default: true\n            }\n          },\n          required: [\"customerId\"]\n        }\n      },\n      {\n        name: \"get_customer_segments\",\n        description: \"Get all customer segments for the organization\",\n        inputSchema: {\n          type: \"object\",\n          properties: {\n            includeStats: {\n              type: \"boolean\",\n              description: \"Include segment statistics\",\n              default: true\n            }\n          }\n        }\n      }\n    ];\n\n    // Filter tools based on permissions\n    if (!authContext.permissions.includes('*') && !authContext.permissions.includes('read:org')) {\n      // Regular users get limited tools\n      return tools.filter(t => ['search_customers', 'get_customer_profile'].includes(t.name));\n    }\n\n    return tools;\n  }\n\n  /**\n   * Execute customer data tools\n   */\n  protected async callTool(name: string, args: any, authContext: MCPAuthContext): Promise<any> {\n    switch (name) {\n      case 'search_customers':\n        return await this.searchCustomers(args, authContext);\n      case 'get_customer_profile':\n        return await this.getCustomerProfile(args, authContext);\n      case 'get_customer_segments':\n        return await this.getCustomerSegments(args, authContext);\n      default:\n        throw new MCPValidationError(`Unknown tool: ${name}`);\n    }\n  }\n\n  /**\n   * Get customer profiles\n   */\n  private async getCustomerProfiles(query: CustomerQuery, authContext: MCPAuthContext): Promise<any> {\n    try {\n      const customers = await prisma.contact.findMany({\n        where: {\n          organizationId: authContext.organizationId,\n          ...(query.email && { email: { contains: query.email } }),\n          ...(query.phone && { phone: { contains: query.phone } }),\n          ...(query.id && { id: query.id })\n        },\n        take: query.limit,\n        skip: query.offset,\n        include: {\n          segments: query.includeSegments,\n          predictions: query.includePredictions\n        }\n      });\n\n      const profiles: CustomerProfile[] = customers.map(customer => ({\n        id: customer.id,\n        email: customer.email,\n        firstName: customer.firstName,\n        lastName: customer.lastName,\n        phone: customer.phone,\n        organizationId: customer.organizationId,\n        segments: query.includeSegments ? customer.segments?.map(s => s.name) : undefined,\n        predictions: query.includePredictions ? {\n          churnRisk: customer.predictions?.churnRisk || 0,\n          lifetimeValue: customer.predictions?.lifetimeValue || 0,\n          engagementScore: customer.predictions?.engagementScore || 0\n        } : undefined,\n        createdAt: customer.createdAt.toISOString(),\n        updatedAt: customer.updatedAt.toISOString()\n      }));\n\n      return {\n        uri: \"customer://profiles\",\n        mimeType: \"application/json\",\n        text: JSON.stringify({\n          profiles,\n          meta: {\n            total: profiles.length,\n            offset: query.offset,\n            limit: query.limit\n          }\n        })\n      };\n    } catch (error) {\n      // Fallback to direct database access\n      return await this.createFallbackResponse(\n        () => this.getCustomerProfilesFallback(query, authContext),\n        'Failed to retrieve customer profiles via MCP'\n      );\n    }\n  }\n\n  /**\n   * Search customers tool\n   */\n  private async searchCustomers(args: any, authContext: MCPAuthContext): Promise<any> {\n    const { query, limit = 10, includeSegments = false, includePredictions = false } = args;\n    const startTime = Date.now();\n\n    try {\n      // Log tool execution start\n      await this.logMCPToolExecution(\n        authContext,\n        'search_customers',\n        args,\n        'success',\n        { duration: 0, riskLevel: 'low' }\n      );\n      const customers = await prisma.contact.findMany({\n        where: {\n          organizationId: authContext.organizationId,\n          OR: [\n            { email: { contains: query, mode: 'insensitive' } },\n            { phone: { contains: query } },\n            { firstName: { contains: query, mode: 'insensitive' } },\n            { lastName: { contains: query, mode: 'insensitive' } }\n          ]\n        },\n        take: limit,\n        include: {\n          segments: includeSegments,\n          predictions: includePredictions\n        }\n      });\n\n      const results = customers.map(customer => ({\n        id: customer.id,\n        email: customer.email,\n        firstName: customer.firstName,\n        lastName: customer.lastName,\n        phone: customer.phone,\n        segments: includeSegments ? customer.segments?.map(s => s.name) : undefined,\n        predictions: includePredictions ? {\n          churnRisk: customer.predictions?.churnRisk || 0,\n          lifetimeValue: customer.predictions?.lifetimeValue || 0,\n          engagementScore: customer.predictions?.engagementScore || 0\n        } : undefined\n      }));\n\n      const duration = Date.now() - startTime;\n\n      // Log successful tool execution\n      await this.logMCPToolExecution(\n        authContext,\n        'search_customers',\n        args,\n        'success',\n        { \n          duration,\n          outputSize: results.length,\n          riskLevel: includeSegments || includePredictions ? 'medium' : 'low'\n        }\n      );\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify({\n            results,\n            meta: {\n              query,\n              total: results.length,\n              hasMore: results.length === limit,\n              duration\n            }\n          })\n        }]\n      };\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      \n      // Log failed tool execution\n      await this.logMCPToolExecution(\n        authContext,\n        'search_customers',\n        args,\n        'failure',\n        { \n          duration,\n          errorMessage: error instanceof Error ? error.message : 'Unknown error',\n          riskLevel: 'medium'\n        }\n      );\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify({\n            error: \"Failed to search customers\",\n            details: error instanceof Error ? error.message : 'Unknown error'\n          })\n        }],\n        isError: true\n      };\n    }\n  }\n\n  /**\n   * Get customer profile tool\n   */\n  private async getCustomerProfile(args: any, authContext: MCPAuthContext): Promise<any> {\n    const { customerId, includeSegments = true, includePredictions = true } = args;\n\n    try {\n      const customer = await prisma.contact.findFirst({\n        where: {\n          id: customerId,\n          organizationId: authContext.organizationId\n        },\n        include: {\n          segments: includeSegments,\n          predictions: includePredictions\n        }\n      });\n\n      if (!customer) {\n        return {\n          content: [{\n            type: \"text\",\n            text: JSON.stringify({\n              error: \"Customer not found\",\n              customerId\n            })\n          }],\n          isError: true\n        };\n      }\n\n      const profile = {\n        id: customer.id,\n        email: customer.email,\n        firstName: customer.firstName,\n        lastName: customer.lastName,\n        phone: customer.phone,\n        segments: includeSegments ? customer.segments?.map(s => s.name) : undefined,\n        predictions: includePredictions ? {\n          churnRisk: customer.predictions?.churnRisk || 0,\n          lifetimeValue: customer.predictions?.lifetimeValue || 0,\n          engagementScore: customer.predictions?.engagementScore || 0\n        } : undefined,\n        createdAt: customer.createdAt.toISOString(),\n        updatedAt: customer.updatedAt.toISOString()\n      };\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(profile)\n        }]\n      };\n    } catch (error) {\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify({\n            error: \"Failed to retrieve customer profile\",\n            details: error instanceof Error ? error.message : 'Unknown error'\n          })\n        }],\n        isError: true\n      };\n    }\n  }\n\n  /**\n   * Fallback method for customer profiles\n   */\n  private async getCustomerProfilesFallback(query: CustomerQuery, authContext: MCPAuthContext): Promise<any> {\n    // Direct database access as fallback\n    const customers = await prisma.contact.findMany({\n      where: {\n        organizationId: authContext.organizationId,\n        ...(query.email && { email: { contains: query.email } }),\n        ...(query.phone && { phone: { contains: query.phone } }),\n        ...(query.id && { id: query.id })\n      },\n      take: query.limit,\n      skip: query.offset\n    });\n\n    return {\n      profiles: customers.map(customer => ({\n        id: customer.id,\n        email: customer.email,\n        firstName: customer.firstName,\n        lastName: customer.lastName,\n        phone: customer.phone,\n        organizationId: customer.organizationId,\n        createdAt: customer.createdAt.toISOString(),\n        updatedAt: customer.updatedAt.toISOString()\n      })),\n      meta: {\n        total: customers.length,\n        offset: query.offset,\n        limit: query.limit,\n        fallbackUsed: true\n      }\n    };\n  }\n\n  /**\n   * Get customer segments with real data\n   */\n  private async getCustomerSegments(query: any, authContext: MCPAuthContext): Promise<any> {\n    try {\n      const startTime = Date.now();\n      \n      // Get segments with member counts and statistics\n      const segments = await prisma.segment.findMany({\n        where: {\n          createdBy: {\n            organizationId: authContext.organizationId\n          }\n        },\n        include: {\n          members: {\n            include: {\n              contact: {\n                select: {\n                  id: true,\n                  email: true,\n                  firstName: true,\n                  lastName: true,\n                  lastEngaged: true,\n                  createdAt: true\n                }\n              }\n            }\n          },\n          _count: {\n            select: {\n              members: true,\n              emailCampaigns: true,\n              smsCampaigns: true,\n              waCampaigns: true\n            }\n          }\n        }\n      });\n\n      // Calculate segment statistics\n      const segmentStats = segments.map(segment => {\n        const memberData = segment.members.map(m => m.contact);\n        const totalMembers = memberData.length;\n        \n        // Calculate engagement statistics\n        const now = new Date();\n        const recentlyEngaged = memberData.filter(contact => {\n          if (!contact.lastEngaged) return false;\n          const daysSinceEngagement = (now.getTime() - contact.lastEngaged.getTime()) / (1000 * 60 * 60 * 24);\n          return daysSinceEngagement <= 30;\n        }).length;\n\n        const newMembers = memberData.filter(contact => {\n          const daysSinceCreated = (now.getTime() - contact.createdAt.getTime()) / (1000 * 60 * 60 * 24);\n          return daysSinceCreated <= 30;\n        }).length;\n\n        return {\n          id: segment.id,\n          name: segment.name,\n          description: segment.description,\n          rules: JSON.parse(segment.rules || '{}'),\n          statistics: {\n            totalMembers,\n            recentlyEngaged,\n            newMembers,\n            engagementRate: totalMembers > 0 ? (recentlyEngaged / totalMembers) * 100 : 0,\n            growthRate: totalMembers > 0 ? (newMembers / totalMembers) * 100 : 0,\n            campaignUsage: {\n              emailCampaigns: segment._count.emailCampaigns,\n              smsCampaigns: segment._count.smsCampaigns,\n              whatsappCampaigns: segment._count.waCampaigns\n            }\n          },\n          createdAt: segment.createdAt.toISOString(),\n          updatedAt: segment.updatedAt.toISOString(),\n          ...(query.includeMembers && {\n            members: memberData.slice(0, 50).map(contact => ({\n              id: contact.id,\n              email: contact.email,\n              firstName: contact.firstName,\n              lastName: contact.lastName,\n              lastEngaged: contact.lastEngaged?.toISOString()\n            }))\n          })\n        };\n      });\n\n      const duration = Date.now() - startTime;\n\n      // Log the resource access\n      await this.logMCPResourceAccess(\n        authContext,\n        'customer://segments',\n        'LIST',\n        'success',\n        { duration, dataSize: segmentStats.length }\n      );\n\n      return {\n        uri: \"customer://segments\",\n        mimeType: \"application/json\",\n        text: JSON.stringify({\n          segments: segmentStats,\n          meta: {\n            total: segmentStats.length,\n            organizationId: authContext.organizationId,\n            timestamp: new Date().toISOString(),\n            duration\n          }\n        })\n      };\n    } catch (error) {\n      // Log failed access\n      await this.logMCPResourceAccess(\n        authContext,\n        'customer://segments',\n        'LIST',\n        'failure',\n        { errorMessage: error instanceof Error ? error.message : 'Unknown error' }\n      );\n\n      return {\n        uri: \"customer://segments\",\n        mimeType: \"application/json\",\n        text: JSON.stringify({\n          error: \"Failed to retrieve customer segments\",\n          details: error instanceof Error ? error.message : 'Unknown error'\n        })\n      };\n    }\n  }\n\n  /**\n   * Get customer predictions with real MCP seeded data\n   */\n  private async getCustomerPredictions(query: CustomerQuery, authContext: MCPAuthContext): Promise<any> {\n    try {\n      const startTime = Date.now();\n      \n      // Build where clause\n      const whereClause: any = {\n        organizationId: authContext.organizationId\n      };\n\n      if (query.id) {\n        whereClause.contactId = query.id;\n      }\n\n      // Get predictions from MCP table\n      const predictions = await prisma.mCPCustomerPredictions.findMany({\n        where: whereClause,\n        take: query.limit,\n        skip: query.offset,\n        include: {\n          contact: {\n            select: {\n              id: true,\n              email: true,\n              firstName: true,\n              lastName: true,\n              phone: true,\n              company: true,\n              lastEngaged: true,\n              createdAt: true\n            }\n          },\n          organization: {\n            select: {\n              id: true,\n              name: true\n            }\n          }\n        },\n        orderBy: {\n          calculatedAt: 'desc'\n        }\n      });\n\n      // Transform predictions data\n      const predictionData = predictions.map(pred => ({\n        id: pred.id,\n        contactId: pred.contactId,\n        customer: pred.contact ? {\n          id: pred.contact.id,\n          email: pred.contact.email,\n          firstName: pred.contact.firstName,\n          lastName: pred.contact.lastName,\n          phone: pred.contact.phone,\n          company: pred.contact.company,\n          lastEngaged: pred.contact.lastEngaged?.toISOString(),\n          createdAt: pred.contact.createdAt.toISOString()\n        } : null,\n        predictions: {\n          churnRisk: pred.churnRisk,\n          lifetimeValue: pred.lifetimeValue,\n          engagementScore: pred.engagementScore,\n          segment: pred.segment,\n          confidenceScore: pred.confidenceScore\n        },\n        insights: {\n          lastActivityDate: pred.lastActivityDate.toISOString(),\n          nextBestAction: pred.nextBestAction,\n          preferredChannel: pred.preferredChannel,\n          behavioralScores: pred.behavioralScores,\n          actionableInsights: pred.insights\n        },\n        calculatedAt: pred.calculatedAt.toISOString()\n      }));\n\n      // Calculate summary statistics\n      const totalPredictions = predictionData.length;\n      const avgChurnRisk = totalPredictions > 0 \n        ? predictionData.reduce((sum, p) => sum + p.predictions.churnRisk, 0) / totalPredictions \n        : 0;\n      const avgLifetimeValue = totalPredictions > 0 \n        ? predictionData.reduce((sum, p) => sum + p.predictions.lifetimeValue, 0) / totalPredictions \n        : 0;\n      const avgEngagementScore = totalPredictions > 0 \n        ? predictionData.reduce((sum, p) => sum + p.predictions.engagementScore, 0) / totalPredictions \n        : 0;\n\n      // Risk distribution\n      const highRisk = predictionData.filter(p => p.predictions.churnRisk > 70).length;\n      const mediumRisk = predictionData.filter(p => p.predictions.churnRisk > 30 && p.predictions.churnRisk <= 70).length;\n      const lowRisk = predictionData.filter(p => p.predictions.churnRisk <= 30).length;\n\n      // Segment distribution\n      const segmentDistribution = predictionData.reduce((acc: Record<string, number>, p) => {\n        acc[p.predictions.segment] = (acc[p.predictions.segment] || 0) + 1;\n        return acc;\n      }, {});\n\n      // Channel preferences\n      const channelPreferences = predictionData.reduce((acc: Record<string, number>, p) => {\n        acc[p.insights.preferredChannel] = (acc[p.insights.preferredChannel] || 0) + 1;\n        return acc;\n      }, {});\n\n      const duration = Date.now() - startTime;\n\n      // Log the resource access\n      await this.logMCPResourceAccess(\n        authContext,\n        'customer://predictions',\n        'READ',\n        'success',\n        { \n          duration, \n          dataSize: predictionData.length,\n          riskLevel: totalPredictions > 50 ? 'medium' : 'low' \n        }\n      );\n\n      return {\n        uri: \"customer://predictions\",\n        mimeType: \"application/json\",\n        text: JSON.stringify({\n          predictions: predictionData,\n          summary: {\n            totalPredictions,\n            averages: {\n              churnRisk: Math.round(avgChurnRisk * 100) / 100,\n              lifetimeValue: Math.round(avgLifetimeValue * 100) / 100,\n              engagementScore: Math.round(avgEngagementScore * 100) / 100\n            },\n            riskDistribution: {\n              highRisk: { count: highRisk, percentage: totalPredictions > 0 ? (highRisk / totalPredictions) * 100 : 0 },\n              mediumRisk: { count: mediumRisk, percentage: totalPredictions > 0 ? (mediumRisk / totalPredictions) * 100 : 0 },\n              lowRisk: { count: lowRisk, percentage: totalPredictions > 0 ? (lowRisk / totalPredictions) * 100 : 0 }\n            },\n            segmentDistribution,\n            channelPreferences\n          },\n          meta: {\n            query: {\n              limit: query.limit,\n              offset: query.offset,\n              organizationId: authContext.organizationId\n            },\n            timestamp: new Date().toISOString(),\n            duration,\n            source: 'MCP_CUSTOMER_PREDICTIONS'\n          }\n        })\n      };\n    } catch (error) {\n      // Log failed access\n      await this.logMCPResourceAccess(\n        authContext,\n        'customer://predictions',\n        'READ',\n        'failure',\n        { \n          errorMessage: error instanceof Error ? error.message : 'Unknown error',\n          riskLevel: 'high' // Data access failures are high risk\n        }\n      );\n\n      // Fallback to basic response\n      return {\n        uri: \"customer://predictions\",\n        mimeType: \"application/json\",\n        text: JSON.stringify({\n          error: \"Failed to retrieve customer predictions\",\n          details: error instanceof Error ? error.message : 'Unknown error',\n          fallback: {\n            message: \"Predictions temporarily unavailable\",\n            timestamp: new Date().toISOString()\n          }\n        })\n      };\n    }\n  }\n}"],"names":["CustomerDataMCPServer","HTTPBaseMCPServer","constructor","config","defaultMCPConfig","servers","customer","listResources","authContext","resources","uri","name","description","mimeType","permissions","includes","filter","r","readResource","url","URL","path","pathname","searchParams","queryParams","Object","fromEntries","entries","validatedQuery","CustomerQuerySchema","parse","organizationId","limit","Number","parseInt","offset","includeSegments","includePredictions","getCustomerProfiles","getCustomerSegments","getCustomerPredictions","MCPValidationError","listTools","tools","inputSchema","type","properties","query","minimum","maximum","default","required","customerId","includeStats","t","callTool","args","searchCustomers","getCustomerProfile","customers","prisma","contact","findMany","where","email","contains","phone","id","take","skip","include","segments","predictions","profiles","map","firstName","lastName","s","undefined","churnRisk","lifetimeValue","engagementScore","createdAt","toISOString","updatedAt","text","JSON","stringify","meta","total","length","error","createFallbackResponse","getCustomerProfilesFallback","startTime","Date","now","logMCPToolExecution","duration","riskLevel","OR","mode","results","outputSize","content","hasMore","errorMessage","Error","message","details","isError","findFirst","profile","fallbackUsed","segment","createdBy","members","select","lastEngaged","_count","emailCampaigns","smsCampaigns","waCampaigns","segmentStats","memberData","m","totalMembers","recentlyEngaged","daysSinceEngagement","getTime","newMembers","daysSinceCreated","rules","statistics","engagementRate","growthRate","campaignUsage","whatsappCampaigns","includeMembers","slice","logMCPResourceAccess","dataSize","timestamp","whereClause","contactId","mCPCustomerPredictions","company","organization","orderBy","calculatedAt","predictionData","pred","confidenceScore","insights","lastActivityDate","nextBestAction","preferredChannel","behavioralScores","actionableInsights","totalPredictions","avgChurnRisk","reduce","sum","p","avgLifetimeValue","avgEngagementScore","highRisk","mediumRisk","lowRisk","segmentDistribution","acc","channelPreferences","summary","averages","Math","round","riskDistribution","count","percentage","source","fallback"],"mappings":"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"}