{"version":3,"sources":["/Users/supreme/Desktop/marketsage/src/lib/attribution/autonomous-attribution-engine.ts"],"sourcesContent":["/**\n * Autonomous Attribution Engine\n * ============================\n * Connects multi-touch attribution with autonomous decision-making\n * Enables AI to make data-driven decisions based on attribution insights\n */\n\nimport { logger } from '@/lib/logger';\nimport { trace } from '@opentelemetry/api';\nimport prisma from '@/lib/db/prisma';\nimport { EventEmitter } from 'events';\nimport { \n  AttributionModel, \n  ConversionCategory,\n  EntityType,\n  type ConversionEvent,\n  type ConversionTracking\n} from '@prisma/client';\nimport { \n  trackConversion, \n  applyAttributionModel,\n  getConversionAttribution,\n  type TouchPoint\n} from '@/lib/enhanced-conversions';\nimport { strategicDecisionEngine } from '@/lib/ai/strategic-decision-engine';\nimport { realtimeDecisionEngine } from '@/lib/ai/realtime-decision-engine';\nimport { multiAgentCoordinator } from '@/lib/ai/multi-agent-coordinator';\n\nexport interface AttributionInsight {\n  id: string;\n  timestamp: Date;\n  type: 'channel_performance' | 'journey_pattern' | 'conversion_driver' | 'optimization_opportunity' | 'anomaly';\n  confidence: number; // 0-1\n  insight: string;\n  details: {\n    channels?: ChannelPerformance[];\n    journeyPatterns?: JourneyPattern[];\n    conversionDrivers?: ConversionDriver[];\n    recommendations?: AttributionRecommendation[];\n    impact?: BusinessImpact;\n  };\n  actionRequired: boolean;\n  suggestedActions?: AutonomousAction[];\n}\n\nexport interface ChannelPerformance {\n  channel: string;\n  entityType: EntityType;\n  conversions: number;\n  revenue: number;\n  cost: number;\n  roi: number;\n  roas: number; // Return on Ad Spend\n  attribution: {\n    firstTouch: number;\n    lastTouch: number;\n    linear: number;\n    timeDecay: number;\n    positionBased: number;\n  };\n  trend: 'improving' | 'stable' | 'declining';\n  anomalies?: string[];\n}\n\nexport interface JourneyPattern {\n  id: string;\n  pattern: TouchPoint[];\n  frequency: number;\n  avgTimeToConversion: number; // hours\n  avgValue: number;\n  conversionRate: number;\n  channels: string[];\n  significance: 'high' | 'medium' | 'low';\n  insights: string[];\n}\n\nexport interface ConversionDriver {\n  factor: string;\n  type: 'channel' | 'content' | 'timing' | 'frequency' | 'sequence';\n  impact: number; // -1 to 1\n  confidence: number; // 0-1\n  description: string;\n  examples: string[];\n}\n\nexport interface AttributionRecommendation {\n  id: string;\n  type: 'budget_reallocation' | 'channel_optimization' | 'journey_optimization' | 'content_adjustment' | 'timing_change';\n  priority: 'high' | 'medium' | 'low';\n  description: string;\n  expectedImpact: {\n    conversions: number; // percentage change\n    revenue: number; // percentage change\n    cost: number; // percentage change\n  };\n  implementation: {\n    difficulty: 'easy' | 'medium' | 'hard';\n    timeframe: string;\n    steps: string[];\n  };\n}\n\nexport interface BusinessImpact {\n  revenue: {\n    current: number;\n    projected: number;\n    change: number;\n  };\n  conversions: {\n    current: number;\n    projected: number;\n    change: number;\n  };\n  efficiency: {\n    currentCPA: number; // Cost Per Acquisition\n    projectedCPA: number;\n    currentROAS: number;\n    projectedROAS: number;\n  };\n}\n\nexport interface AutonomousAction {\n  id: string;\n  type: 'immediate' | 'scheduled' | 'conditional';\n  action: string;\n  description: string;\n  targetEntity: {\n    type: EntityType;\n    id: string;\n  };\n  parameters: Record<string, any>;\n  trigger?: {\n    condition: string;\n    threshold: number;\n  };\n  approvalRequired: boolean;\n  riskLevel: 'low' | 'medium' | 'high';\n}\n\nclass AutonomousAttributionEngine extends EventEmitter {\n  private analysisInterval: NodeJS.Timeout | null = null;\n  private decisionQueue: AutonomousAction[] = [];\n  private insightHistory: Map<string, AttributionInsight[]> = new Map();\n  private performanceBaseline: Map<string, ChannelPerformance> = new Map();\n\n  constructor() {\n    super();\n    this.initializeEngine();\n  }\n\n  /**\n   * Initialize the autonomous attribution engine\n   */\n  private async initializeEngine() {\n    try {\n      logger.info('Initializing autonomous attribution engine...');\n\n      // Load performance baselines\n      await this.loadPerformanceBaselines();\n\n      // Start continuous analysis\n      this.startContinuousAnalysis();\n\n      // Register with strategic decision engine\n      this.registerWithDecisionEngines();\n\n      logger.info('Autonomous attribution engine initialized successfully');\n\n    } catch (error) {\n      logger.error('Failed to initialize autonomous attribution engine', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Load historical performance baselines\n   */\n  private async loadPerformanceBaselines() {\n    try {\n      // Get last 30 days of conversion data\n      const thirtyDaysAgo = new Date();\n      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n\n      const conversions = await prisma.conversionTracking.findMany({\n        where: {\n          occurredAt: { gte: thirtyDaysAgo }\n        },\n        include: {\n          event: true\n        }\n      });\n\n      // Calculate baseline performance by channel\n      const channelData = new Map<string, any>();\n\n      for (const conversion of conversions) {\n        const touchPoints = conversion.touchPoints ? \n          JSON.parse(conversion.touchPoints as string) as TouchPoint[] : [];\n\n        for (const touchPoint of touchPoints) {\n          const key = `${touchPoint.entityType}_${touchPoint.type}`;\n          \n          if (!channelData.has(key)) {\n            channelData.set(key, {\n              conversions: 0,\n              revenue: 0,\n              touchPoints: []\n            });\n          }\n\n          const data = channelData.get(key);\n          data.conversions++;\n          data.revenue += conversion.value || 0;\n          data.touchPoints.push(touchPoint);\n        }\n      }\n\n      // Convert to performance baselines\n      for (const [key, data] of channelData.entries()) {\n        const [entityType, channel] = key.split('_');\n        \n        const performance: ChannelPerformance = {\n          channel,\n          entityType: entityType as EntityType,\n          conversions: data.conversions,\n          revenue: data.revenue,\n          cost: 0, // Would need cost data from campaigns\n          roi: 0,\n          roas: 0,\n          attribution: {\n            firstTouch: 0,\n            lastTouch: 0,\n            linear: 0,\n            timeDecay: 0,\n            positionBased: 0\n          },\n          trend: 'stable'\n        };\n\n        this.performanceBaseline.set(key, performance);\n      }\n\n      logger.info('Loaded performance baselines', {\n        channels: this.performanceBaseline.size\n      });\n\n    } catch (error) {\n      logger.error('Failed to load performance baselines', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n    }\n  }\n\n  /**\n   * Start continuous attribution analysis\n   */\n  private startContinuousAnalysis() {\n    // Run analysis every 30 minutes\n    this.analysisInterval = setInterval(async () => {\n      await this.performAttributionAnalysis();\n    }, 30 * 60 * 1000);\n\n    // Run initial analysis\n    this.performAttributionAnalysis();\n  }\n\n  /**\n   * Perform comprehensive attribution analysis\n   */\n  private async performAttributionAnalysis() {\n    const tracer = trace.getTracer('attribution-analysis');\n    \n    return tracer.startActiveSpan('analyze-attribution', async (span) => {\n      try {\n        span.setAttributes({\n          'analysis.timestamp': Date.now(),\n          'analysis.type': 'comprehensive'\n        });\n\n        logger.info('Starting autonomous attribution analysis...');\n\n        // Analyze channel performance\n        const channelInsights = await this.analyzeChannelPerformance();\n        \n        // Analyze customer journey patterns\n        const journeyInsights = await this.analyzeJourneyPatterns();\n        \n        // Identify conversion drivers\n        const driverInsights = await this.identifyConversionDrivers();\n        \n        // Detect anomalies\n        const anomalyInsights = await this.detectAttributionAnomalies();\n        \n        // Generate optimization opportunities\n        const optimizationInsights = await this.generateOptimizationOpportunities();\n\n        // Process all insights\n        const allInsights = [\n          ...channelInsights,\n          ...journeyInsights,\n          ...driverInsights,\n          ...anomalyInsights,\n          ...optimizationInsights\n        ];\n\n        // Generate autonomous actions\n        for (const insight of allInsights) {\n          if (insight.actionRequired && insight.suggestedActions) {\n            await this.processAutonomousActions(insight);\n          }\n        }\n\n        // Store insights\n        this.storeInsights(allInsights);\n\n        // Emit analysis complete event\n        this.emit('analysis_complete', {\n          timestamp: new Date(),\n          insightCount: allInsights.length,\n          actionsGenerated: this.decisionQueue.length\n        });\n\n        logger.info('Attribution analysis completed', {\n          insights: allInsights.length,\n          actions: this.decisionQueue.length\n        });\n\n      } catch (error) {\n        span.setStatus({ code: 2, message: String(error) });\n        logger.error('Attribution analysis failed', {\n          error: error instanceof Error ? error.message : String(error)\n        });\n      } finally {\n        span.end();\n      }\n    });\n  }\n\n  /**\n   * Analyze channel performance across attribution models\n   */\n  private async analyzeChannelPerformance(): Promise<AttributionInsight[]> {\n    const insights: AttributionInsight[] = [];\n\n    try {\n      // Get recent conversions\n      const sevenDaysAgo = new Date();\n      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);\n\n      const conversions = await prisma.conversionTracking.findMany({\n        where: {\n          occurredAt: { gte: sevenDaysAgo }\n        },\n        include: {\n          event: true\n        }\n      });\n\n      // Analyze by channel and attribution model\n      const channelMetrics = new Map<string, ChannelPerformance>();\n      const models: AttributionModel[] = [\n        AttributionModel.FIRST_TOUCH,\n        AttributionModel.LAST_TOUCH,\n        AttributionModel.LINEAR,\n        AttributionModel.TIME_DECAY,\n        AttributionModel.POSITION_BASED\n      ];\n\n      for (const conversion of conversions) {\n        const touchPoints = conversion.touchPoints ? \n          JSON.parse(conversion.touchPoints as string) as TouchPoint[] : [];\n\n        if (touchPoints.length === 0) continue;\n\n        // Apply each attribution model\n        for (const model of models) {\n          const attributedTouchPoints = applyAttributionModel(touchPoints, model);\n          \n          for (const touchPoint of attributedTouchPoints) {\n            const key = `${touchPoint.entityType}_${touchPoint.type}`;\n            \n            if (!channelMetrics.has(key)) {\n              channelMetrics.set(key, {\n                channel: touchPoint.type,\n                entityType: touchPoint.entityType,\n                conversions: 0,\n                revenue: 0,\n                cost: 0,\n                roi: 0,\n                roas: 0,\n                attribution: {\n                  firstTouch: 0,\n                  lastTouch: 0,\n                  linear: 0,\n                  timeDecay: 0,\n                  positionBased: 0\n                },\n                trend: 'stable'\n              });\n            }\n\n            const metrics = channelMetrics.get(key)!;\n            const attributionKey = model.toLowerCase().replace('_', '') as keyof typeof metrics.attribution;\n            \n            metrics.conversions += touchPoint.weight || 0;\n            metrics.revenue += (conversion.value || 0) * (touchPoint.weight || 0);\n            metrics.attribution[attributionKey] += touchPoint.weight || 0;\n          }\n        }\n      }\n\n      // Compare with baselines and generate insights\n      for (const [key, metrics] of channelMetrics.entries()) {\n        const baseline = this.performanceBaseline.get(key);\n        \n        if (baseline) {\n          // Calculate trend\n          const conversionChange = (metrics.conversions - baseline.conversions) / baseline.conversions;\n          metrics.trend = conversionChange > 0.1 ? 'improving' : \n                         conversionChange < -0.1 ? 'declining' : 'stable';\n\n          // Check for significant changes\n          if (Math.abs(conversionChange) > 0.2) {\n            const insight: AttributionInsight = {\n              id: `insight_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n              timestamp: new Date(),\n              type: 'channel_performance',\n              confidence: 0.85,\n              insight: `${metrics.channel} channel ${metrics.trend} with ${Math.round(Math.abs(conversionChange) * 100)}% change in conversions`,\n              details: {\n                channels: [metrics],\n                impact: {\n                  revenue: {\n                    current: metrics.revenue,\n                    projected: metrics.revenue * (1 + conversionChange),\n                    change: conversionChange\n                  },\n                  conversions: {\n                    current: metrics.conversions,\n                    projected: metrics.conversions * (1 + conversionChange),\n                    change: conversionChange\n                  },\n                  efficiency: {\n                    currentCPA: metrics.cost / metrics.conversions || 0,\n                    projectedCPA: metrics.cost / (metrics.conversions * (1 + conversionChange)) || 0,\n                    currentROAS: metrics.revenue / metrics.cost || 0,\n                    projectedROAS: (metrics.revenue * (1 + conversionChange)) / metrics.cost || 0\n                  }\n                }\n              },\n              actionRequired: Math.abs(conversionChange) > 0.3,\n              suggestedActions: this.generateChannelActions(metrics, conversionChange)\n            };\n\n            insights.push(insight);\n          }\n        }\n      }\n\n    } catch (error) {\n      logger.error('Channel performance analysis failed', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n    }\n\n    return insights;\n  }\n\n  /**\n   * Analyze customer journey patterns\n   */\n  private async analyzeJourneyPatterns(): Promise<AttributionInsight[]> {\n    const insights: AttributionInsight[] = [];\n\n    try {\n      // Get conversions with multiple touchpoints\n      const conversions = await prisma.conversionTracking.findMany({\n        where: {\n          touchPoints: { not: null }\n        },\n        include: {\n          event: true\n        },\n        take: 1000,\n        orderBy: { occurredAt: 'desc' }\n      });\n\n      // Extract journey patterns\n      const patternMap = new Map<string, JourneyPattern>();\n\n      for (const conversion of conversions) {\n        const touchPoints = JSON.parse(conversion.touchPoints as string) as TouchPoint[];\n        \n        if (touchPoints.length < 2) continue;\n\n        // Create pattern key\n        const patternKey = touchPoints\n          .map(tp => `${tp.entityType}_${tp.type}`)\n          .join(' -> ');\n\n        if (!patternMap.has(patternKey)) {\n          patternMap.set(patternKey, {\n            id: `pattern_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n            pattern: touchPoints,\n            frequency: 0,\n            avgTimeToConversion: 0,\n            avgValue: 0,\n            conversionRate: 0,\n            channels: [...new Set(touchPoints.map(tp => tp.type))],\n            significance: 'low',\n            insights: []\n          });\n        }\n\n        const pattern = patternMap.get(patternKey)!;\n        pattern.frequency++;\n        pattern.avgValue = (pattern.avgValue * (pattern.frequency - 1) + (conversion.value || 0)) / pattern.frequency;\n        \n        // Calculate time to conversion\n        const firstTouch = new Date(touchPoints[0].timestamp);\n        const lastTouch = new Date(touchPoints[touchPoints.length - 1].timestamp);\n        const timeToConversion = (lastTouch.getTime() - firstTouch.getTime()) / (1000 * 60 * 60); // hours\n        \n        pattern.avgTimeToConversion = (pattern.avgTimeToConversion * (pattern.frequency - 1) + timeToConversion) / pattern.frequency;\n      }\n\n      // Analyze significant patterns\n      const totalConversions = conversions.length;\n      \n      for (const pattern of patternMap.values()) {\n        pattern.conversionRate = pattern.frequency / totalConversions;\n        pattern.significance = pattern.conversionRate > 0.1 ? 'high' : \n                              pattern.conversionRate > 0.05 ? 'medium' : 'low';\n\n        if (pattern.significance !== 'low') {\n          // Generate insights\n          pattern.insights = this.generateJourneyInsights(pattern);\n\n          const insight: AttributionInsight = {\n            id: `insight_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n            timestamp: new Date(),\n            type: 'journey_pattern',\n            confidence: Math.min(0.6 + pattern.conversionRate, 0.95),\n            insight: `Discovered ${pattern.significance} value journey pattern with ${Math.round(pattern.conversionRate * 100)}% of conversions`,\n            details: {\n              journeyPatterns: [pattern]\n            },\n            actionRequired: pattern.significance === 'high',\n            suggestedActions: pattern.significance === 'high' ? \n              this.generateJourneyActions(pattern) : undefined\n          };\n\n          insights.push(insight);\n        }\n      }\n\n    } catch (error) {\n      logger.error('Journey pattern analysis failed', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n    }\n\n    return insights;\n  }\n\n  /**\n   * Identify key conversion drivers\n   */\n  private async identifyConversionDrivers(): Promise<AttributionInsight[]> {\n    const insights: AttributionInsight[] = [];\n\n    try {\n      // Analyze various conversion factors\n      const drivers: ConversionDriver[] = [];\n\n      // Channel sequence analysis\n      const sequenceDriver = await this.analyzeChannelSequence();\n      if (sequenceDriver) drivers.push(sequenceDriver);\n\n      // Timing analysis\n      const timingDriver = await this.analyzeConversionTiming();\n      if (timingDriver) drivers.push(timingDriver);\n\n      // Frequency analysis\n      const frequencyDriver = await this.analyzeTouchpointFrequency();\n      if (frequencyDriver) drivers.push(frequencyDriver);\n\n      // Content type analysis\n      const contentDriver = await this.analyzeContentPerformance();\n      if (contentDriver) drivers.push(contentDriver);\n\n      // Create insights for significant drivers\n      const significantDrivers = drivers.filter(d => Math.abs(d.impact) > 0.2);\n\n      if (significantDrivers.length > 0) {\n        const insight: AttributionInsight = {\n          id: `insight_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n          timestamp: new Date(),\n          type: 'conversion_driver',\n          confidence: 0.8,\n          insight: `Identified ${significantDrivers.length} key conversion drivers`,\n          details: {\n            conversionDrivers: significantDrivers,\n            recommendations: this.generateDriverRecommendations(significantDrivers)\n          },\n          actionRequired: significantDrivers.some(d => Math.abs(d.impact) > 0.4),\n          suggestedActions: this.generateDriverActions(significantDrivers)\n        };\n\n        insights.push(insight);\n      }\n\n    } catch (error) {\n      logger.error('Conversion driver analysis failed', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n    }\n\n    return insights;\n  }\n\n  /**\n   * Detect attribution anomalies\n   */\n  private async detectAttributionAnomalies(): Promise<AttributionInsight[]> {\n    const insights: AttributionInsight[] = [];\n\n    try {\n      // Compare current performance with historical patterns\n      const anomalies: string[] = [];\n\n      // Check for sudden channel performance changes\n      for (const [key, baseline] of this.performanceBaseline.entries()) {\n        const current = await this.getCurrentChannelMetrics(key);\n        \n        if (current) {\n          const conversionChange = Math.abs((current.conversions - baseline.conversions) / baseline.conversions);\n          const revenueChange = Math.abs((current.revenue - baseline.revenue) / baseline.revenue);\n\n          if (conversionChange > 0.5 || revenueChange > 0.5) {\n            anomalies.push(`${baseline.channel} showing ${Math.round(Math.max(conversionChange, revenueChange) * 100)}% deviation from baseline`);\n          }\n        }\n      }\n\n      // Check for unusual journey patterns\n      const unusualPatterns = await this.detectUnusualJourneys();\n      anomalies.push(...unusualPatterns);\n\n      if (anomalies.length > 0) {\n        const insight: AttributionInsight = {\n          id: `insight_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n          timestamp: new Date(),\n          type: 'anomaly',\n          confidence: 0.75,\n          insight: `Detected ${anomalies.length} attribution anomalies requiring attention`,\n          details: {\n            channels: anomalies.map(a => ({\n              channel: a,\n              entityType: EntityType.CAMPAIGN,\n              conversions: 0,\n              revenue: 0,\n              cost: 0,\n              roi: 0,\n              roas: 0,\n              attribution: {\n                firstTouch: 0,\n                lastTouch: 0,\n                linear: 0,\n                timeDecay: 0,\n                positionBased: 0\n              },\n              trend: 'stable' as const,\n              anomalies: [a]\n            }))\n          },\n          actionRequired: true,\n          suggestedActions: [{\n            id: `action_${Date.now()}`,\n            type: 'immediate',\n            action: 'investigate_anomalies',\n            description: 'Investigate and address attribution anomalies',\n            targetEntity: {\n              type: EntityType.CAMPAIGN,\n              id: 'all'\n            },\n            parameters: { anomalies },\n            approvalRequired: false,\n            riskLevel: 'low'\n          }]\n        };\n\n        insights.push(insight);\n      }\n\n    } catch (error) {\n      logger.error('Anomaly detection failed', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n    }\n\n    return insights;\n  }\n\n  /**\n   * Generate optimization opportunities\n   */\n  private async generateOptimizationOpportunities(): Promise<AttributionInsight[]> {\n    const insights: AttributionInsight[] = [];\n\n    try {\n      const recommendations: AttributionRecommendation[] = [];\n\n      // Budget reallocation opportunities\n      const budgetReco = await this.analyzeBudgetAllocation();\n      if (budgetReco) recommendations.push(budgetReco);\n\n      // Channel mix optimization\n      const channelMixReco = await this.optimizeChannelMix();\n      if (channelMixReco) recommendations.push(channelMixReco);\n\n      // Journey optimization\n      const journeyReco = await this.optimizeCustomerJourneys();\n      if (journeyReco) recommendations.push(journeyReco);\n\n      // Timing optimization\n      const timingReco = await this.optimizeCampaignTiming();\n      if (timingReco) recommendations.push(timingReco);\n\n      if (recommendations.length > 0) {\n        const insight: AttributionInsight = {\n          id: `insight_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n          timestamp: new Date(),\n          type: 'optimization_opportunity',\n          confidence: 0.85,\n          insight: `Identified ${recommendations.length} optimization opportunities`,\n          details: {\n            recommendations,\n            impact: this.calculateTotalImpact(recommendations)\n          },\n          actionRequired: recommendations.some(r => r.priority === 'high'),\n          suggestedActions: this.generateOptimizationActions(recommendations)\n        };\n\n        insights.push(insight);\n      }\n\n    } catch (error) {\n      logger.error('Optimization analysis failed', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n    }\n\n    return insights;\n  }\n\n  /**\n   * Process autonomous actions based on insights\n   */\n  private async processAutonomousActions(insight: AttributionInsight) {\n    if (!insight.suggestedActions) return;\n\n    for (const action of insight.suggestedActions) {\n      // Check risk level and approval requirements\n      if (action.riskLevel === 'high' || action.approvalRequired) {\n        // Queue for approval\n        await this.queueForApproval(action, insight);\n      } else if (action.type === 'immediate') {\n        // Execute immediately\n        await this.executeAutonomousAction(action);\n      } else if (action.type === 'scheduled') {\n        // Schedule for later execution\n        await this.scheduleAction(action);\n      } else if (action.type === 'conditional') {\n        // Set up monitoring for trigger condition\n        await this.setupConditionalTrigger(action);\n      }\n    }\n  }\n\n  /**\n   * Execute an autonomous action\n   */\n  private async executeAutonomousAction(action: AutonomousAction) {\n    const tracer = trace.getTracer('autonomous-attribution');\n    \n    return tracer.startActiveSpan('execute-action', async (span) => {\n      try {\n        span.setAttributes({\n          'action.id': action.id,\n          'action.type': action.type,\n          'action.riskLevel': action.riskLevel\n        });\n\n        logger.info('Executing autonomous attribution action', {\n          actionId: action.id,\n          action: action.action,\n          targetEntity: action.targetEntity\n        });\n\n        // Execute based on action type\n        switch (action.action) {\n          case 'reallocate_budget':\n            await this.executeBudgetReallocation(action);\n            break;\n\n          case 'adjust_channel_mix':\n            await this.executeChannelMixAdjustment(action);\n            break;\n\n          case 'optimize_journey':\n            await this.executeJourneyOptimization(action);\n            break;\n\n          case 'update_attribution_model':\n            await this.updateAttributionModel(action);\n            break;\n\n          case 'pause_underperforming':\n            await this.pauseUnderperformingChannels(action);\n            break;\n\n          case 'scale_high_performers':\n            await this.scaleHighPerformingChannels(action);\n            break;\n\n          default:\n            logger.warn('Unknown autonomous action', { action: action.action });\n        }\n\n        // Emit action executed event\n        this.emit('action_executed', {\n          actionId: action.id,\n          action: action.action,\n          timestamp: new Date(),\n          success: true\n        });\n\n      } catch (error) {\n        span.setStatus({ code: 2, message: String(error) });\n        logger.error('Autonomous action execution failed', {\n          actionId: action.id,\n          error: error instanceof Error ? error.message : String(error)\n        });\n      } finally {\n        span.end();\n      }\n    });\n  }\n\n  /**\n   * Register with decision engines for coordination\n   */\n  private registerWithDecisionEngines() {\n    // Register attribution insights provider\n    strategicDecisionEngine.registerDataProvider('attribution', {\n      getInsights: async () => this.getRecentInsights(),\n      getMetrics: async () => this.getAttributionMetrics(),\n      getRecommendations: async () => this.getAttributionRecommendations()\n    });\n\n    // Register real-time attribution handler\n    realtimeDecisionEngine.registerHandler('attribution_change', async (event) => {\n      await this.handleRealtimeAttributionChange(event);\n    });\n\n    // Register with multi-agent coordinator\n    multiAgentCoordinator.on('collaboration_request', async (request) => {\n      if (request.capabilities.includes('attribution')) {\n        await this.participateInCollaboration(request);\n      }\n    });\n  }\n\n  /**\n   * Get recent attribution insights\n   */\n  async getRecentInsights(hours = 24): Promise<AttributionInsight[]> {\n    const cutoff = new Date();\n    cutoff.setHours(cutoff.getHours() - hours);\n\n    const allInsights: AttributionInsight[] = [];\n    \n    for (const insights of this.insightHistory.values()) {\n      allInsights.push(...insights.filter(i => i.timestamp > cutoff));\n    }\n\n    return allInsights.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\n  }\n\n  /**\n   * Get current attribution metrics\n   */\n  async getAttributionMetrics(): Promise<Record<string, any>> {\n    const metrics = {\n      totalConversions: 0,\n      totalRevenue: 0,\n      avgTimeToConversion: 0,\n      topChannels: [] as any[],\n      attributionHealth: 'good' as 'excellent' | 'good' | 'warning' | 'critical'\n    };\n\n    // Calculate metrics from recent data\n    const recentConversions = await prisma.conversionTracking.findMany({\n      where: {\n        occurredAt: { gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) }\n      }\n    });\n\n    metrics.totalConversions = recentConversions.length;\n    metrics.totalRevenue = recentConversions.reduce((sum, c) => sum + (c.value || 0), 0);\n\n    return metrics;\n  }\n\n  /**\n   * Get attribution-based recommendations\n   */\n  async getAttributionRecommendations(): Promise<AttributionRecommendation[]> {\n    const insights = await this.getRecentInsights(168); // Last week\n    const recommendations: AttributionRecommendation[] = [];\n\n    for (const insight of insights) {\n      if (insight.details.recommendations) {\n        recommendations.push(...insight.details.recommendations);\n      }\n    }\n\n    return recommendations.sort((a, b) => {\n      const priorityOrder = { high: 0, medium: 1, low: 2 };\n      return priorityOrder[a.priority] - priorityOrder[b.priority];\n    });\n  }\n\n  /**\n   * Handle real-time attribution changes\n   */\n  private async handleRealtimeAttributionChange(event: any) {\n    logger.info('Handling real-time attribution change', { event });\n\n    // Trigger immediate analysis if significant\n    if (event.significance === 'high') {\n      await this.performAttributionAnalysis();\n    }\n  }\n\n  /**\n   * Participate in multi-agent collaboration\n   */\n  private async participateInCollaboration(request: any) {\n    logger.info('Participating in multi-agent collaboration for attribution', {\n      sessionId: request.sessionId,\n      objective: request.objective\n    });\n\n    // Provide attribution insights for collaboration\n    const insights = await this.getRecentInsights();\n    const metrics = await this.getAttributionMetrics();\n\n    return {\n      agentId: 'attribution_engine',\n      insights,\n      metrics,\n      recommendations: await this.getAttributionRecommendations()\n    };\n  }\n\n  // Helper methods for generating actions and recommendations\n\n  private generateChannelActions(metrics: ChannelPerformance, change: number): AutonomousAction[] {\n    const actions: AutonomousAction[] = [];\n\n    if (change > 0.3) {\n      // Channel performing well - scale up\n      actions.push({\n        id: `action_${Date.now()}_scale`,\n        type: 'immediate',\n        action: 'scale_high_performers',\n        description: `Scale up ${metrics.channel} channel due to ${Math.round(change * 100)}% improvement`,\n        targetEntity: {\n          type: metrics.entityType,\n          id: metrics.channel\n        },\n        parameters: {\n          scalePercentage: Math.min(50, Math.round(change * 100))\n        },\n        approvalRequired: change > 0.5,\n        riskLevel: change > 0.5 ? 'medium' : 'low'\n      });\n    } else if (change < -0.3) {\n      // Channel underperforming - investigate or pause\n      actions.push({\n        id: `action_${Date.now()}_pause`,\n        type: 'conditional',\n        action: 'pause_underperforming',\n        description: `Consider pausing ${metrics.channel} channel due to ${Math.round(Math.abs(change) * 100)}% decline`,\n        targetEntity: {\n          type: metrics.entityType,\n          id: metrics.channel\n        },\n        parameters: {\n          threshold: -0.4\n        },\n        trigger: {\n          condition: 'performance_below_threshold',\n          threshold: -0.4\n        },\n        approvalRequired: true,\n        riskLevel: 'medium'\n      });\n    }\n\n    return actions;\n  }\n\n  private generateJourneyInsights(pattern: JourneyPattern): string[] {\n    const insights: string[] = [];\n\n    if (pattern.avgTimeToConversion < 24) {\n      insights.push('Fast conversion journey - customers decide quickly');\n    } else if (pattern.avgTimeToConversion > 168) {\n      insights.push('Long consideration period - nurturing required');\n    }\n\n    if (pattern.channels.length > 3) {\n      insights.push('Multi-channel journey - coordination important');\n    }\n\n    if (pattern.avgValue > 1000) {\n      insights.push('High-value conversion path - prioritize optimization');\n    }\n\n    return insights;\n  }\n\n  private generateJourneyActions(pattern: JourneyPattern): AutonomousAction[] {\n    return [{\n      id: `action_${Date.now()}_optimize_journey`,\n      type: 'scheduled',\n      action: 'optimize_journey',\n      description: `Optimize high-value journey pattern with ${pattern.frequency} conversions`,\n      targetEntity: {\n        type: EntityType.WORKFLOW,\n        id: 'journey_optimization'\n      },\n      parameters: {\n        pattern: pattern.pattern,\n        targetConversionRate: pattern.conversionRate * 1.2\n      },\n      approvalRequired: false,\n      riskLevel: 'low'\n    }];\n  }\n\n  private generateDriverRecommendations(drivers: ConversionDriver[]): AttributionRecommendation[] {\n    return drivers.map(driver => ({\n      id: `reco_${Date.now()}_${driver.factor}`,\n      type: driver.type === 'channel' ? 'channel_optimization' : \n            driver.type === 'timing' ? 'timing_change' : 'content_adjustment',\n      priority: Math.abs(driver.impact) > 0.4 ? 'high' : 'medium',\n      description: driver.description,\n      expectedImpact: {\n        conversions: driver.impact * 20,\n        revenue: driver.impact * 25,\n        cost: 5\n      },\n      implementation: {\n        difficulty: 'medium',\n        timeframe: '1-2 weeks',\n        steps: [`Analyze ${driver.factor}`, 'Implement changes', 'Monitor results']\n      }\n    }));\n  }\n\n  private generateDriverActions(drivers: ConversionDriver[]): AutonomousAction[] {\n    const highImpactDrivers = drivers.filter(d => Math.abs(d.impact) > 0.4);\n    \n    return highImpactDrivers.map(driver => ({\n      id: `action_${Date.now()}_${driver.factor}`,\n      type: 'scheduled',\n      action: 'implement_driver_optimization',\n      description: `Optimize ${driver.factor} based on attribution analysis`,\n      targetEntity: {\n        type: EntityType.CAMPAIGN,\n        id: 'all'\n      },\n      parameters: {\n        driver,\n        optimization: driver.type\n      },\n      approvalRequired: driver.type === 'budget_reallocation',\n      riskLevel: driver.type === 'budget_reallocation' ? 'medium' : 'low'\n    }));\n  }\n\n  private calculateTotalImpact(recommendations: AttributionRecommendation[]): BusinessImpact {\n    const current = { revenue: 100000, conversions: 1000 }; // Example baseline\n    \n    const projectedRevenue = recommendations.reduce((sum, r) => \n      sum + (current.revenue * (r.expectedImpact.revenue / 100)), current.revenue);\n    \n    const projectedConversions = recommendations.reduce((sum, r) => \n      sum + (current.conversions * (r.expectedImpact.conversions / 100)), current.conversions);\n\n    return {\n      revenue: {\n        current: current.revenue,\n        projected: projectedRevenue,\n        change: (projectedRevenue - current.revenue) / current.revenue\n      },\n      conversions: {\n        current: current.conversions,\n        projected: projectedConversions,\n        change: (projectedConversions - current.conversions) / current.conversions\n      },\n      efficiency: {\n        currentCPA: 50,\n        projectedCPA: 45,\n        currentROAS: 4,\n        projectedROAS: 4.5\n      }\n    };\n  }\n\n  private generateOptimizationActions(recommendations: AttributionRecommendation[]): AutonomousAction[] {\n    return recommendations\n      .filter(r => r.priority === 'high')\n      .map(r => ({\n        id: `action_${Date.now()}_${r.type}`,\n        type: 'scheduled' as const,\n        action: `implement_${r.type}`,\n        description: r.description,\n        targetEntity: {\n          type: EntityType.CAMPAIGN,\n          id: 'optimization_target'\n        },\n        parameters: {\n          recommendation: r,\n          steps: r.implementation.steps\n        },\n        approvalRequired: r.implementation.difficulty === 'hard',\n        riskLevel: r.implementation.difficulty === 'hard' ? 'high' : \n                   r.implementation.difficulty === 'medium' ? 'medium' : 'low'\n      }));\n  }\n\n  // Stub methods for specific analyses\n  private async analyzeChannelSequence(): Promise<ConversionDriver | null> {\n    // Implementation would analyze optimal channel sequences\n    return null;\n  }\n\n  private async analyzeConversionTiming(): Promise<ConversionDriver | null> {\n    // Implementation would analyze optimal timing patterns\n    return null;\n  }\n\n  private async analyzeTouchpointFrequency(): Promise<ConversionDriver | null> {\n    // Implementation would analyze optimal contact frequency\n    return null;\n  }\n\n  private async analyzeContentPerformance(): Promise<ConversionDriver | null> {\n    // Implementation would analyze content effectiveness\n    return null;\n  }\n\n  private async getCurrentChannelMetrics(key: string): Promise<ChannelPerformance | null> {\n    // Implementation would fetch current metrics\n    return null;\n  }\n\n  private async detectUnusualJourneys(): Promise<string[]> {\n    // Implementation would detect anomalous journey patterns\n    return [];\n  }\n\n  private async analyzeBudgetAllocation(): Promise<AttributionRecommendation | null> {\n    // Implementation would analyze and recommend budget changes\n    return null;\n  }\n\n  private async optimizeChannelMix(): Promise<AttributionRecommendation | null> {\n    // Implementation would recommend channel mix changes\n    return null;\n  }\n\n  private async optimizeCustomerJourneys(): Promise<AttributionRecommendation | null> {\n    // Implementation would recommend journey optimizations\n    return null;\n  }\n\n  private async optimizeCampaignTiming(): Promise<AttributionRecommendation | null> {\n    // Implementation would recommend timing optimizations\n    return null;\n  }\n\n  private async queueForApproval(action: AutonomousAction, insight: AttributionInsight) {\n    logger.info('Queueing action for approval', {\n      actionId: action.id,\n      insightId: insight.id\n    });\n  }\n\n  private async scheduleAction(action: AutonomousAction) {\n    logger.info('Scheduling action for later execution', {\n      actionId: action.id\n    });\n  }\n\n  private async setupConditionalTrigger(action: AutonomousAction) {\n    logger.info('Setting up conditional trigger for action', {\n      actionId: action.id,\n      trigger: action.trigger\n    });\n  }\n\n  private async executeBudgetReallocation(action: AutonomousAction) {\n    logger.info('Executing budget reallocation', action.parameters);\n  }\n\n  private async executeChannelMixAdjustment(action: AutonomousAction) {\n    logger.info('Executing channel mix adjustment', action.parameters);\n  }\n\n  private async executeJourneyOptimization(action: AutonomousAction) {\n    logger.info('Executing journey optimization', action.parameters);\n  }\n\n  private async updateAttributionModel(action: AutonomousAction) {\n    logger.info('Updating attribution model', action.parameters);\n  }\n\n  private async pauseUnderperformingChannels(action: AutonomousAction) {\n    logger.info('Pausing underperforming channels', action.parameters);\n  }\n\n  private async scaleHighPerformingChannels(action: AutonomousAction) {\n    logger.info('Scaling high performing channels', action.parameters);\n  }\n\n  private storeInsights(insights: AttributionInsight[]) {\n    const key = new Date().toISOString().split('T')[0]; // Daily key\n    \n    if (!this.insightHistory.has(key)) {\n      this.insightHistory.set(key, []);\n    }\n    \n    this.insightHistory.get(key)!.push(...insights);\n    \n    // Keep only last 30 days\n    const cutoff = new Date();\n    cutoff.setDate(cutoff.getDate() - 30);\n    \n    for (const [date, _] of this.insightHistory.entries()) {\n      if (new Date(date) < cutoff) {\n        this.insightHistory.delete(date);\n      }\n    }\n  }\n\n  /**\n   * Cleanup and stop the engine\n   */\n  destroy() {\n    if (this.analysisInterval) {\n      clearInterval(this.analysisInterval);\n      this.analysisInterval = null;\n    }\n    \n    this.removeAllListeners();\n    logger.info('Autonomous attribution engine destroyed');\n  }\n}\n\n// Export singleton instance\nexport const autonomousAttributionEngine = new AutonomousAttributionEngine();\n\n// Export types\nexport { AutonomousAttributionEngine };"],"names":["AutonomousAttributionEngine","autonomousAttributionEngine","EventEmitter","constructor","analysisInterval","decisionQueue","insightHistory","Map","performanceBaseline","initializeEngine","logger","info","loadPerformanceBaselines","startContinuousAnalysis","registerWithDecisionEngines","error","Error","message","String","thirtyDaysAgo","Date","setDate","getDate","conversions","prisma","conversionTracking","findMany","where","occurredAt","gte","include","event","channelData","conversion","touchPoints","JSON","parse","touchPoint","key","entityType","type","has","set","revenue","data","get","value","push","entries","channel","split","performance","cost","roi","roas","attribution","firstTouch","lastTouch","linear","timeDecay","positionBased","trend","channels","size","setInterval","performAttributionAnalysis","tracer","trace","getTracer","startActiveSpan","span","setAttributes","now","channelInsights","analyzeChannelPerformance","journeyInsights","analyzeJourneyPatterns","driverInsights","identifyConversionDrivers","anomalyInsights","detectAttributionAnomalies","optimizationInsights","generateOptimizationOpportunities","allInsights","insight","actionRequired","suggestedActions","processAutonomousActions","storeInsights","emit","timestamp","insightCount","length","actionsGenerated","insights","actions","setStatus","code","end","sevenDaysAgo","channelMetrics","models","AttributionModel","FIRST_TOUCH","LAST_TOUCH","LINEAR","TIME_DECAY","POSITION_BASED","model","attributedTouchPoints","applyAttributionModel","metrics","attributionKey","toLowerCase","replace","weight","baseline","conversionChange","Math","abs","id","random","toString","substr","confidence","round","details","impact","current","projected","change","efficiency","currentCPA","projectedCPA","currentROAS","projectedROAS","generateChannelActions","not","take","orderBy","patternMap","patternKey","map","tp","join","pattern","frequency","avgTimeToConversion","avgValue","conversionRate","Set","significance","timeToConversion","getTime","totalConversions","values","generateJourneyInsights","min","journeyPatterns","generateJourneyActions","undefined","drivers","sequenceDriver","analyzeChannelSequence","timingDriver","analyzeConversionTiming","frequencyDriver","analyzeTouchpointFrequency","contentDriver","analyzeContentPerformance","significantDrivers","filter","d","conversionDrivers","recommendations","generateDriverRecommendations","some","generateDriverActions","anomalies","getCurrentChannelMetrics","revenueChange","max","unusualPatterns","detectUnusualJourneys","a","EntityType","CAMPAIGN","action","description","targetEntity","parameters","approvalRequired","riskLevel","budgetReco","analyzeBudgetAllocation","channelMixReco","optimizeChannelMix","journeyReco","optimizeCustomerJourneys","timingReco","optimizeCampaignTiming","calculateTotalImpact","r","priority","generateOptimizationActions","queueForApproval","executeAutonomousAction","scheduleAction","setupConditionalTrigger","actionId","executeBudgetReallocation","executeChannelMixAdjustment","executeJourneyOptimization","updateAttributionModel","pauseUnderperformingChannels","scaleHighPerformingChannels","warn","success","strategicDecisionEngine","registerDataProvider","getInsights","getRecentInsights","getMetrics","getAttributionMetrics","getRecommendations","getAttributionRecommendations","realtimeDecisionEngine","registerHandler","handleRealtimeAttributionChange","multiAgentCoordinator","on","request","capabilities","includes","participateInCollaboration","hours","cutoff","setHours","getHours","i","sort","b","totalRevenue","topChannels","attributionHealth","recentConversions","reduce","sum","c","priorityOrder","high","medium","low","sessionId","objective","agentId","scalePercentage","threshold","trigger","condition","WORKFLOW","targetConversionRate","driver","factor","expectedImpact","implementation","difficulty","timeframe","steps","highImpactDrivers","optimization","projectedRevenue","projectedConversions","recommendation","insightId","toISOString","date","_","delete","destroy","clearInterval","removeAllListeners"],"mappings":"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"}