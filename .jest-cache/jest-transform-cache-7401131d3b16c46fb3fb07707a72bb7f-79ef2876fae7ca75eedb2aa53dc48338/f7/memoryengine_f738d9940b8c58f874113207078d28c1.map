{"version":3,"sources":["/Users/supreme/Desktop/marketsage/src/lib/ai/memory-engine.ts"],"sourcesContent":["/**\n * Supreme-AI Memory Engine\n * ========================\n * Long-term memory and context management for ChatGPT-like continuity\n * \n * Features:\n * ðŸ§  Conversation memory\n * ðŸ‘¤ Customer interaction history  \n * ðŸ“Š Campaign outcome tracking\n * ðŸŽ¯ Contextual recommendations\n * ðŸ”„ Memory consolidation\n */\n\nimport { promises as fs } from 'fs';\nimport { join } from 'path';\nimport { logger } from '@/lib/logger';\n\nexport interface MemoryEntry {\n  id: string;\n  type: 'conversation' | 'campaign' | 'customer' | 'insight';\n  timestamp: Date;\n  userId: string;\n  content: string;\n  metadata: Record<string, any>;\n  importance: number; // 0-1 scale\n  tags: string[];\n}\n\nexport interface ConversationContext {\n  sessionId: string;\n  userId: string;\n  messages: Array<{\n    role: 'user' | 'assistant';\n    content: string;\n    timestamp: Date;\n    metadata?: Record<string, any>;\n  }>;\n  summary: string;\n  lastActive: Date;\n}\n\nexport interface CustomerMemory {\n  customerId: string;\n  interactions: Array<{\n    type: 'email' | 'sms' | 'whatsapp' | 'campaign' | 'support';\n    content: string;\n    timestamp: Date;\n    outcome?: string;\n    sentiment?: number;\n  }>;\n  preferences: Record<string, any>;\n  lastUpdate: Date;\n}\n\nexport class MemoryEngine {\n  private memories: MemoryEntry[] = [];\n  private conversations: Map<string, ConversationContext> = new Map();\n  private customerMemories: Map<string, CustomerMemory> = new Map();\n  private memoryPath: string;\n\n  constructor() {\n    this.memoryPath = join(process.cwd(), '.supreme', 'memory');\n  }\n\n  // Initialize memory system\n  async initialize() {\n    try {\n      await fs.mkdir(this.memoryPath, { recursive: true });\n      await this.loadMemories();\n      await this.loadConversations();\n      await this.loadCustomerMemories();\n    } catch (error) {\n      logger.error('Memory engine initialization failed', error);\n    }\n  }\n\n  // Store new memory entry\n  async storeMemory(entry: Omit<MemoryEntry, 'id' | 'timestamp'>): Promise<string> {\n    const id = `mem_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    const memory: MemoryEntry = {\n      ...entry,\n      id,\n      timestamp: new Date()\n    };\n\n    this.memories.push(memory);\n    await this.saveMemories();\n\n    logger.info('Memory stored', { id, type: entry.type, importance: entry.importance });\n    return id;\n  }\n\n  // Retrieve relevant memories for context\n  async getRelevantMemories(query: string, userId: string, limit = 5): Promise<MemoryEntry[]> {\n    const userMemories = this.memories.filter(m => m.userId === userId);\n    \n    // Simple relevance scoring based on keyword matching and importance\n    const scored = userMemories.map(memory => {\n      const contentWords = memory.content.toLowerCase().split(/\\s+/);\n      const queryWords = query.toLowerCase().split(/\\s+/);\n      \n      let relevanceScore = 0;\n      queryWords.forEach(qWord => {\n        if (contentWords.some(cWord => cWord.includes(qWord) || qWord.includes(cWord))) {\n          relevanceScore += 1;\n        }\n      });\n      \n      // Factor in importance and recency\n      const recencyFactor = Math.max(0, 1 - (Date.now() - memory.timestamp.getTime()) / (7 * 24 * 60 * 60 * 1000)); // 1 week decay\n      const finalScore = relevanceScore * memory.importance * (0.7 + 0.3 * recencyFactor);\n      \n      return { memory, score: finalScore };\n    });\n\n    return scored\n      .sort((a, b) => b.score - a.score)\n      .slice(0, limit)\n      .map(s => s.memory);\n  }\n\n  // Conversation management\n  async startConversation(sessionId: string, userId: string): Promise<ConversationContext> {\n    const context: ConversationContext = {\n      sessionId,\n      userId,\n      messages: [],\n      summary: '',\n      lastActive: new Date()\n    };\n\n    this.conversations.set(sessionId, context);\n    return context;\n  }\n\n  async addMessage(sessionId: string, role: 'user' | 'assistant', content: string, metadata?: Record<string, any>) {\n    const conversation = this.conversations.get(sessionId);\n    if (!conversation) {\n      throw new Error(`Conversation ${sessionId} not found`);\n    }\n\n    conversation.messages.push({\n      role,\n      content,\n      timestamp: new Date(),\n      metadata\n    });\n\n    conversation.lastActive = new Date();\n\n    // Auto-summarize if conversation gets long\n    if (conversation.messages.length > 20) {\n      await this.summarizeConversation(sessionId);\n    }\n\n    await this.saveConversations();\n  }\n\n  async getConversationContext(sessionId: string): Promise<ConversationContext | null> {\n    return this.conversations.get(sessionId) || null;\n  }\n\n  // Summarize long conversations to maintain context efficiency\n  private async summarizeConversation(sessionId: string) {\n    const conversation = this.conversations.get(sessionId);\n    if (!conversation) return;\n\n    const recentMessages = conversation.messages.slice(-10);\n    const olderMessages = conversation.messages.slice(0, -10);\n\n    // Simple summarization - extract key topics and outcomes\n    const topics = new Set<string>();\n    const outcomes = new Set<string>();\n\n    olderMessages.forEach(msg => {\n      const words = msg.content.toLowerCase().split(/\\s+/);\n      words.forEach(word => {\n        if (word.length > 4 && !['said', 'told', 'asked', 'replied'].includes(word)) {\n          topics.add(word);\n        }\n      });\n\n      if (msg.metadata?.outcome) {\n        outcomes.add(msg.metadata.outcome);\n      }\n    });\n\n    const summary = `Previous discussion covered: ${Array.from(topics).slice(0, 5).join(', ')}. Outcomes: ${Array.from(outcomes).join(', ')}.`;\n    \n    conversation.summary = summary;\n    conversation.messages = recentMessages;\n\n    // Store the summarized portion as a memory\n    await this.storeMemory({\n      type: 'conversation',\n      userId: conversation.userId,\n      content: `Conversation summary: ${summary}`,\n      metadata: { sessionId, messageCount: olderMessages.length },\n      importance: 0.6,\n      tags: ['conversation', 'summary']\n    });\n  }\n\n  // Customer memory management\n  async updateCustomerMemory(customerId: string, interaction: CustomerMemory['interactions'][0]) {\n    let memory = this.customerMemories.get(customerId);\n    \n    if (!memory) {\n      memory = {\n        customerId,\n        interactions: [],\n        preferences: {},\n        lastUpdate: new Date()\n      };\n      this.customerMemories.set(customerId, memory);\n    }\n\n    memory.interactions.push(interaction);\n    memory.lastUpdate = new Date();\n\n    // Keep only last 50 interactions per customer\n    if (memory.interactions.length > 50) {\n      memory.interactions = memory.interactions.slice(-50);\n    }\n\n    await this.saveCustomerMemories();\n\n    // Create a memory entry for important interactions\n    if (interaction.outcome === 'converted' || interaction.sentiment && Math.abs(interaction.sentiment) > 0.7) {\n      await this.storeMemory({\n        type: 'customer',\n        userId: customerId,\n        content: `Customer interaction: ${interaction.type} - ${interaction.content}`,\n        metadata: { \n          customerId, \n          outcome: interaction.outcome, \n          sentiment: interaction.sentiment \n        },\n        importance: interaction.outcome === 'converted' ? 0.9 : 0.7,\n        tags: ['customer', interaction.type, interaction.outcome || 'interaction']\n      });\n    }\n  }\n\n  async getCustomerMemory(customerId: string): Promise<CustomerMemory | null> {\n    return this.customerMemories.get(customerId) || null;\n  }\n\n  // Context-aware response generation\n  async getContextForResponse(userId: string, query: string): Promise<{\n    relevantMemories: MemoryEntry[];\n    conversationHistory: ConversationContext | null;\n    customerInsights: CustomerMemory | null;\n    contextSummary: string;\n  }> {\n    const [relevantMemories, conversationHistory, customerInsights] = await Promise.all([\n      this.getRelevantMemories(query, userId, 3),\n      this.getConversationContext(userId), // Using userId as sessionId for simplicity\n      this.getCustomerMemory(userId)\n    ]);\n\n    // Build context summary\n    const memoryContext = relevantMemories.map(m => m.content).join(' ');\n    const conversationContext = conversationHistory?.summary || '';\n    const customerContext = customerInsights?.interactions.slice(-3).map(i => `${i.type}: ${i.content}`).join(' ') || '';\n\n    const contextSummary = `Recent context: ${conversationContext} Related memories: ${memoryContext} Customer history: ${customerContext}`.slice(0, 500);\n\n    return {\n      relevantMemories,\n      conversationHistory,\n      customerInsights,\n      contextSummary\n    };\n  }\n\n  // Memory consolidation - run periodically to optimize memory storage\n  async consolidateMemories() {\n    const now = Date.now();\n    const oneWeek = 7 * 24 * 60 * 60 * 1000;\n    const oneMonth = 30 * 24 * 60 * 60 * 1000;\n\n    let removedCount = 0;\n    let consolidatedCount = 0;\n\n    // Remove low-importance old memories\n    this.memories = this.memories.filter(memory => {\n      const age = now - memory.timestamp.getTime();\n      if (age > oneMonth && memory.importance < 0.3) {\n        removedCount++;\n        return false;\n      }\n      if (age > oneWeek && memory.importance < 0.1) {\n        removedCount++;\n        return false;\n      }\n      return true;\n    });\n\n    // Consolidate similar memories\n    const consolidatedMemories: MemoryEntry[] = [];\n    const processedIds = new Set<string>();\n\n    this.memories.forEach(memory => {\n      if (processedIds.has(memory.id)) return;\n\n      const similar = this.memories.filter(m => \n        m.id !== memory.id && \n        !processedIds.has(m.id) &&\n        m.type === memory.type &&\n        m.userId === memory.userId &&\n        this.calculateSimilarity(memory.content, m.content) > 0.8\n      );\n\n      if (similar.length > 0) {\n        // Consolidate similar memories\n        const allMemories = [memory, ...similar];\n        const consolidatedContent = allMemories.map(m => m.content).join(' ');\n        const avgImportance = allMemories.reduce((sum, m) => sum + m.importance, 0) / allMemories.length;\n        const allTags = [...new Set(allMemories.flatMap(m => m.tags))];\n\n        consolidatedMemories.push({\n          ...memory,\n          content: consolidatedContent.slice(0, 500), // Truncate if too long\n          importance: Math.min(0.9, avgImportance * 1.1), // Slight boost for consolidated\n          tags: allTags,\n          metadata: { ...memory.metadata, consolidatedFrom: allMemories.length }\n        });\n\n        allMemories.forEach(m => processedIds.add(m.id));\n        consolidatedCount++;\n      } else {\n        consolidatedMemories.push(memory);\n        processedIds.add(memory.id);\n      }\n    });\n\n    this.memories = consolidatedMemories;\n    await this.saveMemories();\n\n    logger.info('Memory consolidation complete', {\n      removedCount,\n      consolidatedCount,\n      totalMemories: this.memories.length\n    });\n  }\n\n  private calculateSimilarity(text1: string, text2: string): number {\n    const words1 = new Set(text1.toLowerCase().split(/\\s+/));\n    const words2 = new Set(text2.toLowerCase().split(/\\s+/));\n    const intersection = new Set([...words1].filter(x => words2.has(x)));\n    const union = new Set([...words1, ...words2]);\n    return intersection.size / union.size;\n  }\n\n  // Persistence methods\n  private async saveMemories() {\n    try {\n      await fs.writeFile(\n        join(this.memoryPath, 'memories.json'),\n        JSON.stringify(this.memories, null, 2)\n      );\n    } catch (error) {\n      logger.error('Failed to save memories', error);\n    }\n  }\n\n  private async loadMemories() {\n    try {\n      const data = await fs.readFile(join(this.memoryPath, 'memories.json'), 'utf8');\n      this.memories = JSON.parse(data).map((m: any) => ({\n        ...m,\n        timestamp: new Date(m.timestamp)\n      }));\n    } catch {\n      this.memories = [];\n    }\n  }\n\n  private async saveConversations() {\n    try {\n      const data = Object.fromEntries(\n        Array.from(this.conversations.entries()).map(([k, v]) => [k, v])\n      );\n      await fs.writeFile(\n        join(this.memoryPath, 'conversations.json'),\n        JSON.stringify(data, null, 2)\n      );\n    } catch (error) {\n      logger.error('Failed to save conversations', error);\n    }\n  }\n\n  private async loadConversations() {\n    try {\n      const data = await fs.readFile(join(this.memoryPath, 'conversations.json'), 'utf8');\n      const parsed = JSON.parse(data);\n      this.conversations = new Map(\n        Object.entries(parsed).map(([k, v]: [string, any]) => [\n          k,\n          {\n            ...v,\n            lastActive: new Date(v.lastActive),\n            messages: v.messages.map((m: any) => ({\n              ...m,\n              timestamp: new Date(m.timestamp)\n            }))\n          }\n        ])\n      );\n    } catch {\n      this.conversations = new Map();\n    }\n  }\n\n  private async saveCustomerMemories() {\n    try {\n      const data = Object.fromEntries(this.customerMemories.entries());\n      await fs.writeFile(\n        join(this.memoryPath, 'customers.json'),\n        JSON.stringify(data, null, 2)\n      );\n    } catch (error) {\n      logger.error('Failed to save customer memories', error);\n    }\n  }\n\n  private async loadCustomerMemories() {\n    try {\n      const data = await fs.readFile(join(this.memoryPath, 'customers.json'), 'utf8');\n      const parsed = JSON.parse(data);\n      this.customerMemories = new Map(\n        Object.entries(parsed).map(([k, v]: [string, any]) => [\n          k,\n          {\n            ...v,\n            lastUpdate: new Date(v.lastUpdate),\n            interactions: v.interactions.map((i: any) => ({\n              ...i,\n              timestamp: new Date(i.timestamp)\n            }))\n          }\n        ])\n      );\n    } catch {\n      this.customerMemories = new Map();\n    }\n  }\n}\n\n// Export singleton memory engine\nexport const supremeMemory = new MemoryEngine(); "],"names":["MemoryEngine","supremeMemory","constructor","memories","conversations","Map","customerMemories","memoryPath","join","process","cwd","initialize","fs","mkdir","recursive","loadMemories","loadConversations","loadCustomerMemories","error","logger","storeMemory","entry","id","Date","now","Math","random","toString","substr","memory","timestamp","push","saveMemories","info","type","importance","getRelevantMemories","query","userId","limit","userMemories","filter","m","scored","map","contentWords","content","toLowerCase","split","queryWords","relevanceScore","forEach","qWord","some","cWord","includes","recencyFactor","max","getTime","finalScore","score","sort","a","b","slice","s","startConversation","sessionId","context","messages","summary","lastActive","set","addMessage","role","metadata","conversation","get","Error","length","summarizeConversation","saveConversations","getConversationContext","recentMessages","olderMessages","topics","Set","outcomes","msg","words","word","add","outcome","Array","from","messageCount","tags","updateCustomerMemory","customerId","interaction","interactions","preferences","lastUpdate","saveCustomerMemories","sentiment","abs","getCustomerMemory","getContextForResponse","relevantMemories","conversationHistory","customerInsights","Promise","all","memoryContext","conversationContext","customerContext","i","contextSummary","consolidateMemories","oneWeek","oneMonth","removedCount","consolidatedCount","age","consolidatedMemories","processedIds","has","similar","calculateSimilarity","allMemories","consolidatedContent","avgImportance","reduce","sum","allTags","flatMap","min","consolidatedFrom","totalMemories","text1","text2","words1","words2","intersection","x","union","size","writeFile","JSON","stringify","data","readFile","parse","Object","fromEntries","entries","k","v","parsed"],"mappings":"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"}