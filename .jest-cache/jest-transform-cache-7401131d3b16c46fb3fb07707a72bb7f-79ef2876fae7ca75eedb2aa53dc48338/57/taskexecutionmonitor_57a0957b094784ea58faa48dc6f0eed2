8be01b5f29e72619c3a24fc2ea2f32a2
/**
 * Task Execution Monitoring - Enhanced Production Version
 * ======================================================
 * Comprehensive monitoring, audit logging, rollback capabilities, and performance analytics
 * for AI task execution system with enterprise-grade security and compliance features.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    recordTaskExecution: function() {
        return recordTaskExecution;
    },
    taskExecutionMonitor: function() {
        return taskExecutionMonitor;
    }
});
const _logger = require("../logger");
const _prisma = /*#__PURE__*/ _interop_require_default(require("../db/prisma"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
class TaskExecutionMonitor {
    constructor(){
        this.metrics = new Map();
        this.taskLogs = new Map();
        this.rollbackCapabilities = new Map();
        this.MAX_EVENTS_PER_TYPE = 1000 // Limit memory usage
        ;
        this.MAX_TASK_LOGS = 5000 // Limit task log storage
        ;
        this.performanceBuffer = {
            hourly: new Array(24).fill(0),
            daily: new Array(30).fill(0),
            weekly: new Array(52).fill(0)
        };
        // Start performance trend tracking
        this.startPerformanceTrendTracking();
        // Start automatic cleanup
        this.startAutomaticCleanup();
    }
    /**
   * Start comprehensive task execution with full audit logging
   */ async startTaskExecution(taskId, userId, userRole, taskType, description, parameters, riskLevel, securityContext, approvalId) {
        const executionId = `exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const taskLog = {
            id: executionId,
            taskId,
            userId,
            userRole,
            taskType,
            description: description.substring(0, 500),
            status: 'running',
            riskLevel,
            executionTime: 0,
            parameters,
            result: null,
            warnings: [],
            errors: [],
            auditTrail: [
                `${new Date().toISOString()}: Task execution started`
            ],
            approvalId,
            approvalRequired: !!approvalId,
            createdAt: new Date(),
            securityContext
        };
        this.taskLogs.set(executionId, taskLog);
        // Update performance trends
        this.updatePerformanceTrends(1);
        // Persist to database
        await this.persistTaskLog(taskLog);
        _logger.logger.info('Task execution started with comprehensive logging', {
            executionId,
            taskId,
            userId,
            taskType,
            riskLevel,
            approvalRequired: !!approvalId
        });
        return executionId;
    }
    /**
   * Record a task execution attempt (enhanced version)
   */ recordExecution(event) {
        const events = this.metrics.get(event.taskType) || [];
        events.push(event);
        // Keep only recent events to prevent memory overflow
        if (events.length > this.MAX_EVENTS_PER_TYPE) {
            events.splice(0, events.length - this.MAX_EVENTS_PER_TYPE);
        }
        this.metrics.set(event.taskType, events);
        // Log the event with enhanced details
        _logger.logger.info('Task execution recorded', {
            taskType: event.taskType,
            userId: event.userId,
            userRole: event.userRole,
            success: event.success,
            executionTime: event.executionTime,
            errorType: event.errorType,
            riskLevel: event.riskLevel,
            approvalRequired: event.approvalRequired,
            rollbackPerformed: event.rollbackPerformed,
            timestamp: event.timestamp
        });
        // Store metrics in database for persistence (async, don't wait)
        this.persistMetrics(event).catch((error)=>{
            _logger.logger.warn('Failed to persist task execution metrics', {
                error: error.message
            });
        });
    }
    /**
   * Complete task execution with comprehensive logging
   */ async completeTaskExecution(executionId, result, warnings = [], rollbackData) {
        const taskLog = this.taskLogs.get(executionId);
        if (!taskLog) {
            _logger.logger.error('Task log not found for completion', {
                executionId
            });
            return;
        }
        const executionTime = Date.now() - taskLog.createdAt.getTime();
        taskLog.status = 'completed';
        taskLog.executionTime = executionTime;
        taskLog.result = result;
        taskLog.warnings = warnings;
        taskLog.rollbackData = rollbackData;
        taskLog.completedAt = new Date();
        taskLog.auditTrail.push(`${new Date().toISOString()}: Task completed successfully in ${executionTime}ms`);
        if (warnings.length > 0) {
            taskLog.auditTrail.push(`${new Date().toISOString()}: ${warnings.length} warnings generated`);
        }
        // Create rollback capability if data is available
        if (rollbackData) {
            this.createRollbackCapability(executionId, rollbackData, taskLog);
        }
        // Record execution event
        this.recordExecution({
            taskType: taskLog.taskType,
            userId: taskLog.userId,
            userRole: taskLog.userRole,
            success: true,
            executionTime,
            timestamp: new Date(),
            riskLevel: taskLog.riskLevel,
            approvalRequired: taskLog.approvalRequired,
            parameters: taskLog.parameters,
            result,
            auditTrail: taskLog.auditTrail
        });
        // Update database
        await this.persistTaskLog(taskLog);
        _logger.logger.info('Task execution completed', {
            executionId,
            taskId: taskLog.taskId,
            executionTime,
            warnings: warnings.length,
            rollbackAvailable: !!rollbackData
        });
    }
    /**
   * Fail task execution with comprehensive logging
   */ async failTaskExecution(executionId, errorType, errorMessage, rollbackData) {
        const taskLog = this.taskLogs.get(executionId);
        if (!taskLog) {
            _logger.logger.error('Task log not found for failure', {
                executionId
            });
            return;
        }
        const executionTime = Date.now() - taskLog.createdAt.getTime();
        taskLog.status = 'failed';
        taskLog.executionTime = executionTime;
        taskLog.errors.push(errorMessage);
        taskLog.rollbackData = rollbackData;
        taskLog.completedAt = new Date();
        taskLog.auditTrail.push(`${new Date().toISOString()}: Task failed after ${executionTime}ms`);
        taskLog.auditTrail.push(`${new Date().toISOString()}: Error - ${errorType}: ${errorMessage}`);
        // Create rollback capability if data is available
        if (rollbackData) {
            this.createRollbackCapability(executionId, rollbackData, taskLog);
        }
        // Record execution event
        this.recordExecution({
            taskType: taskLog.taskType,
            userId: taskLog.userId,
            userRole: taskLog.userRole,
            success: false,
            executionTime,
            errorType,
            errorMessage,
            timestamp: new Date(),
            riskLevel: taskLog.riskLevel,
            approvalRequired: taskLog.approvalRequired,
            parameters: taskLog.parameters,
            auditTrail: taskLog.auditTrail
        });
        // Update database
        await this.persistTaskLog(taskLog);
        _logger.logger.error('Task execution failed', {
            executionId,
            taskId: taskLog.taskId,
            executionTime,
            errorType,
            errorMessage,
            rollbackAvailable: !!rollbackData
        });
    }
    /**
   * Perform task rollback with comprehensive logging
   */ async performRollback(executionId, rollbackReason, rollbackUserId) {
        const taskLog = this.taskLogs.get(executionId);
        const rollbackCapability = this.rollbackCapabilities.get(executionId);
        if (!taskLog || !rollbackCapability || !rollbackCapability.available) {
            _logger.logger.error('Rollback not available', {
                executionId,
                taskLog: !!taskLog,
                rollbackCapability: !!rollbackCapability
            });
            return false;
        }
        try {
            taskLog.auditTrail.push(`${new Date().toISOString()}: Rollback initiated by user ${rollbackUserId}`);
            taskLog.auditTrail.push(`${new Date().toISOString()}: Rollback reason: ${rollbackReason}`);
            // Execute rollback steps
            if (rollbackCapability.strategy === 'automatic') {
                taskLog.auditTrail.push(`${new Date().toISOString()}: Executing automatic rollback`);
                // In production, this would execute actual rollback operations
                for (const step of rollbackCapability.steps){
                    taskLog.auditTrail.push(`${new Date().toISOString()}: Rollback step: ${step}`);
                    // Simulate rollback step execution
                    await new Promise((resolve)=>setTimeout(resolve, 100));
                }
            } else {
                taskLog.auditTrail.push(`${new Date().toISOString()}: Manual rollback procedure initiated`);
            }
            taskLog.status = 'rolled_back';
            taskLog.rollbackPerformed = true;
            taskLog.rollbackReason = rollbackReason;
            taskLog.auditTrail.push(`${new Date().toISOString()}: Rollback completed successfully`);
            // Record rollback event
            this.recordExecution({
                taskType: taskLog.taskType,
                userId: taskLog.userId,
                userRole: taskLog.userRole,
                success: true,
                executionTime: taskLog.executionTime,
                timestamp: new Date(),
                riskLevel: taskLog.riskLevel,
                rollbackPerformed: true,
                rollbackReason,
                auditTrail: taskLog.auditTrail
            });
            // Update database
            await this.persistTaskLog(taskLog);
            _logger.logger.info('Task rollback completed', {
                executionId,
                taskId: taskLog.taskId,
                rollbackReason,
                rollbackUserId
            });
            return true;
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            taskLog.auditTrail.push(`${new Date().toISOString()}: Rollback failed: ${errorMessage}`);
            taskLog.errors.push(`Rollback failed: ${errorMessage}`);
            await this.persistTaskLog(taskLog);
            _logger.logger.error('Task rollback failed', {
                executionId,
                error: errorMessage
            });
            return false;
        }
    }
    /**
   * Get enhanced metrics for a specific task type
   */ getMetrics(taskType) {
        const events = this.metrics.get(taskType) || [];
        if (events.length === 0) {
            return {
                totalAttempts: 0,
                successfulExecutions: 0,
                failedExecutions: 0,
                successRate: 0,
                avgExecutionTime: 0,
                commonErrors: [],
                userRoleStats: {},
                rollbackRate: 0,
                approvalRequiredRate: 0,
                riskDistribution: {},
                performanceTrends: {
                    hourly: [
                        ...this.performanceBuffer.hourly
                    ],
                    daily: [
                        ...this.performanceBuffer.daily
                    ],
                    weekly: [
                        ...this.performanceBuffer.weekly
                    ]
                }
            };
        }
        const successful = events.filter((e)=>e.success);
        const failed = events.filter((e)=>!e.success);
        const rolledBack = events.filter((e)=>e.rollbackPerformed);
        const approvalRequired = events.filter((e)=>e.approvalRequired);
        const totalTime = events.reduce((sum, e)=>sum + e.executionTime, 0);
        // Count errors
        const errorCounts = {};
        failed.forEach((e)=>{
            if (e.errorType) {
                errorCounts[e.errorType] = (errorCounts[e.errorType] || 0) + 1;
            }
        });
        // Count user role stats
        const roleStats = {};
        events.forEach((e)=>{
            roleStats[e.userRole] = (roleStats[e.userRole] || 0) + 1;
        });
        // Count risk distribution
        const riskDistribution = {};
        events.forEach((e)=>{
            if (e.riskLevel) {
                riskDistribution[e.riskLevel] = (riskDistribution[e.riskLevel] || 0) + 1;
            }
        });
        const commonErrors = Object.entries(errorCounts).sort(([, a], [, b])=>b - a).slice(0, 5).map(([error])=>error);
        return {
            totalAttempts: events.length,
            successfulExecutions: successful.length,
            failedExecutions: failed.length,
            successRate: events.length > 0 ? successful.length / events.length * 100 : 0,
            avgExecutionTime: events.length > 0 ? totalTime / events.length : 0,
            commonErrors,
            userRoleStats: roleStats,
            rollbackRate: events.length > 0 ? rolledBack.length / events.length * 100 : 0,
            approvalRequiredRate: events.length > 0 ? approvalRequired.length / events.length * 100 : 0,
            riskDistribution,
            performanceTrends: {
                hourly: [
                    ...this.performanceBuffer.hourly
                ],
                daily: [
                    ...this.performanceBuffer.daily
                ],
                weekly: [
                    ...this.performanceBuffer.weekly
                ]
            }
        };
    }
    /**
   * Get comprehensive task log by execution ID
   */ getTaskLog(executionId) {
        return this.taskLogs.get(executionId);
    }
    /**
   * Get task logs for a user with filtering
   */ getUserTaskLogs(userId, status, taskType, limit = 50) {
        let logs = Array.from(this.taskLogs.values()).filter((log)=>log.userId === userId);
        if (status) {
            logs = logs.filter((log)=>log.status === status);
        }
        if (taskType) {
            logs = logs.filter((log)=>log.taskType === taskType);
        }
        return logs.sort((a, b)=>b.createdAt.getTime() - a.createdAt.getTime()).slice(0, limit);
    }
    /**
   * Get rollback capability for a task
   */ getRollbackCapability(executionId) {
        return this.rollbackCapabilities.get(executionId);
    }
    /**
   * Get all task logs that can be rolled back
   */ getRollbackCandidates(userId) {
        const candidates = Array.from(this.taskLogs.values()).filter((log)=>log.status === 'completed' && log.rollbackData && !log.rollbackPerformed && this.rollbackCapabilities.get(log.id)?.available);
        if (userId) {
            return candidates.filter((log)=>log.userId === userId);
        }
        return candidates;
    }
    /**
   * Create rollback capability for a task
   */ createRollbackCapability(executionId, rollbackData, taskLog) {
        const capability = {
            available: true,
            strategy: this.determineRollbackStrategy(taskLog.taskType, taskLog.riskLevel),
            steps: this.generateRollbackSteps(taskLog.taskType, rollbackData),
            timeLimit: this.getRollbackTimeLimit(taskLog.riskLevel),
            dependencies: this.getRollbackDependencies(taskLog.taskType),
            rollbackData
        };
        this.rollbackCapabilities.set(executionId, capability);
        // Auto-expire rollback capability after time limit
        setTimeout(()=>{
            const current = this.rollbackCapabilities.get(executionId);
            if (current && current.available) {
                current.available = false;
                taskLog.auditTrail.push(`${new Date().toISOString()}: Rollback capability expired after ${capability.timeLimit} minutes`);
            }
        }, capability.timeLimit * 60 * 1000);
    }
    /**
   * Determine rollback strategy based on task type and risk level
   */ determineRollbackStrategy(taskType, riskLevel) {
        if (taskType === 'reporting' || taskType === 'data_analysis') {
            return 'impossible'; // Read-only operations
        }
        if (riskLevel === 'critical') {
            return 'manual'; // High-risk operations require manual rollback
        }
        return 'automatic'; // Default to automatic rollback
    }
    /**
   * Generate rollback steps for a task type
   */ generateRollbackSteps(taskType, rollbackData) {
        const steps = [];
        switch(taskType){
            case 'segmentation':
                steps.push('Remove created customer segments');
                steps.push('Restore previous segmentation rules');
                steps.push('Update customer segment assignments');
                break;
            case 'campaign_optimization':
                steps.push('Restore original campaign settings');
                steps.push('Revert send time optimizations');
                steps.push('Reset A/B test configurations');
                break;
            case 'integration_config':
                steps.push('Disable new integration configuration');
                steps.push('Restore previous integration settings');
                steps.push('Validate system connectivity');
                break;
            default:
                steps.push('Restore previous system state');
                steps.push('Verify rollback completion');
        }
        return steps;
    }
    /**
   * Get rollback time limit based on risk level
   */ getRollbackTimeLimit(riskLevel) {
        const limits = {
            low: 1440,
            medium: 720,
            high: 180,
            critical: 60 // 1 hour
        };
        return limits[riskLevel] || limits.medium;
    }
    /**
   * Get rollback dependencies for a task type
   */ getRollbackDependencies(taskType) {
        const dependencies = {
            segmentation: [
                'customer_data',
                'segment_rules'
            ],
            campaign_optimization: [
                'campaign_settings',
                'email_templates'
            ],
            integration_config: [
                'api_credentials',
                'webhook_endpoints'
            ],
            data_analysis: [],
            reporting: [] // No dependencies for read-only
        };
        return dependencies[taskType] || [];
    }
    /**
   * Update performance trends
   */ updatePerformanceTrends(increment) {
        const now = new Date();
        const hourIndex = now.getHours();
        const dayIndex = now.getDate() - 1;
        const weekIndex = Math.floor((now.getTime() - new Date(now.getFullYear(), 0, 1).getTime()) / (7 * 24 * 60 * 60 * 1000));
        this.performanceBuffer.hourly[hourIndex] += increment;
        this.performanceBuffer.daily[dayIndex] += increment;
        this.performanceBuffer.weekly[weekIndex % 52] += increment;
    }
    /**
   * Start performance trend tracking
   */ startPerformanceTrendTracking() {
        // Reset hourly buffer every hour
        setInterval(()=>{
            const hourIndex = new Date().getHours();
            this.performanceBuffer.hourly[hourIndex] = 0;
        }, 60 * 60 * 1000);
        // Reset daily buffer every day
        setInterval(()=>{
            const dayIndex = new Date().getDate() - 1;
            this.performanceBuffer.daily[dayIndex] = 0;
        }, 24 * 60 * 60 * 1000);
    }
    /**
   * Start automatic cleanup of old data
   */ startAutomaticCleanup() {
        // Clean up old task logs every 6 hours
        setInterval(()=>{
            this.cleanupOldTaskLogs();
        }, 6 * 60 * 60 * 1000);
    }
    /**
   * Clean up old task logs to prevent memory overflow
   */ cleanupOldTaskLogs() {
        const cutoffDate = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000); // 7 days ago
        const logsToDelete = [];
        for (const [id, log] of this.taskLogs.entries()){
            if (log.createdAt < cutoffDate) {
                logsToDelete.push(id);
            }
        }
        // Keep only recent logs if we're over the limit
        if (this.taskLogs.size > this.MAX_TASK_LOGS) {
            const sortedLogs = Array.from(this.taskLogs.entries()).sort(([, a], [, b])=>b.createdAt.getTime() - a.createdAt.getTime());
            const toDelete = sortedLogs.slice(this.MAX_TASK_LOGS);
            toDelete.forEach(([id])=>logsToDelete.push(id));
        }
        // Delete old logs
        logsToDelete.forEach((id)=>{
            this.taskLogs.delete(id);
            this.rollbackCapabilities.delete(id);
        });
        if (logsToDelete.length > 0) {
            _logger.logger.info('Cleaned up old task logs', {
                deletedCount: logsToDelete.length,
                remainingCount: this.taskLogs.size
            });
        }
    }
    /**
   * Persist task log to database
   */ async persistTaskLog(taskLog) {
        try {
            await _prisma.default.taskExecution.upsert({
                where: {
                    id: taskLog.id
                },
                update: {
                    status: taskLog.status,
                    executionTime: taskLog.executionTime,
                    result: taskLog.result,
                    warnings: taskLog.warnings,
                    errors: taskLog.errors,
                    auditTrail: taskLog.auditTrail,
                    rollbackData: taskLog.rollbackData,
                    rollbackPerformed: taskLog.rollbackPerformed,
                    rollbackReason: taskLog.rollbackReason,
                    completedAt: taskLog.completedAt
                },
                create: {
                    id: taskLog.id,
                    taskId: taskLog.taskId,
                    userId: taskLog.userId,
                    taskType: taskLog.taskType,
                    description: taskLog.description,
                    status: taskLog.status,
                    riskLevel: taskLog.riskLevel,
                    executionTime: taskLog.executionTime,
                    parameters: taskLog.parameters,
                    result: taskLog.result,
                    warnings: taskLog.warnings,
                    errors: taskLog.errors,
                    auditTrail: taskLog.auditTrail,
                    rollbackData: taskLog.rollbackData,
                    rollbackPerformed: taskLog.rollbackPerformed,
                    rollbackReason: taskLog.rollbackReason,
                    approvalId: taskLog.approvalId,
                    createdAt: taskLog.createdAt,
                    completedAt: taskLog.completedAt
                }
            });
        } catch (error) {
            _logger.logger.warn('Failed to persist task log to database', {
                executionId: taskLog.id,
                error: error instanceof Error ? error.message : String(error)
            });
        }
    }
    /**
   * Get overall system metrics
   */ getOverallMetrics() {
        const result = {};
        for (const taskType of this.metrics.keys()){
            result[taskType] = this.getMetrics(taskType);
        }
        return result;
    }
    /**
   * Get health status of task execution system
   */ getHealthStatus() {
        const overall = this.getOverallMetrics();
        const issues = [];
        const recommendations = [];
        let totalAttempts = 0;
        let totalSuccessful = 0;
        for (const [taskType, metrics] of Object.entries(overall)){
            totalAttempts += metrics.totalAttempts;
            totalSuccessful += metrics.successfulExecutions;
            // Check for issues
            if (metrics.successRate < 70 && metrics.totalAttempts > 10) {
                issues.push(`Low success rate for ${taskType}: ${metrics.successRate.toFixed(1)}%`);
                recommendations.push(`Review ${taskType} implementation and error handling`);
            }
            if (metrics.avgExecutionTime > 5000) {
                issues.push(`Slow execution for ${taskType}: ${metrics.avgExecutionTime.toFixed(0)}ms`);
                recommendations.push(`Optimize ${taskType} performance`);
            }
        }
        const overallSuccessRate = totalAttempts > 0 ? totalSuccessful / totalAttempts * 100 : 100;
        let status = 'healthy';
        if (overallSuccessRate < 50) {
            status = 'critical';
        } else if (overallSuccessRate < 80 || issues.length > 2) {
            status = 'warning';
        }
        return {
            status,
            issues,
            recommendations
        };
    }
    /**
   * Persist metrics to database for long-term storage
   */ async persistMetrics(event) {
        try {
            await _prisma.default.userActivity.create({
                data: {
                    userId: event.userId,
                    type: 'ai_task_execution',
                    channel: 'AI',
                    timestamp: event.timestamp,
                    metadata: {
                        taskType: event.taskType,
                        userRole: event.userRole,
                        success: event.success,
                        executionTime: event.executionTime,
                        errorType: event.errorType,
                        errorMessage: event.errorMessage
                    }
                }
            });
        } catch (error) {
            // Don't throw - this is just for metrics collection
            _logger.logger.warn('Failed to persist task execution metrics to database', {
                error: error instanceof Error ? error.message : String(error)
            });
        }
    }
    /**
   * Clear old metrics (for memory management)
   */ clearOldMetrics(olderThanHours = 24) {
        const cutoff = new Date(Date.now() - olderThanHours * 60 * 60 * 1000);
        for (const [taskType, events] of this.metrics.entries()){
            const filtered = events.filter((e)=>e.timestamp > cutoff);
            this.metrics.set(taskType, filtered);
        }
        _logger.logger.info('Cleared old task execution metrics', {
            cutoffHours: olderThanHours,
            remainingTaskTypes: this.metrics.size
        });
    }
}
const taskExecutionMonitor = new TaskExecutionMonitor();
function recordTaskExecution(taskType, userId, userRole, success, executionTime, errorType, errorMessage) {
    taskExecutionMonitor.recordExecution({
        taskType,
        userId,
        userRole,
        success,
        executionTime,
        errorType,
        errorMessage,
        timestamp: new Date()
    });
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdXByZW1lL0Rlc2t0b3AvbWFya2V0c2FnZS9zcmMvbGliL2FpL3Rhc2stZXhlY3V0aW9uLW1vbml0b3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUYXNrIEV4ZWN1dGlvbiBNb25pdG9yaW5nIC0gRW5oYW5jZWQgUHJvZHVjdGlvbiBWZXJzaW9uXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXByZWhlbnNpdmUgbW9uaXRvcmluZywgYXVkaXQgbG9nZ2luZywgcm9sbGJhY2sgY2FwYWJpbGl0aWVzLCBhbmQgcGVyZm9ybWFuY2UgYW5hbHl0aWNzXG4gKiBmb3IgQUkgdGFzayBleGVjdXRpb24gc3lzdGVtIHdpdGggZW50ZXJwcmlzZS1ncmFkZSBzZWN1cml0eSBhbmQgY29tcGxpYW5jZSBmZWF0dXJlcy5cbiAqL1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICdAL2xpYi9sb2dnZXInO1xuaW1wb3J0IHByaXNtYSBmcm9tICdAL2xpYi9kYi9wcmlzbWEnO1xuXG5pbnRlcmZhY2UgVGFza0V4ZWN1dGlvbk1ldHJpY3Mge1xuICB0b3RhbEF0dGVtcHRzOiBudW1iZXI7XG4gIHN1Y2Nlc3NmdWxFeGVjdXRpb25zOiBudW1iZXI7XG4gIGZhaWxlZEV4ZWN1dGlvbnM6IG51bWJlcjtcbiAgc3VjY2Vzc1JhdGU6IG51bWJlcjtcbiAgYXZnRXhlY3V0aW9uVGltZTogbnVtYmVyO1xuICBjb21tb25FcnJvcnM6IHN0cmluZ1tdO1xuICB1c2VyUm9sZVN0YXRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+O1xuICByb2xsYmFja1JhdGU6IG51bWJlcjtcbiAgYXBwcm92YWxSZXF1aXJlZFJhdGU6IG51bWJlcjtcbiAgcmlza0Rpc3RyaWJ1dGlvbjogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcbiAgcGVyZm9ybWFuY2VUcmVuZHM6IHtcbiAgICBob3VybHk6IG51bWJlcltdO1xuICAgIGRhaWx5OiBudW1iZXJbXTtcbiAgICB3ZWVrbHk6IG51bWJlcltdO1xuICB9O1xufVxuXG5pbnRlcmZhY2UgVGFza0V4ZWN1dGlvbkV2ZW50IHtcbiAgdGFza1R5cGU6IHN0cmluZztcbiAgdXNlcklkOiBzdHJpbmc7XG4gIHVzZXJSb2xlOiBzdHJpbmc7XG4gIHN1Y2Nlc3M6IGJvb2xlYW47XG4gIGV4ZWN1dGlvblRpbWU6IG51bWJlcjtcbiAgZXJyb3JUeXBlPzogc3RyaW5nO1xuICBlcnJvck1lc3NhZ2U/OiBzdHJpbmc7XG4gIHRpbWVzdGFtcDogRGF0ZTtcbiAgcmlza0xldmVsPzogJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJyB8ICdjcml0aWNhbCc7XG4gIGFwcHJvdmFsUmVxdWlyZWQ/OiBib29sZWFuO1xuICBhcHByb3ZhbElkPzogc3RyaW5nO1xuICByb2xsYmFja1BlcmZvcm1lZD86IGJvb2xlYW47XG4gIHJvbGxiYWNrUmVhc29uPzogc3RyaW5nO1xuICBwYXJhbWV0ZXJzPzogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgcmVzdWx0PzogYW55O1xuICBhdWRpdFRyYWlsPzogc3RyaW5nW107XG59XG5cbmludGVyZmFjZSBDb21wcmVoZW5zaXZlVGFza0xvZyB7XG4gIGlkOiBzdHJpbmc7XG4gIHRhc2tJZDogc3RyaW5nO1xuICB1c2VySWQ6IHN0cmluZztcbiAgdXNlclJvbGU6IHN0cmluZztcbiAgdGFza1R5cGU6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgc3RhdHVzOiAncGVuZGluZycgfCAncnVubmluZycgfCAnY29tcGxldGVkJyB8ICdmYWlsZWQnIHwgJ2FwcHJvdmFsX3JlcXVpcmVkJyB8ICdyb2xsZWRfYmFjayc7XG4gIHJpc2tMZXZlbDogJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJyB8ICdjcml0aWNhbCc7XG4gIGV4ZWN1dGlvblRpbWU6IG51bWJlcjtcbiAgcGFyYW1ldGVyczogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgcmVzdWx0OiBhbnk7XG4gIHdhcm5pbmdzOiBzdHJpbmdbXTtcbiAgZXJyb3JzOiBzdHJpbmdbXTtcbiAgYXVkaXRUcmFpbDogc3RyaW5nW107XG4gIHJvbGxiYWNrRGF0YT86IGFueTtcbiAgcm9sbGJhY2tQZXJmb3JtZWQ/OiBib29sZWFuO1xuICByb2xsYmFja1JlYXNvbj86IHN0cmluZztcbiAgYXBwcm92YWxJZD86IHN0cmluZztcbiAgYXBwcm92YWxSZXF1aXJlZDogYm9vbGVhbjtcbiAgY3JlYXRlZEF0OiBEYXRlO1xuICBjb21wbGV0ZWRBdD86IERhdGU7XG4gIHNlY3VyaXR5Q29udGV4dDoge1xuICAgIGlwQWRkcmVzcz86IHN0cmluZztcbiAgICB1c2VyQWdlbnQ/OiBzdHJpbmc7XG4gICAgc2Vzc2lvbklkPzogc3RyaW5nO1xuICAgIHBlcm1pc3Npb25zOiBzdHJpbmdbXTtcbiAgfTtcbn1cblxuaW50ZXJmYWNlIFJvbGxiYWNrQ2FwYWJpbGl0eSB7XG4gIGF2YWlsYWJsZTogYm9vbGVhbjtcbiAgc3RyYXRlZ3k6ICdhdXRvbWF0aWMnIHwgJ21hbnVhbCcgfCAnaW1wb3NzaWJsZSc7XG4gIHN0ZXBzOiBzdHJpbmdbXTtcbiAgdGltZUxpbWl0OiBudW1iZXI7XG4gIGRlcGVuZGVuY2llczogc3RyaW5nW107XG4gIHJvbGxiYWNrRGF0YT86IGFueTtcbn1cblxuY2xhc3MgVGFza0V4ZWN1dGlvbk1vbml0b3Ige1xuICBwcml2YXRlIG1ldHJpY3M6IE1hcDxzdHJpbmcsIFRhc2tFeGVjdXRpb25FdmVudFtdPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSB0YXNrTG9nczogTWFwPHN0cmluZywgQ29tcHJlaGVuc2l2ZVRhc2tMb2c+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIHJvbGxiYWNrQ2FwYWJpbGl0aWVzOiBNYXA8c3RyaW5nLCBSb2xsYmFja0NhcGFiaWxpdHk+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIHJlYWRvbmx5IE1BWF9FVkVOVFNfUEVSX1RZUEUgPSAxMDAwOyAvLyBMaW1pdCBtZW1vcnkgdXNhZ2VcbiAgcHJpdmF0ZSByZWFkb25seSBNQVhfVEFTS19MT0dTID0gNTAwMDsgLy8gTGltaXQgdGFzayBsb2cgc3RvcmFnZVxuICBwcml2YXRlIHBlcmZvcm1hbmNlQnVmZmVyOiB7XG4gICAgaG91cmx5OiBudW1iZXJbXTtcbiAgICBkYWlseTogbnVtYmVyW107XG4gICAgd2Vla2x5OiBudW1iZXJbXTtcbiAgfSA9IHtcbiAgICBob3VybHk6IG5ldyBBcnJheSgyNCkuZmlsbCgwKSxcbiAgICBkYWlseTogbmV3IEFycmF5KDMwKS5maWxsKDApLFxuICAgIHdlZWtseTogbmV3IEFycmF5KDUyKS5maWxsKDApXG4gIH07XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gU3RhcnQgcGVyZm9ybWFuY2UgdHJlbmQgdHJhY2tpbmdcbiAgICB0aGlzLnN0YXJ0UGVyZm9ybWFuY2VUcmVuZFRyYWNraW5nKCk7XG4gICAgXG4gICAgLy8gU3RhcnQgYXV0b21hdGljIGNsZWFudXBcbiAgICB0aGlzLnN0YXJ0QXV0b21hdGljQ2xlYW51cCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGNvbXByZWhlbnNpdmUgdGFzayBleGVjdXRpb24gd2l0aCBmdWxsIGF1ZGl0IGxvZ2dpbmdcbiAgICovXG4gIGFzeW5jIHN0YXJ0VGFza0V4ZWN1dGlvbihcbiAgICB0YXNrSWQ6IHN0cmluZyxcbiAgICB1c2VySWQ6IHN0cmluZyxcbiAgICB1c2VyUm9sZTogc3RyaW5nLFxuICAgIHRhc2tUeXBlOiBzdHJpbmcsXG4gICAgZGVzY3JpcHRpb246IHN0cmluZyxcbiAgICBwYXJhbWV0ZXJzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICAgIHJpc2tMZXZlbDogJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJyB8ICdjcml0aWNhbCcsXG4gICAgc2VjdXJpdHlDb250ZXh0OiB7XG4gICAgICBpcEFkZHJlc3M/OiBzdHJpbmc7XG4gICAgICB1c2VyQWdlbnQ/OiBzdHJpbmc7XG4gICAgICBzZXNzaW9uSWQ/OiBzdHJpbmc7XG4gICAgICBwZXJtaXNzaW9uczogc3RyaW5nW107XG4gICAgfSxcbiAgICBhcHByb3ZhbElkPzogc3RyaW5nXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgZXhlY3V0aW9uSWQgPSBgZXhlY18ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWA7XG4gICAgXG4gICAgY29uc3QgdGFza0xvZzogQ29tcHJlaGVuc2l2ZVRhc2tMb2cgPSB7XG4gICAgICBpZDogZXhlY3V0aW9uSWQsXG4gICAgICB0YXNrSWQsXG4gICAgICB1c2VySWQsXG4gICAgICB1c2VyUm9sZSxcbiAgICAgIHRhc2tUeXBlLFxuICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLnN1YnN0cmluZygwLCA1MDApLFxuICAgICAgc3RhdHVzOiAncnVubmluZycsXG4gICAgICByaXNrTGV2ZWwsXG4gICAgICBleGVjdXRpb25UaW1lOiAwLFxuICAgICAgcGFyYW1ldGVycyxcbiAgICAgIHJlc3VsdDogbnVsbCxcbiAgICAgIHdhcm5pbmdzOiBbXSxcbiAgICAgIGVycm9yczogW10sXG4gICAgICBhdWRpdFRyYWlsOiBbYCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfTogVGFzayBleGVjdXRpb24gc3RhcnRlZGBdLFxuICAgICAgYXBwcm92YWxJZCxcbiAgICAgIGFwcHJvdmFsUmVxdWlyZWQ6ICEhYXBwcm92YWxJZCxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgIHNlY3VyaXR5Q29udGV4dFxuICAgIH07XG5cbiAgICB0aGlzLnRhc2tMb2dzLnNldChleGVjdXRpb25JZCwgdGFza0xvZyk7XG4gICAgXG4gICAgLy8gVXBkYXRlIHBlcmZvcm1hbmNlIHRyZW5kc1xuICAgIHRoaXMudXBkYXRlUGVyZm9ybWFuY2VUcmVuZHMoMSk7XG4gICAgXG4gICAgLy8gUGVyc2lzdCB0byBkYXRhYmFzZVxuICAgIGF3YWl0IHRoaXMucGVyc2lzdFRhc2tMb2codGFza0xvZyk7XG5cbiAgICBsb2dnZXIuaW5mbygnVGFzayBleGVjdXRpb24gc3RhcnRlZCB3aXRoIGNvbXByZWhlbnNpdmUgbG9nZ2luZycsIHtcbiAgICAgIGV4ZWN1dGlvbklkLFxuICAgICAgdGFza0lkLFxuICAgICAgdXNlcklkLFxuICAgICAgdGFza1R5cGUsXG4gICAgICByaXNrTGV2ZWwsXG4gICAgICBhcHByb3ZhbFJlcXVpcmVkOiAhIWFwcHJvdmFsSWRcbiAgICB9KTtcblxuICAgIHJldHVybiBleGVjdXRpb25JZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvcmQgYSB0YXNrIGV4ZWN1dGlvbiBhdHRlbXB0IChlbmhhbmNlZCB2ZXJzaW9uKVxuICAgKi9cbiAgcmVjb3JkRXhlY3V0aW9uKGV2ZW50OiBUYXNrRXhlY3V0aW9uRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLm1ldHJpY3MuZ2V0KGV2ZW50LnRhc2tUeXBlKSB8fCBbXTtcbiAgICBldmVudHMucHVzaChldmVudCk7XG5cbiAgICAvLyBLZWVwIG9ubHkgcmVjZW50IGV2ZW50cyB0byBwcmV2ZW50IG1lbW9yeSBvdmVyZmxvd1xuICAgIGlmIChldmVudHMubGVuZ3RoID4gdGhpcy5NQVhfRVZFTlRTX1BFUl9UWVBFKSB7XG4gICAgICBldmVudHMuc3BsaWNlKDAsIGV2ZW50cy5sZW5ndGggLSB0aGlzLk1BWF9FVkVOVFNfUEVSX1RZUEUpO1xuICAgIH1cblxuICAgIHRoaXMubWV0cmljcy5zZXQoZXZlbnQudGFza1R5cGUsIGV2ZW50cyk7XG5cbiAgICAvLyBMb2cgdGhlIGV2ZW50IHdpdGggZW5oYW5jZWQgZGV0YWlsc1xuICAgIGxvZ2dlci5pbmZvKCdUYXNrIGV4ZWN1dGlvbiByZWNvcmRlZCcsIHtcbiAgICAgIHRhc2tUeXBlOiBldmVudC50YXNrVHlwZSxcbiAgICAgIHVzZXJJZDogZXZlbnQudXNlcklkLFxuICAgICAgdXNlclJvbGU6IGV2ZW50LnVzZXJSb2xlLFxuICAgICAgc3VjY2VzczogZXZlbnQuc3VjY2VzcyxcbiAgICAgIGV4ZWN1dGlvblRpbWU6IGV2ZW50LmV4ZWN1dGlvblRpbWUsXG4gICAgICBlcnJvclR5cGU6IGV2ZW50LmVycm9yVHlwZSxcbiAgICAgIHJpc2tMZXZlbDogZXZlbnQucmlza0xldmVsLFxuICAgICAgYXBwcm92YWxSZXF1aXJlZDogZXZlbnQuYXBwcm92YWxSZXF1aXJlZCxcbiAgICAgIHJvbGxiYWNrUGVyZm9ybWVkOiBldmVudC5yb2xsYmFja1BlcmZvcm1lZCxcbiAgICAgIHRpbWVzdGFtcDogZXZlbnQudGltZXN0YW1wXG4gICAgfSk7XG5cbiAgICAvLyBTdG9yZSBtZXRyaWNzIGluIGRhdGFiYXNlIGZvciBwZXJzaXN0ZW5jZSAoYXN5bmMsIGRvbid0IHdhaXQpXG4gICAgdGhpcy5wZXJzaXN0TWV0cmljcyhldmVudCkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgbG9nZ2VyLndhcm4oJ0ZhaWxlZCB0byBwZXJzaXN0IHRhc2sgZXhlY3V0aW9uIG1ldHJpY3MnLCB7IGVycm9yOiBlcnJvci5tZXNzYWdlIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBsZXRlIHRhc2sgZXhlY3V0aW9uIHdpdGggY29tcHJlaGVuc2l2ZSBsb2dnaW5nXG4gICAqL1xuICBhc3luYyBjb21wbGV0ZVRhc2tFeGVjdXRpb24oXG4gICAgZXhlY3V0aW9uSWQ6IHN0cmluZyxcbiAgICByZXN1bHQ6IGFueSxcbiAgICB3YXJuaW5nczogc3RyaW5nW10gPSBbXSxcbiAgICByb2xsYmFja0RhdGE/OiBhbnlcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgdGFza0xvZyA9IHRoaXMudGFza0xvZ3MuZ2V0KGV4ZWN1dGlvbklkKTtcbiAgICBpZiAoIXRhc2tMb2cpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignVGFzayBsb2cgbm90IGZvdW5kIGZvciBjb21wbGV0aW9uJywgeyBleGVjdXRpb25JZCB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBleGVjdXRpb25UaW1lID0gRGF0ZS5ub3coKSAtIHRhc2tMb2cuY3JlYXRlZEF0LmdldFRpbWUoKTtcbiAgICBcbiAgICB0YXNrTG9nLnN0YXR1cyA9ICdjb21wbGV0ZWQnO1xuICAgIHRhc2tMb2cuZXhlY3V0aW9uVGltZSA9IGV4ZWN1dGlvblRpbWU7XG4gICAgdGFza0xvZy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgdGFza0xvZy53YXJuaW5ncyA9IHdhcm5pbmdzO1xuICAgIHRhc2tMb2cucm9sbGJhY2tEYXRhID0gcm9sbGJhY2tEYXRhO1xuICAgIHRhc2tMb2cuY29tcGxldGVkQXQgPSBuZXcgRGF0ZSgpO1xuICAgIFxuICAgIHRhc2tMb2cuYXVkaXRUcmFpbC5wdXNoKGAke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX06IFRhc2sgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSBpbiAke2V4ZWN1dGlvblRpbWV9bXNgKTtcbiAgICBcbiAgICBpZiAod2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgdGFza0xvZy5hdWRpdFRyYWlsLnB1c2goYCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfTogJHt3YXJuaW5ncy5sZW5ndGh9IHdhcm5pbmdzIGdlbmVyYXRlZGApO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSByb2xsYmFjayBjYXBhYmlsaXR5IGlmIGRhdGEgaXMgYXZhaWxhYmxlXG4gICAgaWYgKHJvbGxiYWNrRGF0YSkge1xuICAgICAgdGhpcy5jcmVhdGVSb2xsYmFja0NhcGFiaWxpdHkoZXhlY3V0aW9uSWQsIHJvbGxiYWNrRGF0YSwgdGFza0xvZyk7XG4gICAgfVxuXG4gICAgLy8gUmVjb3JkIGV4ZWN1dGlvbiBldmVudFxuICAgIHRoaXMucmVjb3JkRXhlY3V0aW9uKHtcbiAgICAgIHRhc2tUeXBlOiB0YXNrTG9nLnRhc2tUeXBlLFxuICAgICAgdXNlcklkOiB0YXNrTG9nLnVzZXJJZCxcbiAgICAgIHVzZXJSb2xlOiB0YXNrTG9nLnVzZXJSb2xlLFxuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIGV4ZWN1dGlvblRpbWUsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICByaXNrTGV2ZWw6IHRhc2tMb2cucmlza0xldmVsLFxuICAgICAgYXBwcm92YWxSZXF1aXJlZDogdGFza0xvZy5hcHByb3ZhbFJlcXVpcmVkLFxuICAgICAgcGFyYW1ldGVyczogdGFza0xvZy5wYXJhbWV0ZXJzLFxuICAgICAgcmVzdWx0LFxuICAgICAgYXVkaXRUcmFpbDogdGFza0xvZy5hdWRpdFRyYWlsXG4gICAgfSk7XG5cbiAgICAvLyBVcGRhdGUgZGF0YWJhc2VcbiAgICBhd2FpdCB0aGlzLnBlcnNpc3RUYXNrTG9nKHRhc2tMb2cpO1xuXG4gICAgbG9nZ2VyLmluZm8oJ1Rhc2sgZXhlY3V0aW9uIGNvbXBsZXRlZCcsIHtcbiAgICAgIGV4ZWN1dGlvbklkLFxuICAgICAgdGFza0lkOiB0YXNrTG9nLnRhc2tJZCxcbiAgICAgIGV4ZWN1dGlvblRpbWUsXG4gICAgICB3YXJuaW5nczogd2FybmluZ3MubGVuZ3RoLFxuICAgICAgcm9sbGJhY2tBdmFpbGFibGU6ICEhcm9sbGJhY2tEYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmFpbCB0YXNrIGV4ZWN1dGlvbiB3aXRoIGNvbXByZWhlbnNpdmUgbG9nZ2luZ1xuICAgKi9cbiAgYXN5bmMgZmFpbFRhc2tFeGVjdXRpb24oXG4gICAgZXhlY3V0aW9uSWQ6IHN0cmluZyxcbiAgICBlcnJvclR5cGU6IHN0cmluZyxcbiAgICBlcnJvck1lc3NhZ2U6IHN0cmluZyxcbiAgICByb2xsYmFja0RhdGE/OiBhbnlcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgdGFza0xvZyA9IHRoaXMudGFza0xvZ3MuZ2V0KGV4ZWN1dGlvbklkKTtcbiAgICBpZiAoIXRhc2tMb2cpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignVGFzayBsb2cgbm90IGZvdW5kIGZvciBmYWlsdXJlJywgeyBleGVjdXRpb25JZCB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBleGVjdXRpb25UaW1lID0gRGF0ZS5ub3coKSAtIHRhc2tMb2cuY3JlYXRlZEF0LmdldFRpbWUoKTtcbiAgICBcbiAgICB0YXNrTG9nLnN0YXR1cyA9ICdmYWlsZWQnO1xuICAgIHRhc2tMb2cuZXhlY3V0aW9uVGltZSA9IGV4ZWN1dGlvblRpbWU7XG4gICAgdGFza0xvZy5lcnJvcnMucHVzaChlcnJvck1lc3NhZ2UpO1xuICAgIHRhc2tMb2cucm9sbGJhY2tEYXRhID0gcm9sbGJhY2tEYXRhO1xuICAgIHRhc2tMb2cuY29tcGxldGVkQXQgPSBuZXcgRGF0ZSgpO1xuICAgIFxuICAgIHRhc2tMb2cuYXVkaXRUcmFpbC5wdXNoKGAke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX06IFRhc2sgZmFpbGVkIGFmdGVyICR7ZXhlY3V0aW9uVGltZX1tc2ApO1xuICAgIHRhc2tMb2cuYXVkaXRUcmFpbC5wdXNoKGAke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX06IEVycm9yIC0gJHtlcnJvclR5cGV9OiAke2Vycm9yTWVzc2FnZX1gKTtcblxuICAgIC8vIENyZWF0ZSByb2xsYmFjayBjYXBhYmlsaXR5IGlmIGRhdGEgaXMgYXZhaWxhYmxlXG4gICAgaWYgKHJvbGxiYWNrRGF0YSkge1xuICAgICAgdGhpcy5jcmVhdGVSb2xsYmFja0NhcGFiaWxpdHkoZXhlY3V0aW9uSWQsIHJvbGxiYWNrRGF0YSwgdGFza0xvZyk7XG4gICAgfVxuXG4gICAgLy8gUmVjb3JkIGV4ZWN1dGlvbiBldmVudFxuICAgIHRoaXMucmVjb3JkRXhlY3V0aW9uKHtcbiAgICAgIHRhc2tUeXBlOiB0YXNrTG9nLnRhc2tUeXBlLFxuICAgICAgdXNlcklkOiB0YXNrTG9nLnVzZXJJZCxcbiAgICAgIHVzZXJSb2xlOiB0YXNrTG9nLnVzZXJSb2xlLFxuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBleGVjdXRpb25UaW1lLFxuICAgICAgZXJyb3JUeXBlLFxuICAgICAgZXJyb3JNZXNzYWdlLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgcmlza0xldmVsOiB0YXNrTG9nLnJpc2tMZXZlbCxcbiAgICAgIGFwcHJvdmFsUmVxdWlyZWQ6IHRhc2tMb2cuYXBwcm92YWxSZXF1aXJlZCxcbiAgICAgIHBhcmFtZXRlcnM6IHRhc2tMb2cucGFyYW1ldGVycyxcbiAgICAgIGF1ZGl0VHJhaWw6IHRhc2tMb2cuYXVkaXRUcmFpbFxuICAgIH0pO1xuXG4gICAgLy8gVXBkYXRlIGRhdGFiYXNlXG4gICAgYXdhaXQgdGhpcy5wZXJzaXN0VGFza0xvZyh0YXNrTG9nKTtcblxuICAgIGxvZ2dlci5lcnJvcignVGFzayBleGVjdXRpb24gZmFpbGVkJywge1xuICAgICAgZXhlY3V0aW9uSWQsXG4gICAgICB0YXNrSWQ6IHRhc2tMb2cudGFza0lkLFxuICAgICAgZXhlY3V0aW9uVGltZSxcbiAgICAgIGVycm9yVHlwZSxcbiAgICAgIGVycm9yTWVzc2FnZSxcbiAgICAgIHJvbGxiYWNrQXZhaWxhYmxlOiAhIXJvbGxiYWNrRGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gdGFzayByb2xsYmFjayB3aXRoIGNvbXByZWhlbnNpdmUgbG9nZ2luZ1xuICAgKi9cbiAgYXN5bmMgcGVyZm9ybVJvbGxiYWNrKFxuICAgIGV4ZWN1dGlvbklkOiBzdHJpbmcsXG4gICAgcm9sbGJhY2tSZWFzb246IHN0cmluZyxcbiAgICByb2xsYmFja1VzZXJJZDogc3RyaW5nXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IHRhc2tMb2cgPSB0aGlzLnRhc2tMb2dzLmdldChleGVjdXRpb25JZCk7XG4gICAgY29uc3Qgcm9sbGJhY2tDYXBhYmlsaXR5ID0gdGhpcy5yb2xsYmFja0NhcGFiaWxpdGllcy5nZXQoZXhlY3V0aW9uSWQpO1xuICAgIFxuICAgIGlmICghdGFza0xvZyB8fCAhcm9sbGJhY2tDYXBhYmlsaXR5IHx8ICFyb2xsYmFja0NhcGFiaWxpdHkuYXZhaWxhYmxlKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ1JvbGxiYWNrIG5vdCBhdmFpbGFibGUnLCB7IGV4ZWN1dGlvbklkLCB0YXNrTG9nOiAhIXRhc2tMb2csIHJvbGxiYWNrQ2FwYWJpbGl0eTogISFyb2xsYmFja0NhcGFiaWxpdHkgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRhc2tMb2cuYXVkaXRUcmFpbC5wdXNoKGAke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX06IFJvbGxiYWNrIGluaXRpYXRlZCBieSB1c2VyICR7cm9sbGJhY2tVc2VySWR9YCk7XG4gICAgICB0YXNrTG9nLmF1ZGl0VHJhaWwucHVzaChgJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9OiBSb2xsYmFjayByZWFzb246ICR7cm9sbGJhY2tSZWFzb259YCk7XG4gICAgICBcbiAgICAgIC8vIEV4ZWN1dGUgcm9sbGJhY2sgc3RlcHNcbiAgICAgIGlmIChyb2xsYmFja0NhcGFiaWxpdHkuc3RyYXRlZ3kgPT09ICdhdXRvbWF0aWMnKSB7XG4gICAgICAgIHRhc2tMb2cuYXVkaXRUcmFpbC5wdXNoKGAke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX06IEV4ZWN1dGluZyBhdXRvbWF0aWMgcm9sbGJhY2tgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQgZXhlY3V0ZSBhY3R1YWwgcm9sbGJhY2sgb3BlcmF0aW9uc1xuICAgICAgICBmb3IgKGNvbnN0IHN0ZXAgb2Ygcm9sbGJhY2tDYXBhYmlsaXR5LnN0ZXBzKSB7XG4gICAgICAgICAgdGFza0xvZy5hdWRpdFRyYWlsLnB1c2goYCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfTogUm9sbGJhY2sgc3RlcDogJHtzdGVwfWApO1xuICAgICAgICAgIC8vIFNpbXVsYXRlIHJvbGxiYWNrIHN0ZXAgZXhlY3V0aW9uXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXNrTG9nLmF1ZGl0VHJhaWwucHVzaChgJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9OiBNYW51YWwgcm9sbGJhY2sgcHJvY2VkdXJlIGluaXRpYXRlZGApO1xuICAgICAgfVxuXG4gICAgICB0YXNrTG9nLnN0YXR1cyA9ICdyb2xsZWRfYmFjayc7XG4gICAgICB0YXNrTG9nLnJvbGxiYWNrUGVyZm9ybWVkID0gdHJ1ZTtcbiAgICAgIHRhc2tMb2cucm9sbGJhY2tSZWFzb24gPSByb2xsYmFja1JlYXNvbjtcbiAgICAgIHRhc2tMb2cuYXVkaXRUcmFpbC5wdXNoKGAke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX06IFJvbGxiYWNrIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHlgKTtcblxuICAgICAgLy8gUmVjb3JkIHJvbGxiYWNrIGV2ZW50XG4gICAgICB0aGlzLnJlY29yZEV4ZWN1dGlvbih7XG4gICAgICAgIHRhc2tUeXBlOiB0YXNrTG9nLnRhc2tUeXBlLFxuICAgICAgICB1c2VySWQ6IHRhc2tMb2cudXNlcklkLFxuICAgICAgICB1c2VyUm9sZTogdGFza0xvZy51c2VyUm9sZSxcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZXhlY3V0aW9uVGltZTogdGFza0xvZy5leGVjdXRpb25UaW1lLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgIHJpc2tMZXZlbDogdGFza0xvZy5yaXNrTGV2ZWwsXG4gICAgICAgIHJvbGxiYWNrUGVyZm9ybWVkOiB0cnVlLFxuICAgICAgICByb2xsYmFja1JlYXNvbixcbiAgICAgICAgYXVkaXRUcmFpbDogdGFza0xvZy5hdWRpdFRyYWlsXG4gICAgICB9KTtcblxuICAgICAgLy8gVXBkYXRlIGRhdGFiYXNlXG4gICAgICBhd2FpdCB0aGlzLnBlcnNpc3RUYXNrTG9nKHRhc2tMb2cpO1xuXG4gICAgICBsb2dnZXIuaW5mbygnVGFzayByb2xsYmFjayBjb21wbGV0ZWQnLCB7XG4gICAgICAgIGV4ZWN1dGlvbklkLFxuICAgICAgICB0YXNrSWQ6IHRhc2tMb2cudGFza0lkLFxuICAgICAgICByb2xsYmFja1JlYXNvbixcbiAgICAgICAgcm9sbGJhY2tVc2VySWRcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcic7XG4gICAgICB0YXNrTG9nLmF1ZGl0VHJhaWwucHVzaChgJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9OiBSb2xsYmFjayBmYWlsZWQ6ICR7ZXJyb3JNZXNzYWdlfWApO1xuICAgICAgdGFza0xvZy5lcnJvcnMucHVzaChgUm9sbGJhY2sgZmFpbGVkOiAke2Vycm9yTWVzc2FnZX1gKTtcbiAgICAgIFxuICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0VGFza0xvZyh0YXNrTG9nKTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmVycm9yKCdUYXNrIHJvbGxiYWNrIGZhaWxlZCcsIHsgZXhlY3V0aW9uSWQsIGVycm9yOiBlcnJvck1lc3NhZ2UgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBlbmhhbmNlZCBtZXRyaWNzIGZvciBhIHNwZWNpZmljIHRhc2sgdHlwZVxuICAgKi9cbiAgZ2V0TWV0cmljcyh0YXNrVHlwZTogc3RyaW5nKTogVGFza0V4ZWN1dGlvbk1ldHJpY3Mge1xuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMubWV0cmljcy5nZXQodGFza1R5cGUpIHx8IFtdO1xuICAgIFxuICAgIGlmIChldmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3RhbEF0dGVtcHRzOiAwLFxuICAgICAgICBzdWNjZXNzZnVsRXhlY3V0aW9uczogMCxcbiAgICAgICAgZmFpbGVkRXhlY3V0aW9uczogMCxcbiAgICAgICAgc3VjY2Vzc1JhdGU6IDAsXG4gICAgICAgIGF2Z0V4ZWN1dGlvblRpbWU6IDAsXG4gICAgICAgIGNvbW1vbkVycm9yczogW10sXG4gICAgICAgIHVzZXJSb2xlU3RhdHM6IHt9LFxuICAgICAgICByb2xsYmFja1JhdGU6IDAsXG4gICAgICAgIGFwcHJvdmFsUmVxdWlyZWRSYXRlOiAwLFxuICAgICAgICByaXNrRGlzdHJpYnV0aW9uOiB7fSxcbiAgICAgICAgcGVyZm9ybWFuY2VUcmVuZHM6IHtcbiAgICAgICAgICBob3VybHk6IFsuLi50aGlzLnBlcmZvcm1hbmNlQnVmZmVyLmhvdXJseV0sXG4gICAgICAgICAgZGFpbHk6IFsuLi50aGlzLnBlcmZvcm1hbmNlQnVmZmVyLmRhaWx5XSxcbiAgICAgICAgICB3ZWVrbHk6IFsuLi50aGlzLnBlcmZvcm1hbmNlQnVmZmVyLndlZWtseV1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBzdWNjZXNzZnVsID0gZXZlbnRzLmZpbHRlcihlID0+IGUuc3VjY2Vzcyk7XG4gICAgY29uc3QgZmFpbGVkID0gZXZlbnRzLmZpbHRlcihlID0+ICFlLnN1Y2Nlc3MpO1xuICAgIGNvbnN0IHJvbGxlZEJhY2sgPSBldmVudHMuZmlsdGVyKGUgPT4gZS5yb2xsYmFja1BlcmZvcm1lZCk7XG4gICAgY29uc3QgYXBwcm92YWxSZXF1aXJlZCA9IGV2ZW50cy5maWx0ZXIoZSA9PiBlLmFwcHJvdmFsUmVxdWlyZWQpO1xuICAgIGNvbnN0IHRvdGFsVGltZSA9IGV2ZW50cy5yZWR1Y2UoKHN1bSwgZSkgPT4gc3VtICsgZS5leGVjdXRpb25UaW1lLCAwKTtcbiAgICBcbiAgICAvLyBDb3VudCBlcnJvcnNcbiAgICBjb25zdCBlcnJvckNvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICAgIGZhaWxlZC5mb3JFYWNoKGUgPT4ge1xuICAgICAgaWYgKGUuZXJyb3JUeXBlKSB7XG4gICAgICAgIGVycm9yQ291bnRzW2UuZXJyb3JUeXBlXSA9IChlcnJvckNvdW50c1tlLmVycm9yVHlwZV0gfHwgMCkgKyAxO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ291bnQgdXNlciByb2xlIHN0YXRzXG4gICAgY29uc3Qgcm9sZVN0YXRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gICAgZXZlbnRzLmZvckVhY2goZSA9PiB7XG4gICAgICByb2xlU3RhdHNbZS51c2VyUm9sZV0gPSAocm9sZVN0YXRzW2UudXNlclJvbGVdIHx8IDApICsgMTtcbiAgICB9KTtcblxuICAgIC8vIENvdW50IHJpc2sgZGlzdHJpYnV0aW9uXG4gICAgY29uc3Qgcmlza0Rpc3RyaWJ1dGlvbjogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICAgIGV2ZW50cy5mb3JFYWNoKGUgPT4ge1xuICAgICAgaWYgKGUucmlza0xldmVsKSB7XG4gICAgICAgIHJpc2tEaXN0cmlidXRpb25bZS5yaXNrTGV2ZWxdID0gKHJpc2tEaXN0cmlidXRpb25bZS5yaXNrTGV2ZWxdIHx8IDApICsgMTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IGNvbW1vbkVycm9ycyA9IE9iamVjdC5lbnRyaWVzKGVycm9yQ291bnRzKVxuICAgICAgLnNvcnQoKFssYV0sIFssYl0pID0+IGIgLSBhKVxuICAgICAgLnNsaWNlKDAsIDUpXG4gICAgICAubWFwKChbZXJyb3JdKSA9PiBlcnJvcik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG90YWxBdHRlbXB0czogZXZlbnRzLmxlbmd0aCxcbiAgICAgIHN1Y2Nlc3NmdWxFeGVjdXRpb25zOiBzdWNjZXNzZnVsLmxlbmd0aCxcbiAgICAgIGZhaWxlZEV4ZWN1dGlvbnM6IGZhaWxlZC5sZW5ndGgsXG4gICAgICBzdWNjZXNzUmF0ZTogZXZlbnRzLmxlbmd0aCA+IDAgPyAoc3VjY2Vzc2Z1bC5sZW5ndGggLyBldmVudHMubGVuZ3RoKSAqIDEwMCA6IDAsXG4gICAgICBhdmdFeGVjdXRpb25UaW1lOiBldmVudHMubGVuZ3RoID4gMCA/IHRvdGFsVGltZSAvIGV2ZW50cy5sZW5ndGggOiAwLFxuICAgICAgY29tbW9uRXJyb3JzLFxuICAgICAgdXNlclJvbGVTdGF0czogcm9sZVN0YXRzLFxuICAgICAgcm9sbGJhY2tSYXRlOiBldmVudHMubGVuZ3RoID4gMCA/IChyb2xsZWRCYWNrLmxlbmd0aCAvIGV2ZW50cy5sZW5ndGgpICogMTAwIDogMCxcbiAgICAgIGFwcHJvdmFsUmVxdWlyZWRSYXRlOiBldmVudHMubGVuZ3RoID4gMCA/IChhcHByb3ZhbFJlcXVpcmVkLmxlbmd0aCAvIGV2ZW50cy5sZW5ndGgpICogMTAwIDogMCxcbiAgICAgIHJpc2tEaXN0cmlidXRpb24sXG4gICAgICBwZXJmb3JtYW5jZVRyZW5kczoge1xuICAgICAgICBob3VybHk6IFsuLi50aGlzLnBlcmZvcm1hbmNlQnVmZmVyLmhvdXJseV0sXG4gICAgICAgIGRhaWx5OiBbLi4udGhpcy5wZXJmb3JtYW5jZUJ1ZmZlci5kYWlseV0sXG4gICAgICAgIHdlZWtseTogWy4uLnRoaXMucGVyZm9ybWFuY2VCdWZmZXIud2Vla2x5XVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNvbXByZWhlbnNpdmUgdGFzayBsb2cgYnkgZXhlY3V0aW9uIElEXG4gICAqL1xuICBnZXRUYXNrTG9nKGV4ZWN1dGlvbklkOiBzdHJpbmcpOiBDb21wcmVoZW5zaXZlVGFza0xvZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMudGFza0xvZ3MuZ2V0KGV4ZWN1dGlvbklkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGFzayBsb2dzIGZvciBhIHVzZXIgd2l0aCBmaWx0ZXJpbmdcbiAgICovXG4gIGdldFVzZXJUYXNrTG9ncyhcbiAgICB1c2VySWQ6IHN0cmluZywgXG4gICAgc3RhdHVzPzogc3RyaW5nLCBcbiAgICB0YXNrVHlwZT86IHN0cmluZywgXG4gICAgbGltaXQgPSA1MFxuICApOiBDb21wcmVoZW5zaXZlVGFza0xvZ1tdIHtcbiAgICBsZXQgbG9ncyA9IEFycmF5LmZyb20odGhpcy50YXNrTG9ncy52YWx1ZXMoKSlcbiAgICAgIC5maWx0ZXIobG9nID0+IGxvZy51c2VySWQgPT09IHVzZXJJZCk7XG5cbiAgICBpZiAoc3RhdHVzKSB7XG4gICAgICBsb2dzID0gbG9ncy5maWx0ZXIobG9nID0+IGxvZy5zdGF0dXMgPT09IHN0YXR1cyk7XG4gICAgfVxuXG4gICAgaWYgKHRhc2tUeXBlKSB7XG4gICAgICBsb2dzID0gbG9ncy5maWx0ZXIobG9nID0+IGxvZy50YXNrVHlwZSA9PT0gdGFza1R5cGUpO1xuICAgIH1cblxuICAgIHJldHVybiBsb2dzXG4gICAgICAuc29ydCgoYSwgYikgPT4gYi5jcmVhdGVkQXQuZ2V0VGltZSgpIC0gYS5jcmVhdGVkQXQuZ2V0VGltZSgpKVxuICAgICAgLnNsaWNlKDAsIGxpbWl0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcm9sbGJhY2sgY2FwYWJpbGl0eSBmb3IgYSB0YXNrXG4gICAqL1xuICBnZXRSb2xsYmFja0NhcGFiaWxpdHkoZXhlY3V0aW9uSWQ6IHN0cmluZyk6IFJvbGxiYWNrQ2FwYWJpbGl0eSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMucm9sbGJhY2tDYXBhYmlsaXRpZXMuZ2V0KGV4ZWN1dGlvbklkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHRhc2sgbG9ncyB0aGF0IGNhbiBiZSByb2xsZWQgYmFja1xuICAgKi9cbiAgZ2V0Um9sbGJhY2tDYW5kaWRhdGVzKHVzZXJJZD86IHN0cmluZyk6IENvbXByZWhlbnNpdmVUYXNrTG9nW10ge1xuICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBBcnJheS5mcm9tKHRoaXMudGFza0xvZ3MudmFsdWVzKCkpXG4gICAgICAuZmlsdGVyKGxvZyA9PiBcbiAgICAgICAgbG9nLnN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcgJiYgXG4gICAgICAgIGxvZy5yb2xsYmFja0RhdGEgJiYgXG4gICAgICAgICFsb2cucm9sbGJhY2tQZXJmb3JtZWQgJiZcbiAgICAgICAgdGhpcy5yb2xsYmFja0NhcGFiaWxpdGllcy5nZXQobG9nLmlkKT8uYXZhaWxhYmxlXG4gICAgICApO1xuXG4gICAgaWYgKHVzZXJJZCkge1xuICAgICAgcmV0dXJuIGNhbmRpZGF0ZXMuZmlsdGVyKGxvZyA9PiBsb2cudXNlcklkID09PSB1c2VySWQpO1xuICAgIH1cblxuICAgIHJldHVybiBjYW5kaWRhdGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSByb2xsYmFjayBjYXBhYmlsaXR5IGZvciBhIHRhc2tcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlUm9sbGJhY2tDYXBhYmlsaXR5KFxuICAgIGV4ZWN1dGlvbklkOiBzdHJpbmcsIFxuICAgIHJvbGxiYWNrRGF0YTogYW55LCBcbiAgICB0YXNrTG9nOiBDb21wcmVoZW5zaXZlVGFza0xvZ1xuICApOiB2b2lkIHtcbiAgICBjb25zdCBjYXBhYmlsaXR5OiBSb2xsYmFja0NhcGFiaWxpdHkgPSB7XG4gICAgICBhdmFpbGFibGU6IHRydWUsXG4gICAgICBzdHJhdGVneTogdGhpcy5kZXRlcm1pbmVSb2xsYmFja1N0cmF0ZWd5KHRhc2tMb2cudGFza1R5cGUsIHRhc2tMb2cucmlza0xldmVsKSxcbiAgICAgIHN0ZXBzOiB0aGlzLmdlbmVyYXRlUm9sbGJhY2tTdGVwcyh0YXNrTG9nLnRhc2tUeXBlLCByb2xsYmFja0RhdGEpLFxuICAgICAgdGltZUxpbWl0OiB0aGlzLmdldFJvbGxiYWNrVGltZUxpbWl0KHRhc2tMb2cucmlza0xldmVsKSxcbiAgICAgIGRlcGVuZGVuY2llczogdGhpcy5nZXRSb2xsYmFja0RlcGVuZGVuY2llcyh0YXNrTG9nLnRhc2tUeXBlKSxcbiAgICAgIHJvbGxiYWNrRGF0YVxuICAgIH07XG5cbiAgICB0aGlzLnJvbGxiYWNrQ2FwYWJpbGl0aWVzLnNldChleGVjdXRpb25JZCwgY2FwYWJpbGl0eSk7XG4gICAgXG4gICAgLy8gQXV0by1leHBpcmUgcm9sbGJhY2sgY2FwYWJpbGl0eSBhZnRlciB0aW1lIGxpbWl0XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5yb2xsYmFja0NhcGFiaWxpdGllcy5nZXQoZXhlY3V0aW9uSWQpO1xuICAgICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC5hdmFpbGFibGUpIHtcbiAgICAgICAgY3VycmVudC5hdmFpbGFibGUgPSBmYWxzZTtcbiAgICAgICAgdGFza0xvZy5hdWRpdFRyYWlsLnB1c2goYCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfTogUm9sbGJhY2sgY2FwYWJpbGl0eSBleHBpcmVkIGFmdGVyICR7Y2FwYWJpbGl0eS50aW1lTGltaXR9IG1pbnV0ZXNgKTtcbiAgICAgIH1cbiAgICB9LCBjYXBhYmlsaXR5LnRpbWVMaW1pdCAqIDYwICogMTAwMCk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHJvbGxiYWNrIHN0cmF0ZWd5IGJhc2VkIG9uIHRhc2sgdHlwZSBhbmQgcmlzayBsZXZlbFxuICAgKi9cbiAgcHJpdmF0ZSBkZXRlcm1pbmVSb2xsYmFja1N0cmF0ZWd5KFxuICAgIHRhc2tUeXBlOiBzdHJpbmcsIFxuICAgIHJpc2tMZXZlbDogc3RyaW5nXG4gICk6ICdhdXRvbWF0aWMnIHwgJ21hbnVhbCcgfCAnaW1wb3NzaWJsZScge1xuICAgIGlmICh0YXNrVHlwZSA9PT0gJ3JlcG9ydGluZycgfHwgdGFza1R5cGUgPT09ICdkYXRhX2FuYWx5c2lzJykge1xuICAgICAgcmV0dXJuICdpbXBvc3NpYmxlJzsgLy8gUmVhZC1vbmx5IG9wZXJhdGlvbnNcbiAgICB9XG5cbiAgICBpZiAocmlza0xldmVsID09PSAnY3JpdGljYWwnKSB7XG4gICAgICByZXR1cm4gJ21hbnVhbCc7IC8vIEhpZ2gtcmlzayBvcGVyYXRpb25zIHJlcXVpcmUgbWFudWFsIHJvbGxiYWNrXG4gICAgfVxuXG4gICAgcmV0dXJuICdhdXRvbWF0aWMnOyAvLyBEZWZhdWx0IHRvIGF1dG9tYXRpYyByb2xsYmFja1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHJvbGxiYWNrIHN0ZXBzIGZvciBhIHRhc2sgdHlwZVxuICAgKi9cbiAgcHJpdmF0ZSBnZW5lcmF0ZVJvbGxiYWNrU3RlcHModGFza1R5cGU6IHN0cmluZywgcm9sbGJhY2tEYXRhOiBhbnkpOiBzdHJpbmdbXSB7XG4gICAgY29uc3Qgc3RlcHM6IHN0cmluZ1tdID0gW107XG5cbiAgICBzd2l0Y2ggKHRhc2tUeXBlKSB7XG4gICAgICBjYXNlICdzZWdtZW50YXRpb24nOlxuICAgICAgICBzdGVwcy5wdXNoKCdSZW1vdmUgY3JlYXRlZCBjdXN0b21lciBzZWdtZW50cycpO1xuICAgICAgICBzdGVwcy5wdXNoKCdSZXN0b3JlIHByZXZpb3VzIHNlZ21lbnRhdGlvbiBydWxlcycpO1xuICAgICAgICBzdGVwcy5wdXNoKCdVcGRhdGUgY3VzdG9tZXIgc2VnbWVudCBhc3NpZ25tZW50cycpO1xuICAgICAgICBicmVhaztcbiAgICAgIFxuICAgICAgY2FzZSAnY2FtcGFpZ25fb3B0aW1pemF0aW9uJzpcbiAgICAgICAgc3RlcHMucHVzaCgnUmVzdG9yZSBvcmlnaW5hbCBjYW1wYWlnbiBzZXR0aW5ncycpO1xuICAgICAgICBzdGVwcy5wdXNoKCdSZXZlcnQgc2VuZCB0aW1lIG9wdGltaXphdGlvbnMnKTtcbiAgICAgICAgc3RlcHMucHVzaCgnUmVzZXQgQS9CIHRlc3QgY29uZmlndXJhdGlvbnMnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBcbiAgICAgIGNhc2UgJ2ludGVncmF0aW9uX2NvbmZpZyc6XG4gICAgICAgIHN0ZXBzLnB1c2goJ0Rpc2FibGUgbmV3IGludGVncmF0aW9uIGNvbmZpZ3VyYXRpb24nKTtcbiAgICAgICAgc3RlcHMucHVzaCgnUmVzdG9yZSBwcmV2aW91cyBpbnRlZ3JhdGlvbiBzZXR0aW5ncycpO1xuICAgICAgICBzdGVwcy5wdXNoKCdWYWxpZGF0ZSBzeXN0ZW0gY29ubmVjdGl2aXR5Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzdGVwcy5wdXNoKCdSZXN0b3JlIHByZXZpb3VzIHN5c3RlbSBzdGF0ZScpO1xuICAgICAgICBzdGVwcy5wdXNoKCdWZXJpZnkgcm9sbGJhY2sgY29tcGxldGlvbicpO1xuICAgIH1cblxuICAgIHJldHVybiBzdGVwcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcm9sbGJhY2sgdGltZSBsaW1pdCBiYXNlZCBvbiByaXNrIGxldmVsXG4gICAqL1xuICBwcml2YXRlIGdldFJvbGxiYWNrVGltZUxpbWl0KHJpc2tMZXZlbDogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBjb25zdCBsaW1pdHMgPSB7XG4gICAgICBsb3c6IDE0NDAsICAgICAgLy8gMjQgaG91cnNcbiAgICAgIG1lZGl1bTogNzIwLCAgICAvLyAxMiBob3Vyc1xuICAgICAgaGlnaDogMTgwLCAgICAgIC8vIDMgaG91cnNcbiAgICAgIGNyaXRpY2FsOiA2MCAgICAvLyAxIGhvdXJcbiAgICB9O1xuICAgIHJldHVybiBsaW1pdHNbcmlza0xldmVsXSB8fCBsaW1pdHMubWVkaXVtO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCByb2xsYmFjayBkZXBlbmRlbmNpZXMgZm9yIGEgdGFzayB0eXBlXG4gICAqL1xuICBwcml2YXRlIGdldFJvbGxiYWNrRGVwZW5kZW5jaWVzKHRhc2tUeXBlOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4gPSB7XG4gICAgICBzZWdtZW50YXRpb246IFsnY3VzdG9tZXJfZGF0YScsICdzZWdtZW50X3J1bGVzJ10sXG4gICAgICBjYW1wYWlnbl9vcHRpbWl6YXRpb246IFsnY2FtcGFpZ25fc2V0dGluZ3MnLCAnZW1haWxfdGVtcGxhdGVzJ10sXG4gICAgICBpbnRlZ3JhdGlvbl9jb25maWc6IFsnYXBpX2NyZWRlbnRpYWxzJywgJ3dlYmhvb2tfZW5kcG9pbnRzJ10sXG4gICAgICBkYXRhX2FuYWx5c2lzOiBbXSwgLy8gTm8gZGVwZW5kZW5jaWVzIGZvciByZWFkLW9ubHlcbiAgICAgIHJlcG9ydGluZzogW10gLy8gTm8gZGVwZW5kZW5jaWVzIGZvciByZWFkLW9ubHlcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiBkZXBlbmRlbmNpZXNbdGFza1R5cGVdIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBwZXJmb3JtYW5jZSB0cmVuZHNcbiAgICovXG4gIHByaXZhdGUgdXBkYXRlUGVyZm9ybWFuY2VUcmVuZHMoaW5jcmVtZW50OiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IGhvdXJJbmRleCA9IG5vdy5nZXRIb3VycygpO1xuICAgIGNvbnN0IGRheUluZGV4ID0gbm93LmdldERhdGUoKSAtIDE7XG4gICAgY29uc3Qgd2Vla0luZGV4ID0gTWF0aC5mbG9vcigobm93LmdldFRpbWUoKSAtIG5ldyBEYXRlKG5vdy5nZXRGdWxsWWVhcigpLCAwLCAxKS5nZXRUaW1lKCkpIC8gKDcgKiAyNCAqIDYwICogNjAgKiAxMDAwKSk7XG5cbiAgICB0aGlzLnBlcmZvcm1hbmNlQnVmZmVyLmhvdXJseVtob3VySW5kZXhdICs9IGluY3JlbWVudDtcbiAgICB0aGlzLnBlcmZvcm1hbmNlQnVmZmVyLmRhaWx5W2RheUluZGV4XSArPSBpbmNyZW1lbnQ7XG4gICAgdGhpcy5wZXJmb3JtYW5jZUJ1ZmZlci53ZWVrbHlbd2Vla0luZGV4ICUgNTJdICs9IGluY3JlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBwZXJmb3JtYW5jZSB0cmVuZCB0cmFja2luZ1xuICAgKi9cbiAgcHJpdmF0ZSBzdGFydFBlcmZvcm1hbmNlVHJlbmRUcmFja2luZygpOiB2b2lkIHtcbiAgICAvLyBSZXNldCBob3VybHkgYnVmZmVyIGV2ZXJ5IGhvdXJcbiAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBob3VySW5kZXggPSBuZXcgRGF0ZSgpLmdldEhvdXJzKCk7XG4gICAgICB0aGlzLnBlcmZvcm1hbmNlQnVmZmVyLmhvdXJseVtob3VySW5kZXhdID0gMDtcbiAgICB9LCA2MCAqIDYwICogMTAwMCk7XG5cbiAgICAvLyBSZXNldCBkYWlseSBidWZmZXIgZXZlcnkgZGF5XG4gICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgY29uc3QgZGF5SW5kZXggPSBuZXcgRGF0ZSgpLmdldERhdGUoKSAtIDE7XG4gICAgICB0aGlzLnBlcmZvcm1hbmNlQnVmZmVyLmRhaWx5W2RheUluZGV4XSA9IDA7XG4gICAgfSwgMjQgKiA2MCAqIDYwICogMTAwMCk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYXV0b21hdGljIGNsZWFudXAgb2Ygb2xkIGRhdGFcbiAgICovXG4gIHByaXZhdGUgc3RhcnRBdXRvbWF0aWNDbGVhbnVwKCk6IHZvaWQge1xuICAgIC8vIENsZWFuIHVwIG9sZCB0YXNrIGxvZ3MgZXZlcnkgNiBob3Vyc1xuICAgIHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMuY2xlYW51cE9sZFRhc2tMb2dzKCk7XG4gICAgfSwgNiAqIDYwICogNjAgKiAxMDAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCBvbGQgdGFzayBsb2dzIHRvIHByZXZlbnQgbWVtb3J5IG92ZXJmbG93XG4gICAqL1xuICBwcml2YXRlIGNsZWFudXBPbGRUYXNrTG9ncygpOiB2b2lkIHtcbiAgICBjb25zdCBjdXRvZmZEYXRlID0gbmV3IERhdGUoRGF0ZS5ub3coKSAtIDcgKiAyNCAqIDYwICogNjAgKiAxMDAwKTsgLy8gNyBkYXlzIGFnb1xuICAgIGNvbnN0IGxvZ3NUb0RlbGV0ZTogc3RyaW5nW10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgW2lkLCBsb2ddIG9mIHRoaXMudGFza0xvZ3MuZW50cmllcygpKSB7XG4gICAgICBpZiAobG9nLmNyZWF0ZWRBdCA8IGN1dG9mZkRhdGUpIHtcbiAgICAgICAgbG9nc1RvRGVsZXRlLnB1c2goaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEtlZXAgb25seSByZWNlbnQgbG9ncyBpZiB3ZSdyZSBvdmVyIHRoZSBsaW1pdFxuICAgIGlmICh0aGlzLnRhc2tMb2dzLnNpemUgPiB0aGlzLk1BWF9UQVNLX0xPR1MpIHtcbiAgICAgIGNvbnN0IHNvcnRlZExvZ3MgPSBBcnJheS5mcm9tKHRoaXMudGFza0xvZ3MuZW50cmllcygpKVxuICAgICAgICAuc29ydCgoWyxhXSwgWyxiXSkgPT4gYi5jcmVhdGVkQXQuZ2V0VGltZSgpIC0gYS5jcmVhdGVkQXQuZ2V0VGltZSgpKTtcbiAgICAgIFxuICAgICAgY29uc3QgdG9EZWxldGUgPSBzb3J0ZWRMb2dzLnNsaWNlKHRoaXMuTUFYX1RBU0tfTE9HUyk7XG4gICAgICB0b0RlbGV0ZS5mb3JFYWNoKChbaWRdKSA9PiBsb2dzVG9EZWxldGUucHVzaChpZCkpO1xuICAgIH1cblxuICAgIC8vIERlbGV0ZSBvbGQgbG9nc1xuICAgIGxvZ3NUb0RlbGV0ZS5mb3JFYWNoKGlkID0+IHtcbiAgICAgIHRoaXMudGFza0xvZ3MuZGVsZXRlKGlkKTtcbiAgICAgIHRoaXMucm9sbGJhY2tDYXBhYmlsaXRpZXMuZGVsZXRlKGlkKTtcbiAgICB9KTtcblxuICAgIGlmIChsb2dzVG9EZWxldGUubGVuZ3RoID4gMCkge1xuICAgICAgbG9nZ2VyLmluZm8oJ0NsZWFuZWQgdXAgb2xkIHRhc2sgbG9ncycsIHsgXG4gICAgICAgIGRlbGV0ZWRDb3VudDogbG9nc1RvRGVsZXRlLmxlbmd0aCxcbiAgICAgICAgcmVtYWluaW5nQ291bnQ6IHRoaXMudGFza0xvZ3Muc2l6ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcnNpc3QgdGFzayBsb2cgdG8gZGF0YWJhc2VcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcGVyc2lzdFRhc2tMb2codGFza0xvZzogQ29tcHJlaGVuc2l2ZVRhc2tMb2cpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgcHJpc21hLnRhc2tFeGVjdXRpb24udXBzZXJ0KHtcbiAgICAgICAgd2hlcmU6IHsgaWQ6IHRhc2tMb2cuaWQgfSxcbiAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgc3RhdHVzOiB0YXNrTG9nLnN0YXR1cyxcbiAgICAgICAgICBleGVjdXRpb25UaW1lOiB0YXNrTG9nLmV4ZWN1dGlvblRpbWUsXG4gICAgICAgICAgcmVzdWx0OiB0YXNrTG9nLnJlc3VsdCxcbiAgICAgICAgICB3YXJuaW5nczogdGFza0xvZy53YXJuaW5ncyxcbiAgICAgICAgICBlcnJvcnM6IHRhc2tMb2cuZXJyb3JzLFxuICAgICAgICAgIGF1ZGl0VHJhaWw6IHRhc2tMb2cuYXVkaXRUcmFpbCxcbiAgICAgICAgICByb2xsYmFja0RhdGE6IHRhc2tMb2cucm9sbGJhY2tEYXRhLFxuICAgICAgICAgIHJvbGxiYWNrUGVyZm9ybWVkOiB0YXNrTG9nLnJvbGxiYWNrUGVyZm9ybWVkLFxuICAgICAgICAgIHJvbGxiYWNrUmVhc29uOiB0YXNrTG9nLnJvbGxiYWNrUmVhc29uLFxuICAgICAgICAgIGNvbXBsZXRlZEF0OiB0YXNrTG9nLmNvbXBsZXRlZEF0XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZToge1xuICAgICAgICAgIGlkOiB0YXNrTG9nLmlkLFxuICAgICAgICAgIHRhc2tJZDogdGFza0xvZy50YXNrSWQsXG4gICAgICAgICAgdXNlcklkOiB0YXNrTG9nLnVzZXJJZCxcbiAgICAgICAgICB0YXNrVHlwZTogdGFza0xvZy50YXNrVHlwZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogdGFza0xvZy5kZXNjcmlwdGlvbixcbiAgICAgICAgICBzdGF0dXM6IHRhc2tMb2cuc3RhdHVzLFxuICAgICAgICAgIHJpc2tMZXZlbDogdGFza0xvZy5yaXNrTGV2ZWwsXG4gICAgICAgICAgZXhlY3V0aW9uVGltZTogdGFza0xvZy5leGVjdXRpb25UaW1lLFxuICAgICAgICAgIHBhcmFtZXRlcnM6IHRhc2tMb2cucGFyYW1ldGVycyxcbiAgICAgICAgICByZXN1bHQ6IHRhc2tMb2cucmVzdWx0LFxuICAgICAgICAgIHdhcm5pbmdzOiB0YXNrTG9nLndhcm5pbmdzLFxuICAgICAgICAgIGVycm9yczogdGFza0xvZy5lcnJvcnMsXG4gICAgICAgICAgYXVkaXRUcmFpbDogdGFza0xvZy5hdWRpdFRyYWlsLFxuICAgICAgICAgIHJvbGxiYWNrRGF0YTogdGFza0xvZy5yb2xsYmFja0RhdGEsXG4gICAgICAgICAgcm9sbGJhY2tQZXJmb3JtZWQ6IHRhc2tMb2cucm9sbGJhY2tQZXJmb3JtZWQsXG4gICAgICAgICAgcm9sbGJhY2tSZWFzb246IHRhc2tMb2cucm9sbGJhY2tSZWFzb24sXG4gICAgICAgICAgYXBwcm92YWxJZDogdGFza0xvZy5hcHByb3ZhbElkLFxuICAgICAgICAgIGNyZWF0ZWRBdDogdGFza0xvZy5jcmVhdGVkQXQsXG4gICAgICAgICAgY29tcGxldGVkQXQ6IHRhc2tMb2cuY29tcGxldGVkQXRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdGYWlsZWQgdG8gcGVyc2lzdCB0YXNrIGxvZyB0byBkYXRhYmFzZScsIHsgXG4gICAgICAgIGV4ZWN1dGlvbklkOiB0YXNrTG9nLmlkLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IG92ZXJhbGwgc3lzdGVtIG1ldHJpY3NcbiAgICovXG4gIGdldE92ZXJhbGxNZXRyaWNzKCk6IFJlY29yZDxzdHJpbmcsIFRhc2tFeGVjdXRpb25NZXRyaWNzPiB7XG4gICAgY29uc3QgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBUYXNrRXhlY3V0aW9uTWV0cmljcz4gPSB7fTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IHRhc2tUeXBlIG9mIHRoaXMubWV0cmljcy5rZXlzKCkpIHtcbiAgICAgIHJlc3VsdFt0YXNrVHlwZV0gPSB0aGlzLmdldE1ldHJpY3ModGFza1R5cGUpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGhlYWx0aCBzdGF0dXMgb2YgdGFzayBleGVjdXRpb24gc3lzdGVtXG4gICAqL1xuICBnZXRIZWFsdGhTdGF0dXMoKToge1xuICAgIHN0YXR1czogJ2hlYWx0aHknIHwgJ3dhcm5pbmcnIHwgJ2NyaXRpY2FsJztcbiAgICBpc3N1ZXM6IHN0cmluZ1tdO1xuICAgIHJlY29tbWVuZGF0aW9uczogc3RyaW5nW107XG4gIH0ge1xuICAgIGNvbnN0IG92ZXJhbGwgPSB0aGlzLmdldE92ZXJhbGxNZXRyaWNzKCk7XG4gICAgY29uc3QgaXNzdWVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHJlY29tbWVuZGF0aW9uczogc3RyaW5nW10gPSBbXTtcbiAgICBcbiAgICBsZXQgdG90YWxBdHRlbXB0cyA9IDA7XG4gICAgbGV0IHRvdGFsU3VjY2Vzc2Z1bCA9IDA7XG4gICAgXG4gICAgZm9yIChjb25zdCBbdGFza1R5cGUsIG1ldHJpY3NdIG9mIE9iamVjdC5lbnRyaWVzKG92ZXJhbGwpKSB7XG4gICAgICB0b3RhbEF0dGVtcHRzICs9IG1ldHJpY3MudG90YWxBdHRlbXB0cztcbiAgICAgIHRvdGFsU3VjY2Vzc2Z1bCArPSBtZXRyaWNzLnN1Y2Nlc3NmdWxFeGVjdXRpb25zO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgaXNzdWVzXG4gICAgICBpZiAobWV0cmljcy5zdWNjZXNzUmF0ZSA8IDcwICYmIG1ldHJpY3MudG90YWxBdHRlbXB0cyA+IDEwKSB7XG4gICAgICAgIGlzc3Vlcy5wdXNoKGBMb3cgc3VjY2VzcyByYXRlIGZvciAke3Rhc2tUeXBlfTogJHttZXRyaWNzLnN1Y2Nlc3NSYXRlLnRvRml4ZWQoMSl9JWApO1xuICAgICAgICByZWNvbW1lbmRhdGlvbnMucHVzaChgUmV2aWV3ICR7dGFza1R5cGV9IGltcGxlbWVudGF0aW9uIGFuZCBlcnJvciBoYW5kbGluZ2ApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAobWV0cmljcy5hdmdFeGVjdXRpb25UaW1lID4gNTAwMCkgeyAvLyA1IHNlY29uZHNcbiAgICAgICAgaXNzdWVzLnB1c2goYFNsb3cgZXhlY3V0aW9uIGZvciAke3Rhc2tUeXBlfTogJHttZXRyaWNzLmF2Z0V4ZWN1dGlvblRpbWUudG9GaXhlZCgwKX1tc2ApO1xuICAgICAgICByZWNvbW1lbmRhdGlvbnMucHVzaChgT3B0aW1pemUgJHt0YXNrVHlwZX0gcGVyZm9ybWFuY2VgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvdmVyYWxsU3VjY2Vzc1JhdGUgPSB0b3RhbEF0dGVtcHRzID4gMCA/ICh0b3RhbFN1Y2Nlc3NmdWwgLyB0b3RhbEF0dGVtcHRzKSAqIDEwMCA6IDEwMDtcbiAgICBcbiAgICBsZXQgc3RhdHVzOiAnaGVhbHRoeScgfCAnd2FybmluZycgfCAnY3JpdGljYWwnID0gJ2hlYWx0aHknO1xuICAgIGlmIChvdmVyYWxsU3VjY2Vzc1JhdGUgPCA1MCkge1xuICAgICAgc3RhdHVzID0gJ2NyaXRpY2FsJztcbiAgICB9IGVsc2UgaWYgKG92ZXJhbGxTdWNjZXNzUmF0ZSA8IDgwIHx8IGlzc3Vlcy5sZW5ndGggPiAyKSB7XG4gICAgICBzdGF0dXMgPSAnd2FybmluZyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1cyxcbiAgICAgIGlzc3VlcyxcbiAgICAgIHJlY29tbWVuZGF0aW9uc1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUGVyc2lzdCBtZXRyaWNzIHRvIGRhdGFiYXNlIGZvciBsb25nLXRlcm0gc3RvcmFnZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBwZXJzaXN0TWV0cmljcyhldmVudDogVGFza0V4ZWN1dGlvbkV2ZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHByaXNtYS51c2VyQWN0aXZpdHkuY3JlYXRlKHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHVzZXJJZDogZXZlbnQudXNlcklkLFxuICAgICAgICAgIHR5cGU6ICdhaV90YXNrX2V4ZWN1dGlvbicsXG4gICAgICAgICAgY2hhbm5lbDogJ0FJJyxcbiAgICAgICAgICB0aW1lc3RhbXA6IGV2ZW50LnRpbWVzdGFtcCxcbiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgdGFza1R5cGU6IGV2ZW50LnRhc2tUeXBlLFxuICAgICAgICAgICAgdXNlclJvbGU6IGV2ZW50LnVzZXJSb2xlLFxuICAgICAgICAgICAgc3VjY2VzczogZXZlbnQuc3VjY2VzcyxcbiAgICAgICAgICAgIGV4ZWN1dGlvblRpbWU6IGV2ZW50LmV4ZWN1dGlvblRpbWUsXG4gICAgICAgICAgICBlcnJvclR5cGU6IGV2ZW50LmVycm9yVHlwZSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZTogZXZlbnQuZXJyb3JNZXNzYWdlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gRG9uJ3QgdGhyb3cgLSB0aGlzIGlzIGp1c3QgZm9yIG1ldHJpY3MgY29sbGVjdGlvblxuICAgICAgbG9nZ2VyLndhcm4oJ0ZhaWxlZCB0byBwZXJzaXN0IHRhc2sgZXhlY3V0aW9uIG1ldHJpY3MgdG8gZGF0YWJhc2UnLCB7XG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcilcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBvbGQgbWV0cmljcyAoZm9yIG1lbW9yeSBtYW5hZ2VtZW50KVxuICAgKi9cbiAgY2xlYXJPbGRNZXRyaWNzKG9sZGVyVGhhbkhvdXJzID0gMjQpOiB2b2lkIHtcbiAgICBjb25zdCBjdXRvZmYgPSBuZXcgRGF0ZShEYXRlLm5vdygpIC0gb2xkZXJUaGFuSG91cnMgKiA2MCAqIDYwICogMTAwMCk7XG4gICAgXG4gICAgZm9yIChjb25zdCBbdGFza1R5cGUsIGV2ZW50c10gb2YgdGhpcy5tZXRyaWNzLmVudHJpZXMoKSkge1xuICAgICAgY29uc3QgZmlsdGVyZWQgPSBldmVudHMuZmlsdGVyKGUgPT4gZS50aW1lc3RhbXAgPiBjdXRvZmYpO1xuICAgICAgdGhpcy5tZXRyaWNzLnNldCh0YXNrVHlwZSwgZmlsdGVyZWQpO1xuICAgIH1cbiAgICBcbiAgICBsb2dnZXIuaW5mbygnQ2xlYXJlZCBvbGQgdGFzayBleGVjdXRpb24gbWV0cmljcycsIHsgXG4gICAgICBjdXRvZmZIb3Vyczogb2xkZXJUaGFuSG91cnMsXG4gICAgICByZW1haW5pbmdUYXNrVHlwZXM6IHRoaXMubWV0cmljcy5zaXplIFxuICAgIH0pO1xuICB9XG59XG5cbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCB0YXNrRXhlY3V0aW9uTW9uaXRvciA9IG5ldyBUYXNrRXhlY3V0aW9uTW9uaXRvcigpO1xuXG4vLyBFeHBvcnQgaGVscGVyIGZ1bmN0aW9uIHRvIHJlY29yZCB0YXNrIGV4ZWN1dGlvblxuZXhwb3J0IGZ1bmN0aW9uIHJlY29yZFRhc2tFeGVjdXRpb24oXG4gIHRhc2tUeXBlOiBzdHJpbmcsXG4gIHVzZXJJZDogc3RyaW5nLFxuICB1c2VyUm9sZTogc3RyaW5nLFxuICBzdWNjZXNzOiBib29sZWFuLFxuICBleGVjdXRpb25UaW1lOiBudW1iZXIsXG4gIGVycm9yVHlwZT86IHN0cmluZyxcbiAgZXJyb3JNZXNzYWdlPzogc3RyaW5nXG4pOiB2b2lkIHtcbiAgdGFza0V4ZWN1dGlvbk1vbml0b3IucmVjb3JkRXhlY3V0aW9uKHtcbiAgICB0YXNrVHlwZSxcbiAgICB1c2VySWQsXG4gICAgdXNlclJvbGUsXG4gICAgc3VjY2VzcyxcbiAgICBleGVjdXRpb25UaW1lLFxuICAgIGVycm9yVHlwZSxcbiAgICBlcnJvck1lc3NhZ2UsXG4gICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpXG4gIH0pO1xufVxuXG4vLyBFeHBvcnQgdHlwZXNcbmV4cG9ydCB0eXBlIHsgVGFza0V4ZWN1dGlvbk1ldHJpY3MsIFRhc2tFeGVjdXRpb25FdmVudCB9OyJdLCJuYW1lcyI6WyJyZWNvcmRUYXNrRXhlY3V0aW9uIiwidGFza0V4ZWN1dGlvbk1vbml0b3IiLCJUYXNrRXhlY3V0aW9uTW9uaXRvciIsImNvbnN0cnVjdG9yIiwibWV0cmljcyIsIk1hcCIsInRhc2tMb2dzIiwicm9sbGJhY2tDYXBhYmlsaXRpZXMiLCJNQVhfRVZFTlRTX1BFUl9UWVBFIiwiTUFYX1RBU0tfTE9HUyIsInBlcmZvcm1hbmNlQnVmZmVyIiwiaG91cmx5IiwiQXJyYXkiLCJmaWxsIiwiZGFpbHkiLCJ3ZWVrbHkiLCJzdGFydFBlcmZvcm1hbmNlVHJlbmRUcmFja2luZyIsInN0YXJ0QXV0b21hdGljQ2xlYW51cCIsInN0YXJ0VGFza0V4ZWN1dGlvbiIsInRhc2tJZCIsInVzZXJJZCIsInVzZXJSb2xlIiwidGFza1R5cGUiLCJkZXNjcmlwdGlvbiIsInBhcmFtZXRlcnMiLCJyaXNrTGV2ZWwiLCJzZWN1cml0eUNvbnRleHQiLCJhcHByb3ZhbElkIiwiZXhlY3V0aW9uSWQiLCJEYXRlIiwibm93IiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwidGFza0xvZyIsImlkIiwic3Vic3RyaW5nIiwic3RhdHVzIiwiZXhlY3V0aW9uVGltZSIsInJlc3VsdCIsIndhcm5pbmdzIiwiZXJyb3JzIiwiYXVkaXRUcmFpbCIsInRvSVNPU3RyaW5nIiwiYXBwcm92YWxSZXF1aXJlZCIsImNyZWF0ZWRBdCIsInNldCIsInVwZGF0ZVBlcmZvcm1hbmNlVHJlbmRzIiwicGVyc2lzdFRhc2tMb2ciLCJsb2dnZXIiLCJpbmZvIiwicmVjb3JkRXhlY3V0aW9uIiwiZXZlbnQiLCJldmVudHMiLCJnZXQiLCJwdXNoIiwibGVuZ3RoIiwic3BsaWNlIiwic3VjY2VzcyIsImVycm9yVHlwZSIsInJvbGxiYWNrUGVyZm9ybWVkIiwidGltZXN0YW1wIiwicGVyc2lzdE1ldHJpY3MiLCJjYXRjaCIsImVycm9yIiwid2FybiIsIm1lc3NhZ2UiLCJjb21wbGV0ZVRhc2tFeGVjdXRpb24iLCJyb2xsYmFja0RhdGEiLCJnZXRUaW1lIiwiY29tcGxldGVkQXQiLCJjcmVhdGVSb2xsYmFja0NhcGFiaWxpdHkiLCJyb2xsYmFja0F2YWlsYWJsZSIsImZhaWxUYXNrRXhlY3V0aW9uIiwiZXJyb3JNZXNzYWdlIiwicGVyZm9ybVJvbGxiYWNrIiwicm9sbGJhY2tSZWFzb24iLCJyb2xsYmFja1VzZXJJZCIsInJvbGxiYWNrQ2FwYWJpbGl0eSIsImF2YWlsYWJsZSIsInN0cmF0ZWd5Iiwic3RlcCIsInN0ZXBzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiRXJyb3IiLCJnZXRNZXRyaWNzIiwidG90YWxBdHRlbXB0cyIsInN1Y2Nlc3NmdWxFeGVjdXRpb25zIiwiZmFpbGVkRXhlY3V0aW9ucyIsInN1Y2Nlc3NSYXRlIiwiYXZnRXhlY3V0aW9uVGltZSIsImNvbW1vbkVycm9ycyIsInVzZXJSb2xlU3RhdHMiLCJyb2xsYmFja1JhdGUiLCJhcHByb3ZhbFJlcXVpcmVkUmF0ZSIsInJpc2tEaXN0cmlidXRpb24iLCJwZXJmb3JtYW5jZVRyZW5kcyIsInN1Y2Nlc3NmdWwiLCJmaWx0ZXIiLCJlIiwiZmFpbGVkIiwicm9sbGVkQmFjayIsInRvdGFsVGltZSIsInJlZHVjZSIsInN1bSIsImVycm9yQ291bnRzIiwiZm9yRWFjaCIsInJvbGVTdGF0cyIsIk9iamVjdCIsImVudHJpZXMiLCJzb3J0IiwiYSIsImIiLCJzbGljZSIsIm1hcCIsImdldFRhc2tMb2ciLCJnZXRVc2VyVGFza0xvZ3MiLCJsaW1pdCIsImxvZ3MiLCJmcm9tIiwidmFsdWVzIiwibG9nIiwiZ2V0Um9sbGJhY2tDYXBhYmlsaXR5IiwiZ2V0Um9sbGJhY2tDYW5kaWRhdGVzIiwiY2FuZGlkYXRlcyIsImNhcGFiaWxpdHkiLCJkZXRlcm1pbmVSb2xsYmFja1N0cmF0ZWd5IiwiZ2VuZXJhdGVSb2xsYmFja1N0ZXBzIiwidGltZUxpbWl0IiwiZ2V0Um9sbGJhY2tUaW1lTGltaXQiLCJkZXBlbmRlbmNpZXMiLCJnZXRSb2xsYmFja0RlcGVuZGVuY2llcyIsImN1cnJlbnQiLCJsaW1pdHMiLCJsb3ciLCJtZWRpdW0iLCJoaWdoIiwiY3JpdGljYWwiLCJzZWdtZW50YXRpb24iLCJjYW1wYWlnbl9vcHRpbWl6YXRpb24iLCJpbnRlZ3JhdGlvbl9jb25maWciLCJkYXRhX2FuYWx5c2lzIiwicmVwb3J0aW5nIiwiaW5jcmVtZW50IiwiaG91ckluZGV4IiwiZ2V0SG91cnMiLCJkYXlJbmRleCIsImdldERhdGUiLCJ3ZWVrSW5kZXgiLCJmbG9vciIsImdldEZ1bGxZZWFyIiwic2V0SW50ZXJ2YWwiLCJjbGVhbnVwT2xkVGFza0xvZ3MiLCJjdXRvZmZEYXRlIiwibG9nc1RvRGVsZXRlIiwic2l6ZSIsInNvcnRlZExvZ3MiLCJ0b0RlbGV0ZSIsImRlbGV0ZSIsImRlbGV0ZWRDb3VudCIsInJlbWFpbmluZ0NvdW50IiwicHJpc21hIiwidGFza0V4ZWN1dGlvbiIsInVwc2VydCIsIndoZXJlIiwidXBkYXRlIiwiY3JlYXRlIiwiU3RyaW5nIiwiZ2V0T3ZlcmFsbE1ldHJpY3MiLCJrZXlzIiwiZ2V0SGVhbHRoU3RhdHVzIiwib3ZlcmFsbCIsImlzc3VlcyIsInJlY29tbWVuZGF0aW9ucyIsInRvdGFsU3VjY2Vzc2Z1bCIsInRvRml4ZWQiLCJvdmVyYWxsU3VjY2Vzc1JhdGUiLCJ1c2VyQWN0aXZpdHkiLCJkYXRhIiwidHlwZSIsImNoYW5uZWwiLCJtZXRhZGF0YSIsImNsZWFyT2xkTWV0cmljcyIsIm9sZGVyVGhhbkhvdXJzIiwiY3V0b2ZmIiwiZmlsdGVyZWQiLCJjdXRvZmZIb3VycyIsInJlbWFpbmluZ1Rhc2tUeXBlcyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0M7Ozs7Ozs7Ozs7O0lBZzNCZUEsbUJBQW1CO2VBQW5CQTs7SUFISEMsb0JB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