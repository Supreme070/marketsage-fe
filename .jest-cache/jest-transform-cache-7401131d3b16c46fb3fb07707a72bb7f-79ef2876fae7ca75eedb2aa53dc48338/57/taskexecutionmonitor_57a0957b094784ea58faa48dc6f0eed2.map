{"version":3,"sources":["/Users/supreme/Desktop/marketsage/src/lib/ai/task-execution-monitor.ts"],"sourcesContent":["/**\n * Task Execution Monitoring - Enhanced Production Version\n * ======================================================\n * Comprehensive monitoring, audit logging, rollback capabilities, and performance analytics\n * for AI task execution system with enterprise-grade security and compliance features.\n */\n\nimport { logger } from '@/lib/logger';\nimport prisma from '@/lib/db/prisma';\n\ninterface TaskExecutionMetrics {\n  totalAttempts: number;\n  successfulExecutions: number;\n  failedExecutions: number;\n  successRate: number;\n  avgExecutionTime: number;\n  commonErrors: string[];\n  userRoleStats: Record<string, number>;\n  rollbackRate: number;\n  approvalRequiredRate: number;\n  riskDistribution: Record<string, number>;\n  performanceTrends: {\n    hourly: number[];\n    daily: number[];\n    weekly: number[];\n  };\n}\n\ninterface TaskExecutionEvent {\n  taskType: string;\n  userId: string;\n  userRole: string;\n  success: boolean;\n  executionTime: number;\n  errorType?: string;\n  errorMessage?: string;\n  timestamp: Date;\n  riskLevel?: 'low' | 'medium' | 'high' | 'critical';\n  approvalRequired?: boolean;\n  approvalId?: string;\n  rollbackPerformed?: boolean;\n  rollbackReason?: string;\n  parameters?: Record<string, any>;\n  result?: any;\n  auditTrail?: string[];\n}\n\ninterface ComprehensiveTaskLog {\n  id: string;\n  taskId: string;\n  userId: string;\n  userRole: string;\n  taskType: string;\n  description: string;\n  status: 'pending' | 'running' | 'completed' | 'failed' | 'approval_required' | 'rolled_back';\n  riskLevel: 'low' | 'medium' | 'high' | 'critical';\n  executionTime: number;\n  parameters: Record<string, any>;\n  result: any;\n  warnings: string[];\n  errors: string[];\n  auditTrail: string[];\n  rollbackData?: any;\n  rollbackPerformed?: boolean;\n  rollbackReason?: string;\n  approvalId?: string;\n  approvalRequired: boolean;\n  createdAt: Date;\n  completedAt?: Date;\n  securityContext: {\n    ipAddress?: string;\n    userAgent?: string;\n    sessionId?: string;\n    permissions: string[];\n  };\n}\n\ninterface RollbackCapability {\n  available: boolean;\n  strategy: 'automatic' | 'manual' | 'impossible';\n  steps: string[];\n  timeLimit: number;\n  dependencies: string[];\n  rollbackData?: any;\n}\n\nclass TaskExecutionMonitor {\n  private metrics: Map<string, TaskExecutionEvent[]> = new Map();\n  private taskLogs: Map<string, ComprehensiveTaskLog> = new Map();\n  private rollbackCapabilities: Map<string, RollbackCapability> = new Map();\n  private readonly MAX_EVENTS_PER_TYPE = 1000; // Limit memory usage\n  private readonly MAX_TASK_LOGS = 5000; // Limit task log storage\n  private performanceBuffer: {\n    hourly: number[];\n    daily: number[];\n    weekly: number[];\n  } = {\n    hourly: new Array(24).fill(0),\n    daily: new Array(30).fill(0),\n    weekly: new Array(52).fill(0)\n  };\n\n  constructor() {\n    // Start performance trend tracking\n    this.startPerformanceTrendTracking();\n    \n    // Start automatic cleanup\n    this.startAutomaticCleanup();\n  }\n\n  /**\n   * Start comprehensive task execution with full audit logging\n   */\n  async startTaskExecution(\n    taskId: string,\n    userId: string,\n    userRole: string,\n    taskType: string,\n    description: string,\n    parameters: Record<string, any>,\n    riskLevel: 'low' | 'medium' | 'high' | 'critical',\n    securityContext: {\n      ipAddress?: string;\n      userAgent?: string;\n      sessionId?: string;\n      permissions: string[];\n    },\n    approvalId?: string\n  ): Promise<string> {\n    const executionId = `exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    const taskLog: ComprehensiveTaskLog = {\n      id: executionId,\n      taskId,\n      userId,\n      userRole,\n      taskType,\n      description: description.substring(0, 500),\n      status: 'running',\n      riskLevel,\n      executionTime: 0,\n      parameters,\n      result: null,\n      warnings: [],\n      errors: [],\n      auditTrail: [`${new Date().toISOString()}: Task execution started`],\n      approvalId,\n      approvalRequired: !!approvalId,\n      createdAt: new Date(),\n      securityContext\n    };\n\n    this.taskLogs.set(executionId, taskLog);\n    \n    // Update performance trends\n    this.updatePerformanceTrends(1);\n    \n    // Persist to database\n    await this.persistTaskLog(taskLog);\n\n    logger.info('Task execution started with comprehensive logging', {\n      executionId,\n      taskId,\n      userId,\n      taskType,\n      riskLevel,\n      approvalRequired: !!approvalId\n    });\n\n    return executionId;\n  }\n\n  /**\n   * Record a task execution attempt (enhanced version)\n   */\n  recordExecution(event: TaskExecutionEvent): void {\n    const events = this.metrics.get(event.taskType) || [];\n    events.push(event);\n\n    // Keep only recent events to prevent memory overflow\n    if (events.length > this.MAX_EVENTS_PER_TYPE) {\n      events.splice(0, events.length - this.MAX_EVENTS_PER_TYPE);\n    }\n\n    this.metrics.set(event.taskType, events);\n\n    // Log the event with enhanced details\n    logger.info('Task execution recorded', {\n      taskType: event.taskType,\n      userId: event.userId,\n      userRole: event.userRole,\n      success: event.success,\n      executionTime: event.executionTime,\n      errorType: event.errorType,\n      riskLevel: event.riskLevel,\n      approvalRequired: event.approvalRequired,\n      rollbackPerformed: event.rollbackPerformed,\n      timestamp: event.timestamp\n    });\n\n    // Store metrics in database for persistence (async, don't wait)\n    this.persistMetrics(event).catch(error => {\n      logger.warn('Failed to persist task execution metrics', { error: error.message });\n    });\n  }\n\n  /**\n   * Complete task execution with comprehensive logging\n   */\n  async completeTaskExecution(\n    executionId: string,\n    result: any,\n    warnings: string[] = [],\n    rollbackData?: any\n  ): Promise<void> {\n    const taskLog = this.taskLogs.get(executionId);\n    if (!taskLog) {\n      logger.error('Task log not found for completion', { executionId });\n      return;\n    }\n\n    const executionTime = Date.now() - taskLog.createdAt.getTime();\n    \n    taskLog.status = 'completed';\n    taskLog.executionTime = executionTime;\n    taskLog.result = result;\n    taskLog.warnings = warnings;\n    taskLog.rollbackData = rollbackData;\n    taskLog.completedAt = new Date();\n    \n    taskLog.auditTrail.push(`${new Date().toISOString()}: Task completed successfully in ${executionTime}ms`);\n    \n    if (warnings.length > 0) {\n      taskLog.auditTrail.push(`${new Date().toISOString()}: ${warnings.length} warnings generated`);\n    }\n\n    // Create rollback capability if data is available\n    if (rollbackData) {\n      this.createRollbackCapability(executionId, rollbackData, taskLog);\n    }\n\n    // Record execution event\n    this.recordExecution({\n      taskType: taskLog.taskType,\n      userId: taskLog.userId,\n      userRole: taskLog.userRole,\n      success: true,\n      executionTime,\n      timestamp: new Date(),\n      riskLevel: taskLog.riskLevel,\n      approvalRequired: taskLog.approvalRequired,\n      parameters: taskLog.parameters,\n      result,\n      auditTrail: taskLog.auditTrail\n    });\n\n    // Update database\n    await this.persistTaskLog(taskLog);\n\n    logger.info('Task execution completed', {\n      executionId,\n      taskId: taskLog.taskId,\n      executionTime,\n      warnings: warnings.length,\n      rollbackAvailable: !!rollbackData\n    });\n  }\n\n  /**\n   * Fail task execution with comprehensive logging\n   */\n  async failTaskExecution(\n    executionId: string,\n    errorType: string,\n    errorMessage: string,\n    rollbackData?: any\n  ): Promise<void> {\n    const taskLog = this.taskLogs.get(executionId);\n    if (!taskLog) {\n      logger.error('Task log not found for failure', { executionId });\n      return;\n    }\n\n    const executionTime = Date.now() - taskLog.createdAt.getTime();\n    \n    taskLog.status = 'failed';\n    taskLog.executionTime = executionTime;\n    taskLog.errors.push(errorMessage);\n    taskLog.rollbackData = rollbackData;\n    taskLog.completedAt = new Date();\n    \n    taskLog.auditTrail.push(`${new Date().toISOString()}: Task failed after ${executionTime}ms`);\n    taskLog.auditTrail.push(`${new Date().toISOString()}: Error - ${errorType}: ${errorMessage}`);\n\n    // Create rollback capability if data is available\n    if (rollbackData) {\n      this.createRollbackCapability(executionId, rollbackData, taskLog);\n    }\n\n    // Record execution event\n    this.recordExecution({\n      taskType: taskLog.taskType,\n      userId: taskLog.userId,\n      userRole: taskLog.userRole,\n      success: false,\n      executionTime,\n      errorType,\n      errorMessage,\n      timestamp: new Date(),\n      riskLevel: taskLog.riskLevel,\n      approvalRequired: taskLog.approvalRequired,\n      parameters: taskLog.parameters,\n      auditTrail: taskLog.auditTrail\n    });\n\n    // Update database\n    await this.persistTaskLog(taskLog);\n\n    logger.error('Task execution failed', {\n      executionId,\n      taskId: taskLog.taskId,\n      executionTime,\n      errorType,\n      errorMessage,\n      rollbackAvailable: !!rollbackData\n    });\n  }\n\n  /**\n   * Perform task rollback with comprehensive logging\n   */\n  async performRollback(\n    executionId: string,\n    rollbackReason: string,\n    rollbackUserId: string\n  ): Promise<boolean> {\n    const taskLog = this.taskLogs.get(executionId);\n    const rollbackCapability = this.rollbackCapabilities.get(executionId);\n    \n    if (!taskLog || !rollbackCapability || !rollbackCapability.available) {\n      logger.error('Rollback not available', { executionId, taskLog: !!taskLog, rollbackCapability: !!rollbackCapability });\n      return false;\n    }\n\n    try {\n      taskLog.auditTrail.push(`${new Date().toISOString()}: Rollback initiated by user ${rollbackUserId}`);\n      taskLog.auditTrail.push(`${new Date().toISOString()}: Rollback reason: ${rollbackReason}`);\n      \n      // Execute rollback steps\n      if (rollbackCapability.strategy === 'automatic') {\n        taskLog.auditTrail.push(`${new Date().toISOString()}: Executing automatic rollback`);\n        \n        // In production, this would execute actual rollback operations\n        for (const step of rollbackCapability.steps) {\n          taskLog.auditTrail.push(`${new Date().toISOString()}: Rollback step: ${step}`);\n          // Simulate rollback step execution\n          await new Promise(resolve => setTimeout(resolve, 100));\n        }\n      } else {\n        taskLog.auditTrail.push(`${new Date().toISOString()}: Manual rollback procedure initiated`);\n      }\n\n      taskLog.status = 'rolled_back';\n      taskLog.rollbackPerformed = true;\n      taskLog.rollbackReason = rollbackReason;\n      taskLog.auditTrail.push(`${new Date().toISOString()}: Rollback completed successfully`);\n\n      // Record rollback event\n      this.recordExecution({\n        taskType: taskLog.taskType,\n        userId: taskLog.userId,\n        userRole: taskLog.userRole,\n        success: true,\n        executionTime: taskLog.executionTime,\n        timestamp: new Date(),\n        riskLevel: taskLog.riskLevel,\n        rollbackPerformed: true,\n        rollbackReason,\n        auditTrail: taskLog.auditTrail\n      });\n\n      // Update database\n      await this.persistTaskLog(taskLog);\n\n      logger.info('Task rollback completed', {\n        executionId,\n        taskId: taskLog.taskId,\n        rollbackReason,\n        rollbackUserId\n      });\n\n      return true;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      taskLog.auditTrail.push(`${new Date().toISOString()}: Rollback failed: ${errorMessage}`);\n      taskLog.errors.push(`Rollback failed: ${errorMessage}`);\n      \n      await this.persistTaskLog(taskLog);\n      \n      logger.error('Task rollback failed', { executionId, error: errorMessage });\n      return false;\n    }\n  }\n\n  /**\n   * Get enhanced metrics for a specific task type\n   */\n  getMetrics(taskType: string): TaskExecutionMetrics {\n    const events = this.metrics.get(taskType) || [];\n    \n    if (events.length === 0) {\n      return {\n        totalAttempts: 0,\n        successfulExecutions: 0,\n        failedExecutions: 0,\n        successRate: 0,\n        avgExecutionTime: 0,\n        commonErrors: [],\n        userRoleStats: {},\n        rollbackRate: 0,\n        approvalRequiredRate: 0,\n        riskDistribution: {},\n        performanceTrends: {\n          hourly: [...this.performanceBuffer.hourly],\n          daily: [...this.performanceBuffer.daily],\n          weekly: [...this.performanceBuffer.weekly]\n        }\n      };\n    }\n\n    const successful = events.filter(e => e.success);\n    const failed = events.filter(e => !e.success);\n    const rolledBack = events.filter(e => e.rollbackPerformed);\n    const approvalRequired = events.filter(e => e.approvalRequired);\n    const totalTime = events.reduce((sum, e) => sum + e.executionTime, 0);\n    \n    // Count errors\n    const errorCounts: Record<string, number> = {};\n    failed.forEach(e => {\n      if (e.errorType) {\n        errorCounts[e.errorType] = (errorCounts[e.errorType] || 0) + 1;\n      }\n    });\n\n    // Count user role stats\n    const roleStats: Record<string, number> = {};\n    events.forEach(e => {\n      roleStats[e.userRole] = (roleStats[e.userRole] || 0) + 1;\n    });\n\n    // Count risk distribution\n    const riskDistribution: Record<string, number> = {};\n    events.forEach(e => {\n      if (e.riskLevel) {\n        riskDistribution[e.riskLevel] = (riskDistribution[e.riskLevel] || 0) + 1;\n      }\n    });\n\n    const commonErrors = Object.entries(errorCounts)\n      .sort(([,a], [,b]) => b - a)\n      .slice(0, 5)\n      .map(([error]) => error);\n\n    return {\n      totalAttempts: events.length,\n      successfulExecutions: successful.length,\n      failedExecutions: failed.length,\n      successRate: events.length > 0 ? (successful.length / events.length) * 100 : 0,\n      avgExecutionTime: events.length > 0 ? totalTime / events.length : 0,\n      commonErrors,\n      userRoleStats: roleStats,\n      rollbackRate: events.length > 0 ? (rolledBack.length / events.length) * 100 : 0,\n      approvalRequiredRate: events.length > 0 ? (approvalRequired.length / events.length) * 100 : 0,\n      riskDistribution,\n      performanceTrends: {\n        hourly: [...this.performanceBuffer.hourly],\n        daily: [...this.performanceBuffer.daily],\n        weekly: [...this.performanceBuffer.weekly]\n      }\n    };\n  }\n\n  /**\n   * Get comprehensive task log by execution ID\n   */\n  getTaskLog(executionId: string): ComprehensiveTaskLog | undefined {\n    return this.taskLogs.get(executionId);\n  }\n\n  /**\n   * Get task logs for a user with filtering\n   */\n  getUserTaskLogs(\n    userId: string, \n    status?: string, \n    taskType?: string, \n    limit = 50\n  ): ComprehensiveTaskLog[] {\n    let logs = Array.from(this.taskLogs.values())\n      .filter(log => log.userId === userId);\n\n    if (status) {\n      logs = logs.filter(log => log.status === status);\n    }\n\n    if (taskType) {\n      logs = logs.filter(log => log.taskType === taskType);\n    }\n\n    return logs\n      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())\n      .slice(0, limit);\n  }\n\n  /**\n   * Get rollback capability for a task\n   */\n  getRollbackCapability(executionId: string): RollbackCapability | undefined {\n    return this.rollbackCapabilities.get(executionId);\n  }\n\n  /**\n   * Get all task logs that can be rolled back\n   */\n  getRollbackCandidates(userId?: string): ComprehensiveTaskLog[] {\n    const candidates = Array.from(this.taskLogs.values())\n      .filter(log => \n        log.status === 'completed' && \n        log.rollbackData && \n        !log.rollbackPerformed &&\n        this.rollbackCapabilities.get(log.id)?.available\n      );\n\n    if (userId) {\n      return candidates.filter(log => log.userId === userId);\n    }\n\n    return candidates;\n  }\n\n  /**\n   * Create rollback capability for a task\n   */\n  private createRollbackCapability(\n    executionId: string, \n    rollbackData: any, \n    taskLog: ComprehensiveTaskLog\n  ): void {\n    const capability: RollbackCapability = {\n      available: true,\n      strategy: this.determineRollbackStrategy(taskLog.taskType, taskLog.riskLevel),\n      steps: this.generateRollbackSteps(taskLog.taskType, rollbackData),\n      timeLimit: this.getRollbackTimeLimit(taskLog.riskLevel),\n      dependencies: this.getRollbackDependencies(taskLog.taskType),\n      rollbackData\n    };\n\n    this.rollbackCapabilities.set(executionId, capability);\n    \n    // Auto-expire rollback capability after time limit\n    setTimeout(() => {\n      const current = this.rollbackCapabilities.get(executionId);\n      if (current && current.available) {\n        current.available = false;\n        taskLog.auditTrail.push(`${new Date().toISOString()}: Rollback capability expired after ${capability.timeLimit} minutes`);\n      }\n    }, capability.timeLimit * 60 * 1000);\n  }\n\n  /**\n   * Determine rollback strategy based on task type and risk level\n   */\n  private determineRollbackStrategy(\n    taskType: string, \n    riskLevel: string\n  ): 'automatic' | 'manual' | 'impossible' {\n    if (taskType === 'reporting' || taskType === 'data_analysis') {\n      return 'impossible'; // Read-only operations\n    }\n\n    if (riskLevel === 'critical') {\n      return 'manual'; // High-risk operations require manual rollback\n    }\n\n    return 'automatic'; // Default to automatic rollback\n  }\n\n  /**\n   * Generate rollback steps for a task type\n   */\n  private generateRollbackSteps(taskType: string, rollbackData: any): string[] {\n    const steps: string[] = [];\n\n    switch (taskType) {\n      case 'segmentation':\n        steps.push('Remove created customer segments');\n        steps.push('Restore previous segmentation rules');\n        steps.push('Update customer segment assignments');\n        break;\n      \n      case 'campaign_optimization':\n        steps.push('Restore original campaign settings');\n        steps.push('Revert send time optimizations');\n        steps.push('Reset A/B test configurations');\n        break;\n      \n      case 'integration_config':\n        steps.push('Disable new integration configuration');\n        steps.push('Restore previous integration settings');\n        steps.push('Validate system connectivity');\n        break;\n      \n      default:\n        steps.push('Restore previous system state');\n        steps.push('Verify rollback completion');\n    }\n\n    return steps;\n  }\n\n  /**\n   * Get rollback time limit based on risk level\n   */\n  private getRollbackTimeLimit(riskLevel: string): number {\n    const limits = {\n      low: 1440,      // 24 hours\n      medium: 720,    // 12 hours\n      high: 180,      // 3 hours\n      critical: 60    // 1 hour\n    };\n    return limits[riskLevel] || limits.medium;\n  }\n\n  /**\n   * Get rollback dependencies for a task type\n   */\n  private getRollbackDependencies(taskType: string): string[] {\n    const dependencies: Record<string, string[]> = {\n      segmentation: ['customer_data', 'segment_rules'],\n      campaign_optimization: ['campaign_settings', 'email_templates'],\n      integration_config: ['api_credentials', 'webhook_endpoints'],\n      data_analysis: [], // No dependencies for read-only\n      reporting: [] // No dependencies for read-only\n    };\n    \n    return dependencies[taskType] || [];\n  }\n\n  /**\n   * Update performance trends\n   */\n  private updatePerformanceTrends(increment: number): void {\n    const now = new Date();\n    const hourIndex = now.getHours();\n    const dayIndex = now.getDate() - 1;\n    const weekIndex = Math.floor((now.getTime() - new Date(now.getFullYear(), 0, 1).getTime()) / (7 * 24 * 60 * 60 * 1000));\n\n    this.performanceBuffer.hourly[hourIndex] += increment;\n    this.performanceBuffer.daily[dayIndex] += increment;\n    this.performanceBuffer.weekly[weekIndex % 52] += increment;\n  }\n\n  /**\n   * Start performance trend tracking\n   */\n  private startPerformanceTrendTracking(): void {\n    // Reset hourly buffer every hour\n    setInterval(() => {\n      const hourIndex = new Date().getHours();\n      this.performanceBuffer.hourly[hourIndex] = 0;\n    }, 60 * 60 * 1000);\n\n    // Reset daily buffer every day\n    setInterval(() => {\n      const dayIndex = new Date().getDate() - 1;\n      this.performanceBuffer.daily[dayIndex] = 0;\n    }, 24 * 60 * 60 * 1000);\n  }\n\n  /**\n   * Start automatic cleanup of old data\n   */\n  private startAutomaticCleanup(): void {\n    // Clean up old task logs every 6 hours\n    setInterval(() => {\n      this.cleanupOldTaskLogs();\n    }, 6 * 60 * 60 * 1000);\n  }\n\n  /**\n   * Clean up old task logs to prevent memory overflow\n   */\n  private cleanupOldTaskLogs(): void {\n    const cutoffDate = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000); // 7 days ago\n    const logsToDelete: string[] = [];\n\n    for (const [id, log] of this.taskLogs.entries()) {\n      if (log.createdAt < cutoffDate) {\n        logsToDelete.push(id);\n      }\n    }\n\n    // Keep only recent logs if we're over the limit\n    if (this.taskLogs.size > this.MAX_TASK_LOGS) {\n      const sortedLogs = Array.from(this.taskLogs.entries())\n        .sort(([,a], [,b]) => b.createdAt.getTime() - a.createdAt.getTime());\n      \n      const toDelete = sortedLogs.slice(this.MAX_TASK_LOGS);\n      toDelete.forEach(([id]) => logsToDelete.push(id));\n    }\n\n    // Delete old logs\n    logsToDelete.forEach(id => {\n      this.taskLogs.delete(id);\n      this.rollbackCapabilities.delete(id);\n    });\n\n    if (logsToDelete.length > 0) {\n      logger.info('Cleaned up old task logs', { \n        deletedCount: logsToDelete.length,\n        remainingCount: this.taskLogs.size\n      });\n    }\n  }\n\n  /**\n   * Persist task log to database\n   */\n  private async persistTaskLog(taskLog: ComprehensiveTaskLog): Promise<void> {\n    try {\n      await prisma.taskExecution.upsert({\n        where: { id: taskLog.id },\n        update: {\n          status: taskLog.status,\n          executionTime: taskLog.executionTime,\n          result: taskLog.result,\n          warnings: taskLog.warnings,\n          errors: taskLog.errors,\n          auditTrail: taskLog.auditTrail,\n          rollbackData: taskLog.rollbackData,\n          rollbackPerformed: taskLog.rollbackPerformed,\n          rollbackReason: taskLog.rollbackReason,\n          completedAt: taskLog.completedAt\n        },\n        create: {\n          id: taskLog.id,\n          taskId: taskLog.taskId,\n          userId: taskLog.userId,\n          taskType: taskLog.taskType,\n          description: taskLog.description,\n          status: taskLog.status,\n          riskLevel: taskLog.riskLevel,\n          executionTime: taskLog.executionTime,\n          parameters: taskLog.parameters,\n          result: taskLog.result,\n          warnings: taskLog.warnings,\n          errors: taskLog.errors,\n          auditTrail: taskLog.auditTrail,\n          rollbackData: taskLog.rollbackData,\n          rollbackPerformed: taskLog.rollbackPerformed,\n          rollbackReason: taskLog.rollbackReason,\n          approvalId: taskLog.approvalId,\n          createdAt: taskLog.createdAt,\n          completedAt: taskLog.completedAt\n        }\n      });\n    } catch (error) {\n      logger.warn('Failed to persist task log to database', { \n        executionId: taskLog.id,\n        error: error instanceof Error ? error.message : String(error)\n      });\n    }\n  }\n\n  /**\n   * Get overall system metrics\n   */\n  getOverallMetrics(): Record<string, TaskExecutionMetrics> {\n    const result: Record<string, TaskExecutionMetrics> = {};\n    \n    for (const taskType of this.metrics.keys()) {\n      result[taskType] = this.getMetrics(taskType);\n    }\n\n    return result;\n  }\n\n  /**\n   * Get health status of task execution system\n   */\n  getHealthStatus(): {\n    status: 'healthy' | 'warning' | 'critical';\n    issues: string[];\n    recommendations: string[];\n  } {\n    const overall = this.getOverallMetrics();\n    const issues: string[] = [];\n    const recommendations: string[] = [];\n    \n    let totalAttempts = 0;\n    let totalSuccessful = 0;\n    \n    for (const [taskType, metrics] of Object.entries(overall)) {\n      totalAttempts += metrics.totalAttempts;\n      totalSuccessful += metrics.successfulExecutions;\n      \n      // Check for issues\n      if (metrics.successRate < 70 && metrics.totalAttempts > 10) {\n        issues.push(`Low success rate for ${taskType}: ${metrics.successRate.toFixed(1)}%`);\n        recommendations.push(`Review ${taskType} implementation and error handling`);\n      }\n      \n      if (metrics.avgExecutionTime > 5000) { // 5 seconds\n        issues.push(`Slow execution for ${taskType}: ${metrics.avgExecutionTime.toFixed(0)}ms`);\n        recommendations.push(`Optimize ${taskType} performance`);\n      }\n    }\n\n    const overallSuccessRate = totalAttempts > 0 ? (totalSuccessful / totalAttempts) * 100 : 100;\n    \n    let status: 'healthy' | 'warning' | 'critical' = 'healthy';\n    if (overallSuccessRate < 50) {\n      status = 'critical';\n    } else if (overallSuccessRate < 80 || issues.length > 2) {\n      status = 'warning';\n    }\n\n    return {\n      status,\n      issues,\n      recommendations\n    };\n  }\n\n  /**\n   * Persist metrics to database for long-term storage\n   */\n  private async persistMetrics(event: TaskExecutionEvent): Promise<void> {\n    try {\n      await prisma.userActivity.create({\n        data: {\n          userId: event.userId,\n          type: 'ai_task_execution',\n          channel: 'AI',\n          timestamp: event.timestamp,\n          metadata: {\n            taskType: event.taskType,\n            userRole: event.userRole,\n            success: event.success,\n            executionTime: event.executionTime,\n            errorType: event.errorType,\n            errorMessage: event.errorMessage\n          }\n        }\n      });\n    } catch (error) {\n      // Don't throw - this is just for metrics collection\n      logger.warn('Failed to persist task execution metrics to database', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n    }\n  }\n\n  /**\n   * Clear old metrics (for memory management)\n   */\n  clearOldMetrics(olderThanHours = 24): void {\n    const cutoff = new Date(Date.now() - olderThanHours * 60 * 60 * 1000);\n    \n    for (const [taskType, events] of this.metrics.entries()) {\n      const filtered = events.filter(e => e.timestamp > cutoff);\n      this.metrics.set(taskType, filtered);\n    }\n    \n    logger.info('Cleared old task execution metrics', { \n      cutoffHours: olderThanHours,\n      remainingTaskTypes: this.metrics.size \n    });\n  }\n}\n\n// Export singleton instance\nexport const taskExecutionMonitor = new TaskExecutionMonitor();\n\n// Export helper function to record task execution\nexport function recordTaskExecution(\n  taskType: string,\n  userId: string,\n  userRole: string,\n  success: boolean,\n  executionTime: number,\n  errorType?: string,\n  errorMessage?: string\n): void {\n  taskExecutionMonitor.recordExecution({\n    taskType,\n    userId,\n    userRole,\n    success,\n    executionTime,\n    errorType,\n    errorMessage,\n    timestamp: new Date()\n  });\n}\n\n// Export types\nexport type { TaskExecutionMetrics, TaskExecutionEvent };"],"names":["recordTaskExecution","taskExecutionMonitor","TaskExecutionMonitor","constructor","metrics","Map","taskLogs","rollbackCapabilities","MAX_EVENTS_PER_TYPE","MAX_TASK_LOGS","performanceBuffer","hourly","Array","fill","daily","weekly","startPerformanceTrendTracking","startAutomaticCleanup","startTaskExecution","taskId","userId","userRole","taskType","description","parameters","riskLevel","securityContext","approvalId","executionId","Date","now","Math","random","toString","substr","taskLog","id","substring","status","executionTime","result","warnings","errors","auditTrail","toISOString","approvalRequired","createdAt","set","updatePerformanceTrends","persistTaskLog","logger","info","recordExecution","event","events","get","push","length","splice","success","errorType","rollbackPerformed","timestamp","persistMetrics","catch","error","warn","message","completeTaskExecution","rollbackData","getTime","completedAt","createRollbackCapability","rollbackAvailable","failTaskExecution","errorMessage","performRollback","rollbackReason","rollbackUserId","rollbackCapability","available","strategy","step","steps","Promise","resolve","setTimeout","Error","getMetrics","totalAttempts","successfulExecutions","failedExecutions","successRate","avgExecutionTime","commonErrors","userRoleStats","rollbackRate","approvalRequiredRate","riskDistribution","performanceTrends","successful","filter","e","failed","rolledBack","totalTime","reduce","sum","errorCounts","forEach","roleStats","Object","entries","sort","a","b","slice","map","getTaskLog","getUserTaskLogs","limit","logs","from","values","log","getRollbackCapability","getRollbackCandidates","candidates","capability","determineRollbackStrategy","generateRollbackSteps","timeLimit","getRollbackTimeLimit","dependencies","getRollbackDependencies","current","limits","low","medium","high","critical","segmentation","campaign_optimization","integration_config","data_analysis","reporting","increment","hourIndex","getHours","dayIndex","getDate","weekIndex","floor","getFullYear","setInterval","cleanupOldTaskLogs","cutoffDate","logsToDelete","size","sortedLogs","toDelete","delete","deletedCount","remainingCount","prisma","taskExecution","upsert","where","update","create","String","getOverallMetrics","keys","getHealthStatus","overall","issues","recommendations","totalSuccessful","toFixed","overallSuccessRate","userActivity","data","type","channel","metadata","clearOldMetrics","olderThanHours","cutoff","filtered","cutoffHours","remainingTaskTypes"],"mappings":"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"}