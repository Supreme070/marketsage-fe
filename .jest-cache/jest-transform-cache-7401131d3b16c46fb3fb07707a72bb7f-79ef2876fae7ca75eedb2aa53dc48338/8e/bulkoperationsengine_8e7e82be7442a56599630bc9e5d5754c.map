{"version":3,"sources":["/Users/supreme/Desktop/marketsage/src/lib/ai/bulk-operations-engine.ts"],"sourcesContent":["/**\n * Bulk Operations AI Engine\n * ========================\n * Intelligent system for handling mass contact, campaign, and data operations\n * Optimizes performance and provides progress tracking for large-scale operations\n */\n\nimport { logger } from '@/lib/logger';\nimport prisma from '@/lib/db/prisma';\nimport { TransactionManager, withTransaction } from '@/lib/security/transaction-manager';\nimport { AuthorizationService, Permission } from '@/lib/security/authorization';\nimport { validationSchemas, validateRequest } from '@/lib/security/input-validation';\nimport { rateLimiters } from '@/lib/security/rate-limiter';\nimport { z } from 'zod';\n\nexport interface BulkOperation {\n  id: string;\n  type: 'contact_import' | 'contact_export' | 'contact_update' | 'contact_delete' | \n        'campaign_send' | 'campaign_schedule' | 'list_operations' | 'tag_operations' |\n        'segment_operations' | 'workflow_operations';\n  status: 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled' | 'paused';\n  progress: {\n    total: number;\n    processed: number;\n    successful: number;\n    failed: number;\n    percentage: number;\n  };\n  batchSize: number;\n  estimatedTime: number; // seconds\n  startedAt?: Date;\n  completedAt?: Date;\n  errors: BulkOperationError[];\n  metadata: Record<string, any>;\n  userId: string;\n  organizationId: string;\n}\n\nexport interface BulkOperationError {\n  id: string;\n  batchIndex: number;\n  recordId?: string;\n  error: string;\n  timestamp: Date;\n  retryable: boolean;\n}\n\nexport interface BulkOperationRequest {\n  type: BulkOperation['type'];\n  data: any[];\n  options: {\n    batchSize?: number;\n    continueOnError?: boolean;\n    validateData?: boolean;\n    dryRun?: boolean;\n    priority?: 'low' | 'normal' | 'high';\n    scheduleAt?: Date;\n    notifyOnComplete?: boolean;\n  };\n  filters?: Record<string, any>;\n  transformations?: BulkTransformation[];\n}\n\nexport interface BulkTransformation {\n  field: string;\n  operation: 'map' | 'filter' | 'validate' | 'enrich' | 'deduplicate';\n  parameters: Record<string, any>;\n}\n\nexport interface BulkOperationResult {\n  success: boolean;\n  operationId: string;\n  summary: {\n    totalRecords: number;\n    successfulRecords: number;\n    failedRecords: number;\n    skippedRecords: number;\n    duplicatesFound: number;\n    executionTime: number;\n  };\n  errors: BulkOperationError[];\n  data?: any[];\n}\n\n// Validation schemas for bulk operations\nconst bulkOperationSchemas = {\n  contactImport: z.object({\n    data: z.array(z.object({\n      firstName: z.string().min(1, 'First name required'),\n      lastName: z.string().min(1, 'Last name required'),\n      email: z.string().email('Invalid email'),\n      phone: z.string().optional(),\n      company: z.string().optional(),\n      jobTitle: z.string().optional(),\n      tags: z.array(z.string()).optional(),\n      customFields: z.record(z.any()).optional(),\n      listIds: z.array(z.string()).optional()\n    })).min(1, 'At least one contact required').max(10000, 'Too many contacts'),\n    options: z.object({\n      batchSize: z.number().min(1).max(1000).default(100),\n      continueOnError: z.boolean().default(true),\n      validateData: z.boolean().default(true),\n      dryRun: z.boolean().default(false),\n      deduplicateBy: z.enum(['email', 'phone', 'email+phone']).default('email')\n    })\n  }),\n\n  contactUpdate: z.object({\n    filters: z.object({\n      contactIds: z.array(z.string()).optional(),\n      listIds: z.array(z.string()).optional(),\n      tags: z.array(z.string()).optional(),\n      segmentIds: z.array(z.string()).optional(),\n      createdAfter: z.coerce.date().optional(),\n      createdBefore: z.coerce.date().optional()\n    }).refine(data => Object.values(data).some(val => val !== undefined), 'At least one filter required'),\n    updates: z.object({\n      tags: z.array(z.string()).optional(),\n      customFields: z.record(z.any()).optional(),\n      isActive: z.boolean().optional(),\n      addToLists: z.array(z.string()).optional(),\n      removeFromLists: z.array(z.string()).optional()\n    }),\n    options: z.object({\n      batchSize: z.number().min(1).max(1000).default(100),\n      continueOnError: z.boolean().default(true),\n      dryRun: z.boolean().default(false)\n    })\n  }),\n\n  campaignSend: z.object({\n    campaignId: z.string().min(1, 'Campaign ID required'),\n    recipients: z.object({\n      type: z.enum(['all', 'lists', 'segments', 'contacts']),\n      ids: z.array(z.string()).optional(),\n      filters: z.record(z.any()).optional()\n    }),\n    options: z.object({\n      batchSize: z.number().min(1).max(1000).default(100),\n      delayBetweenBatches: z.number().min(0).max(300).default(5), // seconds\n      testMode: z.boolean().default(false),\n      scheduleAt: z.coerce.date().optional()\n    })\n  })\n};\n\nexport class BulkOperationsEngine {\n  private activeOperations = new Map<string, BulkOperation>();\n  private operationQueue: string[] = [];\n  private isProcessing = false;\n  private maxConcurrentOperations = 3;\n\n  constructor() {\n    this.startProcessor();\n    this.startCleanup();\n  }\n\n  /**\n   * Execute bulk contact import\n   */\n  async executeContactImport(\n    request: BulkOperationRequest,\n    userId: string,\n    userRole: string,\n    organizationId: string\n  ): Promise<BulkOperationResult> {\n    // Validate permissions\n    const authResult = await AuthorizationService.validateBulkOperation(\n      userId,\n      userRole as any,\n      organizationId,\n      Permission.BULK_CONTACT_OPERATIONS,\n      request.data.length\n    );\n\n    if (!authResult.allowed) {\n      throw new Error(authResult.reason || 'Bulk operation not allowed');\n    }\n\n    // Validate input\n    const validation = validateRequest(\n      bulkOperationSchemas.contactImport,\n      request,\n      'contact_import'\n    );\n\n    if (!validation.success) {\n      throw new Error(`Validation failed: ${validation.errors?.join(', ')}`);\n    }\n\n    const validatedRequest = validation.data!;\n\n    // Check rate limits\n    const rateLimitResult = rateLimiters.api.check(userId, '/bulk/contact-import');\n    if (!rateLimitResult.allowed) {\n      throw new Error('Rate limit exceeded for bulk operations');\n    }\n\n    // Create operation\n    const operationId = await this.createOperation({\n      type: 'contact_import',\n      data: validatedRequest.data,\n      options: validatedRequest.options,\n      userId,\n      organizationId\n    });\n\n    // Execute operation\n    if (validatedRequest.options.dryRun) {\n      return await this.executeDryRun(operationId, 'contact_import', validatedRequest);\n    } else {\n      this.queueOperation(operationId);\n      return { \n        success: true, \n        operationId,\n        summary: {\n          totalRecords: validatedRequest.data.length,\n          successfulRecords: 0,\n          failedRecords: 0,\n          skippedRecords: 0,\n          duplicatesFound: 0,\n          executionTime: 0\n        },\n        errors: []\n      };\n    }\n  }\n\n  /**\n   * Execute bulk contact update\n   */\n  async executeContactUpdate(\n    request: BulkOperationRequest,\n    userId: string,\n    userRole: string,\n    organizationId: string\n  ): Promise<BulkOperationResult> {\n    // Validate permissions\n    const canUpdate = AuthorizationService.hasPermission(\n      userRole as any,\n      Permission.BULK_CONTACT_OPERATIONS\n    );\n\n    if (!canUpdate) {\n      throw new Error('Insufficient permissions for bulk contact updates');\n    }\n\n    // Validate input\n    const validation = validateRequest(\n      bulkOperationSchemas.contactUpdate,\n      request,\n      'contact_update'\n    );\n\n    if (!validation.success) {\n      throw new Error(`Validation failed: ${validation.errors?.join(', ')}`);\n    }\n\n    const validatedRequest = validation.data!;\n\n    // Get matching contacts count first\n    const contactCount = await this.getContactCount(validatedRequest.filters, organizationId);\n    \n    // Check bulk operation limits\n    const authResult = await AuthorizationService.validateBulkOperation(\n      userId,\n      userRole as any,\n      organizationId,\n      Permission.BULK_CONTACT_OPERATIONS,\n      contactCount\n    );\n\n    if (!authResult.allowed) {\n      throw new Error(authResult.reason || 'Bulk operation limit exceeded');\n    }\n\n    // Create operation\n    const operationId = await this.createOperation({\n      type: 'contact_update',\n      filters: validatedRequest.filters,\n      data: [validatedRequest.updates],\n      options: validatedRequest.options,\n      userId,\n      organizationId\n    });\n\n    // Execute operation\n    if (validatedRequest.options.dryRun) {\n      return await this.executeDryRun(operationId, 'contact_update', validatedRequest);\n    } else {\n      this.queueOperation(operationId);\n      return { \n        success: true, \n        operationId,\n        summary: {\n          totalRecords: contactCount,\n          successfulRecords: 0,\n          failedRecords: 0,\n          skippedRecords: 0,\n          duplicatesFound: 0,\n          executionTime: 0\n        },\n        errors: []\n      };\n    }\n  }\n\n  /**\n   * Execute bulk campaign sending\n   */\n  async executeCampaignSend(\n    request: BulkOperationRequest,\n    userId: string,\n    userRole: string,\n    organizationId: string\n  ): Promise<BulkOperationResult> {\n    // Validate permissions\n    const canSend = AuthorizationService.hasAllPermissions(\n      userRole as any,\n      [Permission.SEND_CAMPAIGN, Permission.BULK_CONTACT_OPERATIONS]\n    );\n\n    if (!canSend) {\n      throw new Error('Insufficient permissions for bulk campaign sending');\n    }\n\n    // Validate input\n    const validation = validateRequest(\n      bulkOperationSchemas.campaignSend,\n      request,\n      'campaign_send'\n    );\n\n    if (!validation.success) {\n      throw new Error(`Validation failed: ${validation.errors?.join(', ')}`);\n    }\n\n    const validatedRequest = validation.data!;\n\n    // Verify campaign exists and user has access\n    const campaign = await prisma.emailCampaign.findFirst({\n      where: {\n        id: validatedRequest.campaignId,\n        organizationId,\n        status: 'DRAFT'\n      }\n    });\n\n    if (!campaign) {\n      throw new Error('Campaign not found or not in draft status');\n    }\n\n    // Get recipient count\n    const recipientCount = await this.getRecipientCount(\n      validatedRequest.recipients,\n      organizationId\n    );\n\n    // Check sending limits\n    const authResult = await AuthorizationService.validateBulkOperation(\n      userId,\n      userRole as any,\n      organizationId,\n      Permission.SEND_CAMPAIGN,\n      recipientCount\n    );\n\n    if (!authResult.allowed) {\n      throw new Error(authResult.reason || 'Campaign sending limit exceeded');\n    }\n\n    // Create operation\n    const operationId = await this.createOperation({\n      type: 'campaign_send',\n      data: [validatedRequest],\n      options: validatedRequest.options,\n      userId,\n      organizationId\n    });\n\n    // Schedule or queue operation\n    if (validatedRequest.options.scheduleAt) {\n      await this.scheduleOperation(operationId, validatedRequest.options.scheduleAt);\n    } else {\n      this.queueOperation(operationId);\n    }\n\n    return { \n      success: true, \n      operationId,\n      summary: {\n        totalRecords: recipientCount,\n        successfulRecords: 0,\n        failedRecords: 0,\n        skippedRecords: 0,\n        duplicatesFound: 0,\n        executionTime: 0\n      },\n      errors: []\n    };\n  }\n\n  /**\n   * Get operation status\n   */\n  getOperationStatus(operationId: string): BulkOperation | null {\n    return this.activeOperations.get(operationId) || null;\n  }\n\n  /**\n   * Cancel operation\n   */\n  async cancelOperation(\n    operationId: string,\n    userId: string,\n    userRole: string\n  ): Promise<boolean> {\n    const operation = this.activeOperations.get(operationId);\n    \n    if (!operation) {\n      return false;\n    }\n\n    // Check if user can cancel this operation\n    if (operation.userId !== userId && userRole !== 'SUPER_ADMIN') {\n      throw new Error('Cannot cancel operation - insufficient permissions');\n    }\n\n    if (operation.status === 'processing') {\n      operation.status = 'cancelled';\n      logger.info('Bulk operation cancelled', {\n        operationId,\n        userId,\n        type: operation.type,\n        progress: operation.progress\n      });\n    }\n\n    return true;\n  }\n\n  /**\n   * Create new bulk operation\n   */\n  private async createOperation(request: BulkOperationRequest & {\n    userId: string;\n    organizationId: string;\n  }): Promise<string> {\n    const operationId = `bulk_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    const dataLength = Array.isArray(request.data) ? request.data.length : \n                     request.filters ? await this.getFilteredCount(request.filters, request.organizationId) : 0;\n\n    const operation: BulkOperation = {\n      id: operationId,\n      type: request.type,\n      status: 'pending',\n      progress: {\n        total: dataLength,\n        processed: 0,\n        successful: 0,\n        failed: 0,\n        percentage: 0\n      },\n      batchSize: request.options.batchSize || 100,\n      estimatedTime: this.estimateExecutionTime(request.type, dataLength),\n      errors: [],\n      metadata: {\n        options: request.options,\n        filters: request.filters,\n        transformations: request.transformations\n      },\n      userId: request.userId,\n      organizationId: request.organizationId\n    };\n\n    this.activeOperations.set(operationId, operation);\n\n    logger.info('Bulk operation created', {\n      operationId,\n      type: request.type,\n      userId: request.userId,\n      totalRecords: dataLength,\n      estimatedTime: operation.estimatedTime\n    });\n\n    return operationId;\n  }\n\n  /**\n   * Queue operation for processing\n   */\n  private queueOperation(operationId: string): void {\n    this.operationQueue.push(operationId);\n    this.processQueue();\n  }\n\n  /**\n   * Process operation queue\n   */\n  private async processQueue(): Promise<void> {\n    if (this.isProcessing || this.operationQueue.length === 0) {\n      return;\n    }\n\n    this.isProcessing = true;\n\n    try {\n      const activeCount = Array.from(this.activeOperations.values())\n        .filter(op => op.status === 'processing').length;\n\n      if (activeCount >= this.maxConcurrentOperations) {\n        this.isProcessing = false;\n        return;\n      }\n\n      const operationId = this.operationQueue.shift();\n      if (operationId) {\n        await this.executeOperation(operationId);\n      }\n    } finally {\n      this.isProcessing = false;\n      \n      // Continue processing if there are more operations\n      if (this.operationQueue.length > 0) {\n        setTimeout(() => this.processQueue(), 1000);\n      }\n    }\n  }\n\n  /**\n   * Execute a specific operation\n   */\n  private async executeOperation(operationId: string): Promise<void> {\n    const operation = this.activeOperations.get(operationId);\n    if (!operation) {\n      return;\n    }\n\n    operation.status = 'processing';\n    operation.startedAt = new Date();\n\n    try {\n      switch (operation.type) {\n        case 'contact_import':\n          await this.processContactImport(operation);\n          break;\n        case 'contact_update':\n          await this.processContactUpdate(operation);\n          break;\n        case 'campaign_send':\n          await this.processCampaignSend(operation);\n          break;\n        default:\n          throw new Error(`Unsupported operation type: ${operation.type}`);\n      }\n\n      operation.status = 'completed';\n      operation.completedAt = new Date();\n\n      logger.info('Bulk operation completed', {\n        operationId,\n        type: operation.type,\n        executionTime: Date.now() - (operation.startedAt?.getTime() || 0),\n        summary: operation.progress\n      });\n\n    } catch (error) {\n      operation.status = 'failed';\n      operation.completedAt = new Date();\n      \n      const errorMessage = error instanceof Error ? error.message : String(error);\n      operation.errors.push({\n        id: `err_${Date.now()}`,\n        batchIndex: -1,\n        error: errorMessage,\n        timestamp: new Date(),\n        retryable: false\n      });\n\n      logger.error('Bulk operation failed', {\n        operationId,\n        type: operation.type,\n        error: errorMessage,\n        progress: operation.progress\n      });\n    }\n  }\n\n  /**\n   * Process contact import operation\n   */\n  private async processContactImport(operation: BulkOperation): Promise<void> {\n    const contacts = operation.metadata.data || [];\n    const options = operation.metadata.options || {};\n    \n    // Process in batches\n    for (let i = 0; i < contacts.length; i += operation.batchSize) {\n      if (operation.status === 'cancelled') {\n        break;\n      }\n\n      const batch = contacts.slice(i, i + operation.batchSize);\n      \n      try {\n        await withTransaction(\n          operation.userId,\n          operation.id,\n          `Contact import batch ${Math.floor(i / operation.batchSize) + 1}`,\n          async (transactionId) => {\n            await this.processBatchContactImport(batch, operation, transactionId);\n          }\n        );\n\n        operation.progress.processed += batch.length;\n        operation.progress.successful += batch.length;\n        \n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        \n        if (options.continueOnError) {\n          operation.progress.processed += batch.length;\n          operation.progress.failed += batch.length;\n          \n          operation.errors.push({\n            id: `err_${Date.now()}`,\n            batchIndex: Math.floor(i / operation.batchSize),\n            error: errorMessage,\n            timestamp: new Date(),\n            retryable: true\n          });\n        } else {\n          throw error;\n        }\n      }\n\n      // Update progress\n      operation.progress.percentage = Math.round(\n        (operation.progress.processed / operation.progress.total) * 100\n      );\n\n      // Small delay between batches to prevent overwhelming the system\n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n  }\n\n  /**\n   * Process single batch of contact imports\n   */\n  private async processBatchContactImport(\n    contacts: any[],\n    operation: BulkOperation,\n    transactionId: string\n  ): Promise<void> {\n    const deduplicatedContacts = this.deduplicateContacts(contacts);\n    \n    for (const contact of deduplicatedContacts) {\n      await TransactionManager.executeStep(\n        transactionId,\n        `import_contact_${contact.email}`,\n        'CREATE',\n        'CONTACT',\n        async (tx) => {\n          return await tx.contact.create({\n            data: {\n              firstName: contact.firstName,\n              lastName: contact.lastName,\n              email: contact.email,\n              phone: contact.phone,\n              company: contact.company,\n              jobTitle: contact.jobTitle,\n              tags: contact.tags || [],\n              customFields: contact.customFields || {},\n              organizationId: operation.organizationId,\n              createdById: operation.userId,\n              isActive: true\n            }\n          });\n        }\n      );\n    }\n  }\n\n  /**\n   * Deduplicate contacts based on criteria\n   */\n  private deduplicateContacts(contacts: any[]): any[] {\n    const seen = new Set<string>();\n    const deduplicated: any[] = [];\n\n    for (const contact of contacts) {\n      const key = contact.email.toLowerCase();\n      \n      if (!seen.has(key)) {\n        seen.add(key);\n        deduplicated.push(contact);\n      }\n    }\n\n    return deduplicated;\n  }\n\n  /**\n   * Helper functions for counting records\n   */\n  private async getContactCount(filters: any, organizationId: string): Promise<number> {\n    const whereClause = this.buildContactWhereClause(filters, organizationId);\n    return await prisma.contact.count({ where: whereClause });\n  }\n\n  private async getRecipientCount(recipients: any, organizationId: string): Promise<number> {\n    switch (recipients.type) {\n      case 'all':\n        return await prisma.contact.count({ \n          where: { organizationId, isActive: true }\n        });\n      case 'lists':\n        return await prisma.contact.count({\n          where: {\n            organizationId,\n            isActive: true,\n            lists: {\n              some: {\n                id: { in: recipients.ids }\n              }\n            }\n          }\n        });\n      case 'contacts':\n        return recipients.ids?.length || 0;\n      default:\n        return 0;\n    }\n  }\n\n  private buildContactWhereClause(filters: any, organizationId: string): any {\n    const where: any = { organizationId };\n\n    if (filters.contactIds) {\n      where.id = { in: filters.contactIds };\n    }\n\n    if (filters.tags && filters.tags.length > 0) {\n      where.tags = { hasSome: filters.tags };\n    }\n\n    if (filters.createdAfter) {\n      where.createdAt = { ...where.createdAt, gte: filters.createdAfter };\n    }\n\n    if (filters.createdBefore) {\n      where.createdAt = { ...where.createdAt, lte: filters.createdBefore };\n    }\n\n    return where;\n  }\n\n  private async getFilteredCount(filters: any, organizationId: string): Promise<number> {\n    return await this.getContactCount(filters, organizationId);\n  }\n\n  private estimateExecutionTime(type: string, recordCount: number): number {\n    const timePerRecord = {\n      'contact_import': 0.5, // seconds per contact\n      'contact_update': 0.2,\n      'campaign_send': 1.0,\n      'contact_export': 0.1\n    };\n\n    return Math.ceil(recordCount * (timePerRecord[type] || 0.5));\n  }\n\n  /**\n   * Execute dry run to preview operation results\n   */\n  private async executeDryRun(\n    operationId: string,\n    type: string,\n    request: any\n  ): Promise<BulkOperationResult> {\n    // Simulate operation without making changes\n    const totalRecords = Array.isArray(request.data) ? request.data.length : 0;\n    \n    return {\n      success: true,\n      operationId,\n      summary: {\n        totalRecords,\n        successfulRecords: Math.floor(totalRecords * 0.95),\n        failedRecords: Math.floor(totalRecords * 0.05),\n        skippedRecords: 0,\n        duplicatesFound: Math.floor(totalRecords * 0.1),\n        executionTime: 0\n      },\n      errors: [],\n      data: request.data?.slice(0, 10) // Return first 10 records as preview\n    };\n  }\n\n  /**\n   * Additional operation processing methods would be implemented here\n   */\n  private async processContactUpdate(operation: BulkOperation): Promise<void> {\n    // Implementation for bulk contact updates\n  }\n\n  private async processCampaignSend(operation: BulkOperation): Promise<void> {\n    // Implementation for bulk campaign sending\n  }\n\n  private async scheduleOperation(operationId: string, scheduleAt: Date): Promise<void> {\n    // Implementation for scheduling operations\n  }\n\n  /**\n   * Start background processor\n   */\n  private startProcessor(): void {\n    // Process queue every 5 seconds\n    setInterval(() => {\n      this.processQueue();\n    }, 5000);\n  }\n\n  /**\n   * Start cleanup process\n   */\n  private startCleanup(): void {\n    // Clean up completed operations every hour\n    setInterval(() => {\n      this.cleanupCompletedOperations();\n    }, 60 * 60 * 1000);\n  }\n\n  private cleanupCompletedOperations(): void {\n    const cutoff = Date.now() - (24 * 60 * 60 * 1000); // 24 hours ago\n    let cleaned = 0;\n\n    for (const [operationId, operation] of this.activeOperations) {\n      if (operation.status === 'completed' || operation.status === 'failed') {\n        const completedTime = operation.completedAt?.getTime() || 0;\n        if (completedTime < cutoff) {\n          this.activeOperations.delete(operationId);\n          cleaned++;\n        }\n      }\n    }\n\n    if (cleaned > 0) {\n      logger.info('Bulk operations cleanup completed', {\n        operationsRemoved: cleaned,\n        remainingOperations: this.activeOperations.size\n      });\n    }\n  }\n}\n\n// Export singleton instance\nexport const bulkOperationsEngine = new BulkOperationsEngine();"],"names":["BulkOperationsEngine","bulkOperationsEngine","bulkOperationSchemas","contactImport","z","object","data","array","firstName","string","min","lastName","email","phone","optional","company","jobTitle","tags","customFields","record","any","listIds","max","options","batchSize","number","default","continueOnError","boolean","validateData","dryRun","deduplicateBy","enum","contactUpdate","filters","contactIds","segmentIds","createdAfter","coerce","date","createdBefore","refine","Object","values","some","val","undefined","updates","isActive","addToLists","removeFromLists","campaignSend","campaignId","recipients","type","ids","delayBetweenBatches","testMode","scheduleAt","constructor","activeOperations","Map","operationQueue","isProcessing","maxConcurrentOperations","startProcessor","startCleanup","executeContactImport","request","userId","userRole","organizationId","authResult","AuthorizationService","validateBulkOperation","Permission","BULK_CONTACT_OPERATIONS","length","allowed","Error","reason","validation","validateRequest","success","errors","join","validatedRequest","rateLimitResult","rateLimiters","api","check","operationId","createOperation","executeDryRun","queueOperation","summary","totalRecords","successfulRecords","failedRecords","skippedRecords","duplicatesFound","executionTime","executeContactUpdate","canUpdate","hasPermission","contactCount","getContactCount","executeCampaignSend","canSend","hasAllPermissions","SEND_CAMPAIGN","campaign","prisma","emailCampaign","findFirst","where","id","status","recipientCount","getRecipientCount","scheduleOperation","getOperationStatus","get","cancelOperation","operation","logger","info","progress","Date","now","Math","random","toString","substr","dataLength","Array","isArray","getFilteredCount","total","processed","successful","failed","percentage","estimatedTime","estimateExecutionTime","metadata","transformations","set","push","processQueue","activeCount","from","filter","op","shift","executeOperation","setTimeout","startedAt","processContactImport","processContactUpdate","processCampaignSend","completedAt","getTime","error","errorMessage","message","String","batchIndex","timestamp","retryable","contacts","i","batch","slice","withTransaction","floor","transactionId","processBatchContactImport","round","Promise","resolve","deduplicatedContacts","deduplicateContacts","contact","TransactionManager","executeStep","tx","create","createdById","seen","Set","deduplicated","key","toLowerCase","has","add","whereClause","buildContactWhereClause","count","lists","in","hasSome","createdAt","gte","lte","recordCount","timePerRecord","ceil","setInterval","cleanupCompletedOperations","cutoff","cleaned","completedTime","delete","operationsRemoved","remainingOperations","size"],"mappings":"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"}