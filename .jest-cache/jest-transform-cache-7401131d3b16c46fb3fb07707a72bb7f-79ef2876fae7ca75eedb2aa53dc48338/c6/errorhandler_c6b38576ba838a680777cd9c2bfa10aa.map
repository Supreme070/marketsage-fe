{"version":3,"sources":["/Users/supreme/Desktop/marketsage/src/lib/leadpulse/error-handler.ts"],"sourcesContent":["/**\n * LeadPulse Error Handling & Reliability System\n * \n * Provides comprehensive error handling, fallbacks, and reliability features\n * for production-ready LeadPulse operations\n */\n\nimport { logger } from '@/lib/logger';\nimport { redis } from '@/lib/cache/redis';\n\n// Error types for LeadPulse\nexport enum LeadPulseErrorType {\n  TRACKING_ERROR = 'tracking_error',\n  DATABASE_ERROR = 'database_error',\n  CACHE_ERROR = 'cache_error',\n  WEBSOCKET_ERROR = 'websocket_error',\n  VALIDATION_ERROR = 'validation_error',\n  RATE_LIMIT_ERROR = 'rate_limit_error',\n  EXTERNAL_API_ERROR = 'external_api_error',\n  UNKNOWN_ERROR = 'unknown_error'\n}\n\n// Error severity levels\nexport enum ErrorSeverity {\n  LOW = 'low',\n  MEDIUM = 'medium',\n  HIGH = 'high',\n  CRITICAL = 'critical'\n}\n\n// Error context interface\nexport interface ErrorContext {\n  userId?: string;\n  visitorId?: string;\n  fingerprint?: string;\n  url?: string;\n  userAgent?: string;\n  ip?: string;\n  timestamp: Date;\n  endpoint?: string;\n  method?: string;\n  additionalData?: Record<string, any>;\n}\n\n// Error record interface\nexport interface ErrorRecord {\n  id: string;\n  type: LeadPulseErrorType;\n  severity: ErrorSeverity;\n  message: string;\n  stack?: string;\n  context: ErrorContext;\n  resolved: boolean;\n  retryCount: number;\n  maxRetries: number;\n  createdAt: Date;\n  resolvedAt?: Date;\n}\n\nexport class LeadPulseErrorHandler {\n  private static instance: LeadPulseErrorHandler;\n  private errorQueue: ErrorRecord[] = [];\n  private maxQueueSize = 1000;\n  private retryIntervals = [1000, 3000, 10000, 30000, 60000]; // Progressive backoff\n\n  static getInstance(): LeadPulseErrorHandler {\n    if (!LeadPulseErrorHandler.instance) {\n      LeadPulseErrorHandler.instance = new LeadPulseErrorHandler();\n    }\n    return LeadPulseErrorHandler.instance;\n  }\n\n  constructor() {\n    this.startErrorProcessor();\n  }\n\n  // Handle and classify errors\n  async handleError(\n    error: Error | unknown,\n    context: Partial<ErrorContext> = {},\n    type?: LeadPulseErrorType\n  ): Promise<ErrorRecord> {\n    const errorRecord: ErrorRecord = {\n      id: this.generateErrorId(),\n      type: type || this.classifyError(error),\n      severity: this.determineSeverity(error, type),\n      message: error instanceof Error ? error.message : String(error),\n      stack: error instanceof Error ? error.stack : undefined,\n      context: {\n        timestamp: new Date(),\n        ...context\n      },\n      resolved: false,\n      retryCount: 0,\n      maxRetries: this.getMaxRetries(type || this.classifyError(error)),\n      createdAt: new Date()\n    };\n\n    // Log the error\n    this.logError(errorRecord);\n\n    // Store in error queue for processing\n    this.addToQueue(errorRecord);\n\n    // Store in cache for monitoring\n    await this.storeErrorInCache(errorRecord);\n\n    // Handle critical errors immediately\n    if (errorRecord.severity === ErrorSeverity.CRITICAL) {\n      await this.handleCriticalError(errorRecord);\n    }\n\n    return errorRecord;\n  }\n\n  // Classify error type based on error content\n  private classifyError(error: unknown): LeadPulseErrorType {\n    if (!error) return LeadPulseErrorType.UNKNOWN_ERROR;\n\n    const message = error instanceof Error ? error.message.toLowerCase() : String(error).toLowerCase();\n    const stack = error instanceof Error ? error.stack?.toLowerCase() : '';\n\n    if (message.includes('database') || message.includes('prisma') || message.includes('sql')) {\n      return LeadPulseErrorType.DATABASE_ERROR;\n    }\n\n    if (message.includes('redis') || message.includes('cache')) {\n      return LeadPulseErrorType.CACHE_ERROR;\n    }\n\n    if (message.includes('websocket') || message.includes('socket')) {\n      return LeadPulseErrorType.WEBSOCKET_ERROR;\n    }\n\n    if (message.includes('validation') || message.includes('invalid')) {\n      return LeadPulseErrorType.VALIDATION_ERROR;\n    }\n\n    if (message.includes('rate limit') || message.includes('too many requests')) {\n      return LeadPulseErrorType.RATE_LIMIT_ERROR;\n    }\n\n    if (message.includes('fetch') || message.includes('network') || message.includes('timeout')) {\n      return LeadPulseErrorType.EXTERNAL_API_ERROR;\n    }\n\n    if (stack?.includes('leadpulse') || stack?.includes('tracking')) {\n      return LeadPulseErrorType.TRACKING_ERROR;\n    }\n\n    return LeadPulseErrorType.UNKNOWN_ERROR;\n  }\n\n  // Determine error severity\n  private determineSeverity(error: unknown, type?: LeadPulseErrorType): ErrorSeverity {\n    const errorType = type || this.classifyError(error);\n    const message = error instanceof Error ? error.message.toLowerCase() : String(error).toLowerCase();\n\n    // Critical errors that affect core functionality\n    if (errorType === LeadPulseErrorType.DATABASE_ERROR && \n        (message.includes('connection') || message.includes('pool'))) {\n      return ErrorSeverity.CRITICAL;\n    }\n\n    if (message.includes('out of memory') || message.includes('disk full')) {\n      return ErrorSeverity.CRITICAL;\n    }\n\n    // High severity errors\n    if (errorType === LeadPulseErrorType.DATABASE_ERROR || \n        errorType === LeadPulseErrorType.WEBSOCKET_ERROR) {\n      return ErrorSeverity.HIGH;\n    }\n\n    // Medium severity errors\n    if (errorType === LeadPulseErrorType.CACHE_ERROR || \n        errorType === LeadPulseErrorType.EXTERNAL_API_ERROR) {\n      return ErrorSeverity.MEDIUM;\n    }\n\n    // Low severity errors\n    return ErrorSeverity.LOW;\n  }\n\n  // Get maximum retries based on error type\n  private getMaxRetries(type: LeadPulseErrorType): number {\n    const retryMap: Record<LeadPulseErrorType, number> = {\n      [LeadPulseErrorType.TRACKING_ERROR]: 3,\n      [LeadPulseErrorType.DATABASE_ERROR]: 2,\n      [LeadPulseErrorType.CACHE_ERROR]: 5,\n      [LeadPulseErrorType.WEBSOCKET_ERROR]: 3,\n      [LeadPulseErrorType.VALIDATION_ERROR]: 0, // Don't retry validation errors\n      [LeadPulseErrorType.RATE_LIMIT_ERROR]: 2,\n      [LeadPulseErrorType.EXTERNAL_API_ERROR]: 3,\n      [LeadPulseErrorType.UNKNOWN_ERROR]: 1\n    };\n\n    return retryMap[type] || 1;\n  }\n\n  // Log error with appropriate level\n  private logError(errorRecord: ErrorRecord): void {\n    const logData = {\n      errorId: errorRecord.id,\n      type: errorRecord.type,\n      severity: errorRecord.severity,\n      message: errorRecord.message,\n      context: errorRecord.context,\n      stack: errorRecord.stack\n    };\n\n    switch (errorRecord.severity) {\n      case ErrorSeverity.CRITICAL:\n        logger.error('CRITICAL LeadPulse Error:', logData);\n        break;\n      case ErrorSeverity.HIGH:\n        logger.error('HIGH severity LeadPulse Error:', logData);\n        break;\n      case ErrorSeverity.MEDIUM:\n        logger.warn('MEDIUM severity LeadPulse Error:', logData);\n        break;\n      case ErrorSeverity.LOW:\n        logger.info('LOW severity LeadPulse Error:', logData);\n        break;\n    }\n  }\n\n  // Add error to processing queue\n  private addToQueue(errorRecord: ErrorRecord): void {\n    if (this.errorQueue.length >= this.maxQueueSize) {\n      // Remove oldest error\n      this.errorQueue.shift();\n    }\n\n    this.errorQueue.push(errorRecord);\n  }\n\n  // Store error in cache for monitoring\n  private async storeErrorInCache(errorRecord: ErrorRecord): Promise<void> {\n    try {\n      const cacheKey = `leadpulse:errors:${errorRecord.id}`;\n      await redis.set(cacheKey, errorRecord, 24 * 60 * 60); // 24 hours\n\n      // Add to error list for monitoring\n      await redis.lpush('leadpulse:errors:list', errorRecord, 100); // Keep last 100\n\n      // Update error counters\n      const dateKey = new Date().toISOString().split('T')[0];\n      await redis.incr(`leadpulse:errors:count:${dateKey}`, 24 * 60 * 60);\n      await redis.incr(`leadpulse:errors:count:${errorRecord.type}:${dateKey}`, 24 * 60 * 60);\n    } catch (cacheError) {\n      logger.warn('Failed to store error in cache:', cacheError);\n    }\n  }\n\n  // Handle critical errors with immediate action\n  private async handleCriticalError(errorRecord: ErrorRecord): Promise<void> {\n    logger.error('CRITICAL ERROR - Taking immediate action:', errorRecord);\n\n    // Store critical error for alerting\n    try {\n      await redis.lpush('leadpulse:errors:critical', errorRecord, 10);\n    } catch (error) {\n      logger.error('Failed to store critical error:', error);\n    }\n\n    // TODO: Add alerting mechanism (email, Slack, etc.)\n    // This could integrate with external monitoring services\n  }\n\n  // Start error processing loop\n  private startErrorProcessor(): void {\n    setInterval(async () => {\n      await this.processErrorQueue();\n    }, 5000); // Process every 5 seconds\n  }\n\n  // Process errors in queue for retries\n  private async processErrorQueue(): Promise<void> {\n    const retryableErrors = this.errorQueue.filter(\n      error => !error.resolved && error.retryCount < error.maxRetries\n    );\n\n    for (const errorRecord of retryableErrors) {\n      if (this.shouldRetry(errorRecord)) {\n        await this.retryOperation(errorRecord);\n      }\n    }\n\n    // Clean up resolved errors\n    this.errorQueue = this.errorQueue.filter(error => !error.resolved);\n  }\n\n  // Check if error should be retried\n  private shouldRetry(errorRecord: ErrorRecord): boolean {\n    if (errorRecord.retryCount >= errorRecord.maxRetries) {\n      return false;\n    }\n\n    const timeSinceLastRetry = Date.now() - errorRecord.createdAt.getTime();\n    const retryInterval = this.retryIntervals[errorRecord.retryCount] || 60000;\n\n    return timeSinceLastRetry >= retryInterval;\n  }\n\n  // Retry failed operations\n  private async retryOperation(errorRecord: ErrorRecord): Promise<void> {\n    errorRecord.retryCount++;\n\n    try {\n      logger.info(`Retrying operation for error ${errorRecord.id}, attempt ${errorRecord.retryCount}`);\n\n      // The actual retry logic would depend on the error type\n      // For now, we'll mark certain types as resolved\n      if (errorRecord.type === LeadPulseErrorType.CACHE_ERROR) {\n        // Cache errors often resolve themselves\n        errorRecord.resolved = true;\n        errorRecord.resolvedAt = new Date();\n      }\n\n      // Update in cache\n      await this.storeErrorInCache(errorRecord);\n    } catch (retryError) {\n      logger.warn(`Retry failed for error ${errorRecord.id}:`, retryError);\n    }\n  }\n\n  // Generate unique error ID\n  private generateErrorId(): string {\n    return `lp-err-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  // Get error statistics\n  async getErrorStats(days = 7): Promise<any> {\n    try {\n      const stats = {\n        totalErrors: 0,\n        errorsByType: {} as Record<string, number>,\n        errorsBySeverity: {} as Record<string, number>,\n        dailyErrorCounts: {} as Record<string, number>,\n        recentErrors: [] as ErrorRecord[]\n      };\n\n      // Get recent errors from cache\n      const recentErrors = await redis.lrange<ErrorRecord>('leadpulse:errors:list', 0, 50);\n      stats.recentErrors = recentErrors;\n      stats.totalErrors = recentErrors.length;\n\n      // Count by type and severity\n      recentErrors.forEach(error => {\n        stats.errorsByType[error.type] = (stats.errorsByType[error.type] || 0) + 1;\n        stats.errorsBySeverity[error.severity] = (stats.errorsBySeverity[error.severity] || 0) + 1;\n      });\n\n      // Get daily counts\n      for (let i = 0; i < days; i++) {\n        const date = new Date();\n        date.setDate(date.getDate() - i);\n        const dateKey = date.toISOString().split('T')[0];\n        \n        const count = await redis.get(`leadpulse:errors:count:${dateKey}`) || 0;\n        stats.dailyErrorCounts[dateKey] = count as number;\n      }\n\n      return stats;\n    } catch (error) {\n      logger.error('Error getting error stats:', error);\n      return null;\n    }\n  }\n\n  // Get critical errors\n  async getCriticalErrors(): Promise<ErrorRecord[]> {\n    try {\n      return await redis.lrange<ErrorRecord>('leadpulse:errors:critical', 0, -1);\n    } catch (error) {\n      logger.error('Error getting critical errors:', error);\n      return [];\n    }\n  }\n\n  // Health check\n  async healthCheck(): Promise<{ healthy: boolean; errorRate?: number; criticalErrors?: number }> {\n    try {\n      const stats = await this.getErrorStats(1); // Last 24 hours\n      const criticalErrors = await this.getCriticalErrors();\n\n      const today = new Date().toISOString().split('T')[0];\n      const todayErrors = stats?.dailyErrorCounts[today] || 0;\n\n      return {\n        healthy: criticalErrors.length === 0 && todayErrors < 100, // Arbitrary threshold\n        errorRate: todayErrors,\n        criticalErrors: criticalErrors.length\n      };\n    } catch (error) {\n      return { healthy: false };\n    }\n  }\n}\n\n// Utility functions for specific error scenarios\n\n// Graceful degradation for database failures\nexport async function withDatabaseFallback<T>(\n  operation: () => Promise<T>,\n  fallback: T,\n  context?: Partial<ErrorContext>\n): Promise<T> {\n  try {\n    return await operation();\n  } catch (error) {\n    await LeadPulseErrorHandler.getInstance().handleError(\n      error,\n      context,\n      LeadPulseErrorType.DATABASE_ERROR\n    );\n    logger.warn('Database operation failed, using fallback value:', fallback);\n    return fallback;\n  }\n}\n\n// Graceful degradation for cache failures\nexport async function withCacheFallback<T>(\n  cacheOperation: () => Promise<T | null>,\n  dbOperation: () => Promise<T>,\n  context?: Partial<ErrorContext>\n): Promise<T> {\n  try {\n    const cached = await cacheOperation();\n    if (cached !== null) {\n      return cached;\n    }\n  } catch (error) {\n    await LeadPulseErrorHandler.getInstance().handleError(\n      error,\n      context,\n      LeadPulseErrorType.CACHE_ERROR\n    );\n    logger.warn('Cache operation failed, falling back to database');\n  }\n\n  return await dbOperation();\n}\n\n// Rate limiting protection\nexport async function withRateLimit<T>(\n  operation: () => Promise<T>,\n  key: string,\n  maxRequests = 100,\n  windowMs = 60000\n): Promise<T> {\n  const rateLimitKey = `rate_limit:${key}`;\n  \n  try {\n    const current = await redis.incr(rateLimitKey, Math.ceil(windowMs / 1000));\n    \n    if (current === 1) {\n      // First request in window\n      await redis.client?.expire(rateLimitKey, Math.ceil(windowMs / 1000));\n    }\n    \n    if (current > maxRequests) {\n      throw new Error(`Rate limit exceeded for ${key}: ${current}/${maxRequests}`);\n    }\n    \n    return await operation();\n  } catch (error) {\n    if (error instanceof Error && error.message.includes('Rate limit exceeded')) {\n      await LeadPulseErrorHandler.getInstance().handleError(\n        error,\n        { additionalData: { key, maxRequests, windowMs } },\n        LeadPulseErrorType.RATE_LIMIT_ERROR\n      );\n    }\n    throw error;\n  }\n}\n\n// Export singleton instance\nexport const leadPulseErrorHandler = LeadPulseErrorHandler.getInstance();"],"names":["ErrorSeverity","LeadPulseErrorHandler","LeadPulseErrorType","leadPulseErrorHandler","withCacheFallback","withDatabaseFallback","withRateLimit","getInstance","instance","constructor","errorQueue","maxQueueSize","retryIntervals","startErrorProcessor","handleError","error","context","type","errorRecord","id","generateErrorId","classifyError","severity","determineSeverity","message","Error","String","stack","undefined","timestamp","Date","resolved","retryCount","maxRetries","getMaxRetries","createdAt","logError","addToQueue","storeErrorInCache","handleCriticalError","toLowerCase","includes","errorType","retryMap","logData","errorId","logger","warn","info","length","shift","push","cacheKey","redis","set","lpush","dateKey","toISOString","split","incr","cacheError","setInterval","processErrorQueue","retryableErrors","filter","shouldRetry","retryOperation","timeSinceLastRetry","now","getTime","retryInterval","resolvedAt","retryError","Math","random","toString","substr","getErrorStats","days","stats","totalErrors","errorsByType","errorsBySeverity","dailyErrorCounts","recentErrors","lrange","forEach","i","date","setDate","getDate","count","get","getCriticalErrors","healthCheck","criticalErrors","today","todayErrors","healthy","errorRate","operation","fallback","cacheOperation","dbOperation","cached","key","maxRequests","windowMs","rateLimitKey","current","ceil","client","expire","additionalData"],"mappings":"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"}