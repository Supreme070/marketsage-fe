{"version":3,"sources":["/Users/supreme/Desktop/marketsage/src/lib/ai/workflow-node-builder.ts"],"sourcesContent":["/**\n * Advanced Workflow Node Builder\n * =============================\n * AI-powered system for creating and managing complex workflow nodes\n * Enables natural language workflow creation with intelligent node connections\n */\n\nimport { logger } from '@/lib/logger';\nimport prisma from '@/lib/db/prisma';\nimport { TransactionManager } from '@/lib/security/transaction-manager';\nimport { AuthorizationService, Permission } from '@/lib/security/authorization';\nimport { validationSchemas } from '@/lib/security/input-validation';\n\nexport interface WorkflowNode {\n  id: string;\n  type: WorkflowNodeType;\n  name: string;\n  description?: string;\n  position: { x: number; y: number };\n  config: WorkflowNodeConfig;\n  connections: {\n    inputs: string[];\n    outputs: string[];\n  };\n  conditions?: WorkflowCondition[];\n  metadata: {\n    createdAt: Date;\n    updatedAt: Date;\n    executionCount: number;\n    lastExecuted?: Date;\n    averageExecutionTime: number;\n  };\n}\n\nexport enum WorkflowNodeType {\n  // Trigger nodes\n  FORM_SUBMISSION = 'form_submission',\n  TIME_TRIGGER = 'time_trigger',\n  WEBHOOK = 'webhook',\n  EMAIL_RECEIVED = 'email_received',\n  CONTACT_CREATED = 'contact_created',\n  CONTACT_UPDATED = 'contact_updated',\n  CAMPAIGN_COMPLETED = 'campaign_completed',\n  \n  // Action nodes\n  SEND_EMAIL = 'send_email',\n  SEND_SMS = 'send_sms',\n  SEND_WHATSAPP = 'send_whatsapp',\n  UPDATE_CONTACT = 'update_contact',\n  ADD_TO_LIST = 'add_to_list',\n  REMOVE_FROM_LIST = 'remove_from_list',\n  CREATE_TASK = 'create_task',\n  SEND_NOTIFICATION = 'send_notification',\n  API_CALL = 'api_call',\n  \n  // Logic nodes\n  CONDITION = 'condition',\n  DELAY = 'delay',\n  SPLIT = 'split',\n  MERGE = 'merge',\n  LOOP = 'loop',\n  FILTER = 'filter',\n  \n  // Data nodes\n  DATA_TRANSFORM = 'data_transform',\n  CALCULATE = 'calculate',\n  LOOKUP = 'lookup',\n  STORE_DATA = 'store_data',\n  \n  // Integration nodes\n  ZAPIER = 'zapier',\n  SALESFORCE = 'salesforce',\n  HUBSPOT = 'hubspot',\n  SLACK = 'slack',\n  TEAMS = 'teams',\n  \n  // AI nodes\n  AI_ANALYSIS = 'ai_analysis',\n  AI_GENERATE_CONTENT = 'ai_generate_content',\n  AI_SENTIMENT = 'ai_sentiment',\n  AI_CLASSIFICATION = 'ai_classification'\n}\n\nexport interface WorkflowNodeConfig {\n  // Common config\n  enabled: boolean;\n  retryAttempts: number;\n  timeoutMs: number;\n  \n  // Type-specific config\n  [key: string]: any;\n}\n\nexport interface WorkflowCondition {\n  field: string;\n  operator: 'equals' | 'not_equals' | 'contains' | 'not_contains' | 'greater_than' | 'less_than' | 'exists' | 'not_exists';\n  value: any;\n  logicOperator?: 'AND' | 'OR';\n}\n\nexport interface WorkflowTemplate {\n  id: string;\n  name: string;\n  description: string;\n  category: string;\n  nodes: WorkflowNode[];\n  connections: WorkflowConnection[];\n  variables: WorkflowVariable[];\n  estimatedExecutionTime: number;\n  complexity: 'simple' | 'moderate' | 'complex' | 'advanced';\n}\n\nexport interface WorkflowConnection {\n  id: string;\n  sourceNodeId: string;\n  targetNodeId: string;\n  sourcePort: string;\n  targetPort: string;\n  condition?: WorkflowCondition;\n}\n\nexport interface WorkflowVariable {\n  name: string;\n  type: 'string' | 'number' | 'boolean' | 'object' | 'array';\n  defaultValue?: any;\n  description?: string;\n  required: boolean;\n}\n\nexport interface WorkflowBuildRequest {\n  description: string;\n  trigger: string;\n  actions: string[];\n  conditions?: string[];\n  integrations?: string[];\n  variables?: Record<string, any>;\n  options: {\n    generatePreview: boolean;\n    autoConnect: boolean;\n    optimizeForPerformance: boolean;\n  };\n}\n\nexport interface WorkflowBuildResult {\n  success: boolean;\n  workflowId?: string;\n  nodes: WorkflowNode[];\n  connections: WorkflowConnection[];\n  variables: WorkflowVariable[];\n  estimatedComplexity: 'simple' | 'moderate' | 'complex' | 'advanced';\n  estimatedExecutionTime: number;\n  suggestions: string[];\n  warnings: string[];\n  errors: string[];\n}\n\nexport class WorkflowNodeBuilder {\n  private nodeTemplates = new Map<WorkflowNodeType, Partial<WorkflowNode>>();\n  private predefinedTemplates: WorkflowTemplate[] = [];\n\n  constructor() {\n    this.initializeNodeTemplates();\n    this.initializePredefinedTemplates();\n  }\n\n  /**\n   * Build workflow from natural language description\n   */\n  async buildWorkflowFromDescription(\n    request: WorkflowBuildRequest,\n    userId: string,\n    userRole: string,\n    organizationId: string\n  ): Promise<WorkflowBuildResult> {\n    try {\n      // Check permissions\n      const canCreateWorkflows = AuthorizationService.hasPermission(\n        userRole as any,\n        Permission.CREATE_WORKFLOW\n      );\n\n      if (!canCreateWorkflows) {\n        return {\n          success: false,\n          nodes: [],\n          connections: [],\n          variables: [],\n          estimatedComplexity: 'simple',\n          estimatedExecutionTime: 0,\n          suggestions: [],\n          warnings: [],\n          errors: ['Insufficient permissions to create workflows']\n        };\n      }\n\n      logger.info('Building workflow from description', {\n        userId,\n        description: request.description.substring(0, 100),\n        trigger: request.trigger,\n        actionCount: request.actions.length\n      });\n\n      // Parse natural language description\n      const parsedWorkflow = await this.parseWorkflowDescription(request);\n      \n      // Build nodes\n      const nodes = await this.buildNodes(parsedWorkflow, request.options);\n      \n      // Create connections\n      const connections = this.createConnections(nodes, parsedWorkflow, request.options);\n      \n      // Extract variables\n      const variables = this.extractVariables(parsedWorkflow);\n      \n      // Calculate complexity and execution time\n      const complexity = this.calculateComplexity(nodes, connections);\n      const estimatedTime = this.calculateExecutionTime(nodes);\n      \n      // Generate suggestions and warnings\n      const suggestions = this.generateSuggestions(nodes, connections);\n      const warnings = this.generateWarnings(nodes, connections);\n\n      // Create workflow in database if not preview\n      let workflowId: string | undefined;\n      if (!request.options.generatePreview) {\n        workflowId = await this.createWorkflowInDatabase(\n          request,\n          nodes,\n          connections,\n          variables,\n          userId,\n          organizationId\n        );\n      }\n\n      return {\n        success: true,\n        workflowId,\n        nodes,\n        connections,\n        variables,\n        estimatedComplexity: complexity,\n        estimatedExecutionTime: estimatedTime,\n        suggestions,\n        warnings,\n        errors: []\n      };\n\n    } catch (error) {\n      logger.error('Workflow building failed', {\n        error: error instanceof Error ? error.message : String(error),\n        userId,\n        description: request.description.substring(0, 100)\n      });\n\n      return {\n        success: false,\n        nodes: [],\n        connections: [],\n        variables: [],\n        estimatedComplexity: 'simple',\n        estimatedExecutionTime: 0,\n        suggestions: [],\n        warnings: [],\n        errors: [error instanceof Error ? error.message : 'Unknown error']\n      };\n    }\n  }\n\n  /**\n   * Create workflow node from natural language\n   */\n  async createNodeFromDescription(\n    description: string,\n    nodeType?: WorkflowNodeType,\n    position?: { x: number; y: number }\n  ): Promise<WorkflowNode> {\n    const parsedNode = this.parseNodeDescription(description, nodeType);\n    \n    const node: WorkflowNode = {\n      id: `node_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      type: parsedNode.type,\n      name: parsedNode.name,\n      description: parsedNode.description,\n      position: position || { x: 0, y: 0 },\n      config: parsedNode.config,\n      connections: { inputs: [], outputs: [] },\n      conditions: parsedNode.conditions,\n      metadata: {\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        executionCount: 0,\n        averageExecutionTime: 0\n      }\n    };\n\n    return node;\n  }\n\n  /**\n   * Get workflow templates by category\n   */\n  getWorkflowTemplates(category?: string): WorkflowTemplate[] {\n    if (category) {\n      return this.predefinedTemplates.filter(template => \n        template.category.toLowerCase() === category.toLowerCase()\n      );\n    }\n    return this.predefinedTemplates;\n  }\n\n  /**\n   * Clone and customize template\n   */\n  async customizeTemplate(\n    templateId: string,\n    customizations: Partial<WorkflowTemplate>,\n    userId: string,\n    organizationId: string\n  ): Promise<WorkflowBuildResult> {\n    const template = this.predefinedTemplates.find(t => t.id === templateId);\n    \n    if (!template) {\n      return {\n        success: false,\n        nodes: [],\n        connections: [],\n        variables: [],\n        estimatedComplexity: 'simple',\n        estimatedExecutionTime: 0,\n        suggestions: [],\n        warnings: [],\n        errors: ['Template not found']\n      };\n    }\n\n    // Clone and apply customizations\n    const customizedNodes = template.nodes.map(node => ({\n      ...node,\n      id: `node_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      metadata: {\n        ...node.metadata,\n        createdAt: new Date(),\n        updatedAt: new Date()\n      }\n    }));\n\n    // Update connections with new node IDs\n    const nodeIdMap = new Map();\n    template.nodes.forEach((oldNode, index) => {\n      nodeIdMap.set(oldNode.id, customizedNodes[index].id);\n    });\n\n    const customizedConnections = template.connections.map(conn => ({\n      ...conn,\n      id: `conn_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      sourceNodeId: nodeIdMap.get(conn.sourceNodeId),\n      targetNodeId: nodeIdMap.get(conn.targetNodeId)\n    }));\n\n    const workflowId = await this.createWorkflowInDatabase(\n      {\n        description: customizations.description || template.description,\n        trigger: 'template',\n        actions: [],\n        options: { generatePreview: false, autoConnect: true, optimizeForPerformance: true }\n      },\n      customizedNodes,\n      customizedConnections,\n      template.variables,\n      userId,\n      organizationId\n    );\n\n    return {\n      success: true,\n      workflowId,\n      nodes: customizedNodes,\n      connections: customizedConnections,\n      variables: template.variables,\n      estimatedComplexity: template.complexity,\n      estimatedExecutionTime: template.estimatedExecutionTime,\n      suggestions: [],\n      warnings: [],\n      errors: []\n    };\n  }\n\n  /**\n   * Validate workflow structure\n   */\n  validateWorkflow(nodes: WorkflowNode[], connections: WorkflowConnection[]): {\n    isValid: boolean;\n    errors: string[];\n    warnings: string[];\n  } {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    // Check for trigger nodes\n    const triggerNodes = nodes.filter(node => this.isTriggerNode(node.type));\n    if (triggerNodes.length === 0) {\n      errors.push('Workflow must have at least one trigger node');\n    }\n    if (triggerNodes.length > 1) {\n      warnings.push('Multiple trigger nodes detected - workflow may have unexpected behavior');\n    }\n\n    // Check for orphaned nodes\n    const connectedNodeIds = new Set([\n      ...connections.map(c => c.sourceNodeId),\n      ...connections.map(c => c.targetNodeId)\n    ]);\n    \n    const orphanedNodes = nodes.filter(node => \n      !connectedNodeIds.has(node.id) && !this.isTriggerNode(node.type)\n    );\n    \n    if (orphanedNodes.length > 0) {\n      warnings.push(`${orphanedNodes.length} nodes are not connected to the workflow`);\n    }\n\n    // Check for circular dependencies\n    if (this.hasCircularDependencies(connections)) {\n      errors.push('Workflow contains circular dependencies');\n    }\n\n    // Check for unreachable nodes\n    const reachableNodes = this.findReachableNodes(nodes, connections);\n    if (reachableNodes.size < nodes.length) {\n      warnings.push(`${nodes.length - reachableNodes.size} nodes are unreachable from triggers`);\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  /**\n   * Optimize workflow for performance\n   */\n  optimizeWorkflow(\n    nodes: WorkflowNode[],\n    connections: WorkflowConnection[]\n  ): { nodes: WorkflowNode[]; connections: WorkflowConnection[] } {\n    // Remove unnecessary delay nodes\n    const optimizedNodes = nodes.filter(node => {\n      if (node.type === WorkflowNodeType.DELAY) {\n        const delayMs = node.config.delayMs || 0;\n        return delayMs > 1000; // Remove delays less than 1 second\n      }\n      return true;\n    });\n\n    // Merge sequential condition nodes\n    // Group parallel actions\n    // Optimize API call batching\n\n    return {\n      nodes: optimizedNodes,\n      connections\n    };\n  }\n\n  // Private methods\n\n  private async parseWorkflowDescription(request: WorkflowBuildRequest): Promise<any> {\n    const description = request.description.toLowerCase();\n    \n    return {\n      triggerType: this.extractTriggerType(request.trigger),\n      actionTypes: request.actions.map(action => this.extractActionType(action)),\n      conditions: request.conditions?.map(condition => this.parseCondition(condition)) || [],\n      integrations: request.integrations || [],\n      variables: request.variables || {}\n    };\n  }\n\n  private extractTriggerType(trigger: string): WorkflowNodeType {\n    const lowerTrigger = trigger.toLowerCase();\n    \n    if (lowerTrigger.includes('form') || lowerTrigger.includes('submit')) {\n      return WorkflowNodeType.FORM_SUBMISSION;\n    }\n    if (lowerTrigger.includes('time') || lowerTrigger.includes('schedule')) {\n      return WorkflowNodeType.TIME_TRIGGER;\n    }\n    if (lowerTrigger.includes('webhook') || lowerTrigger.includes('api')) {\n      return WorkflowNodeType.WEBHOOK;\n    }\n    if (lowerTrigger.includes('email') && lowerTrigger.includes('receive')) {\n      return WorkflowNodeType.EMAIL_RECEIVED;\n    }\n    if (lowerTrigger.includes('contact') && lowerTrigger.includes('create')) {\n      return WorkflowNodeType.CONTACT_CREATED;\n    }\n    if (lowerTrigger.includes('contact') && lowerTrigger.includes('update')) {\n      return WorkflowNodeType.CONTACT_UPDATED;\n    }\n    \n    return WorkflowNodeType.FORM_SUBMISSION; // Default\n  }\n\n  private extractActionType(action: string): WorkflowNodeType {\n    const lowerAction = action.toLowerCase();\n    \n    if (lowerAction.includes('email')) return WorkflowNodeType.SEND_EMAIL;\n    if (lowerAction.includes('sms')) return WorkflowNodeType.SEND_SMS;\n    if (lowerAction.includes('whatsapp')) return WorkflowNodeType.SEND_WHATSAPP;\n    if (lowerAction.includes('update contact')) return WorkflowNodeType.UPDATE_CONTACT;\n    if (lowerAction.includes('add to list')) return WorkflowNodeType.ADD_TO_LIST;\n    if (lowerAction.includes('create task')) return WorkflowNodeType.CREATE_TASK;\n    if (lowerAction.includes('notification')) return WorkflowNodeType.SEND_NOTIFICATION;\n    if (lowerAction.includes('api') || lowerAction.includes('webhook')) return WorkflowNodeType.API_CALL;\n    if (lowerAction.includes('delay') || lowerAction.includes('wait')) return WorkflowNodeType.DELAY;\n    \n    return WorkflowNodeType.SEND_EMAIL; // Default\n  }\n\n  private parseCondition(condition: string): WorkflowCondition {\n    // Simple parsing - in production, use more sophisticated NLP\n    return {\n      field: 'status',\n      operator: 'equals',\n      value: 'active'\n    };\n  }\n\n  private parseNodeDescription(description: string, nodeType?: WorkflowNodeType): any {\n    const lowerDesc = description.toLowerCase();\n    \n    // Extract node type if not provided\n    const type = nodeType || this.extractActionType(description);\n    \n    // Extract configuration based on type\n    let config: WorkflowNodeConfig = {\n      enabled: true,\n      retryAttempts: 3,\n      timeoutMs: 30000\n    };\n\n    // Type-specific config parsing\n    switch (type) {\n      case WorkflowNodeType.SEND_EMAIL:\n        config = {\n          ...config,\n          templateId: null,\n          subject: this.extractQuotedText(description, 'subject'),\n          fromEmail: this.extractQuotedText(description, 'from'),\n          personalizeContent: true\n        };\n        break;\n        \n      case WorkflowNodeType.DELAY:\n        const delayMatch = description.match(/(\\d+)\\s*(minute|hour|day|second)/);\n        const delayMs = delayMatch ? this.convertToMs(Number.parseInt(delayMatch[1]), delayMatch[2]) : 60000;\n        config = { ...config, delayMs };\n        break;\n        \n      case WorkflowNodeType.CONDITION:\n        config = {\n          ...config,\n          conditions: [this.parseCondition(description)]\n        };\n        break;\n    }\n\n    return {\n      type,\n      name: this.generateNodeName(type, description),\n      description,\n      config,\n      conditions: type === WorkflowNodeType.CONDITION ? [this.parseCondition(description)] : undefined\n    };\n  }\n\n  private buildNodes(parsedWorkflow: any, options: any): WorkflowNode[] {\n    const nodes: WorkflowNode[] = [];\n    \n    // Create trigger node\n    const triggerNode = this.createNodeFromType(parsedWorkflow.triggerType, { x: 100, y: 100 });\n    nodes.push(triggerNode);\n    \n    // Create action nodes\n    const yPos = 200;\n    parsedWorkflow.actionTypes.forEach((actionType: WorkflowNodeType, index: number) => {\n      const actionNode = this.createNodeFromType(actionType, { x: 100 + (index * 200), y: yPos });\n      nodes.push(actionNode);\n    });\n    \n    // Add condition nodes if specified\n    parsedWorkflow.conditions.forEach((condition: any, index: number) => {\n      const conditionNode = this.createNodeFromType(WorkflowNodeType.CONDITION, { x: 300, y: 150 + (index * 100) });\n      conditionNode.conditions = [condition];\n      nodes.push(conditionNode);\n    });\n\n    return nodes;\n  }\n\n  private createNodeFromType(type: WorkflowNodeType, position: { x: number; y: number }): WorkflowNode {\n    const template = this.nodeTemplates.get(type) || {};\n    \n    return {\n      id: `node_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      type,\n      name: template.name || this.getDefaultNodeName(type),\n      description: template.description,\n      position,\n      config: template.config || { enabled: true, retryAttempts: 3, timeoutMs: 30000 },\n      connections: { inputs: [], outputs: [] },\n      conditions: template.conditions,\n      metadata: {\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        executionCount: 0,\n        averageExecutionTime: this.getEstimatedExecutionTime(type)\n      }\n    };\n  }\n\n  private createConnections(\n    nodes: WorkflowNode[],\n    parsedWorkflow: any,\n    options: any\n  ): WorkflowConnection[] {\n    const connections: WorkflowConnection[] = [];\n    \n    if (!options.autoConnect) return connections;\n    \n    // Simple linear connection for now\n    for (let i = 0; i < nodes.length - 1; i++) {\n      const connection: WorkflowConnection = {\n        id: `conn_${Date.now()}_${i}`,\n        sourceNodeId: nodes[i].id,\n        targetNodeId: nodes[i + 1].id,\n        sourcePort: 'output',\n        targetPort: 'input'\n      };\n      connections.push(connection);\n    }\n    \n    return connections;\n  }\n\n  private extractVariables(parsedWorkflow: any): WorkflowVariable[] {\n    // Extract variables from the workflow description\n    return [\n      {\n        name: 'contactEmail',\n        type: 'string',\n        description: 'Email address of the contact',\n        required: true\n      },\n      {\n        name: 'contactName',\n        type: 'string',\n        description: 'Name of the contact',\n        required: false\n      }\n    ];\n  }\n\n  private calculateComplexity(nodes: WorkflowNode[], connections: WorkflowConnection[]): 'simple' | 'moderate' | 'complex' | 'advanced' {\n    const nodeCount = nodes.length;\n    const connectionCount = connections.length;\n    const conditionNodes = nodes.filter(n => n.type === WorkflowNodeType.CONDITION).length;\n    const integrationNodes = nodes.filter(n => this.isIntegrationNode(n.type)).length;\n    \n    if (nodeCount <= 3 && conditionNodes === 0) return 'simple';\n    if (nodeCount <= 7 && conditionNodes <= 2) return 'moderate';\n    if (nodeCount <= 15 && integrationNodes <= 3) return 'complex';\n    return 'advanced';\n  }\n\n  private calculateExecutionTime(nodes: WorkflowNode[]): number {\n    return nodes.reduce((total, node) => total + node.metadata.averageExecutionTime, 0);\n  }\n\n  private generateSuggestions(nodes: WorkflowNode[], connections: WorkflowConnection[]): string[] {\n    const suggestions: string[] = [];\n    \n    if (nodes.length > 10) {\n      suggestions.push('Consider breaking this workflow into smaller, more manageable workflows');\n    }\n    \n    const delayNodes = nodes.filter(n => n.type === WorkflowNodeType.DELAY);\n    if (delayNodes.length > 3) {\n      suggestions.push('Multiple delay nodes detected - consider optimizing timing');\n    }\n    \n    if (!nodes.some(n => n.type === WorkflowNodeType.CONDITION)) {\n      suggestions.push('Add conditional logic to make the workflow more intelligent');\n    }\n    \n    return suggestions;\n  }\n\n  private generateWarnings(nodes: WorkflowNode[], connections: WorkflowConnection[]): string[] {\n    const warnings: string[] = [];\n    \n    const apiNodes = nodes.filter(n => n.type === WorkflowNodeType.API_CALL);\n    if (apiNodes.length > 5) {\n      warnings.push('High number of API calls may impact performance');\n    }\n    \n    return warnings;\n  }\n\n  private async createWorkflowInDatabase(\n    request: WorkflowBuildRequest,\n    nodes: WorkflowNode[],\n    connections: WorkflowConnection[],\n    variables: WorkflowVariable[],\n    userId: string,\n    organizationId: string\n  ): Promise<string> {\n    return await TransactionManager.startTransaction(\n      userId,\n      'create_workflow',\n      'Create AI-generated workflow',\n      30000\n    );\n  }\n\n  // Helper methods\n  private initializeNodeTemplates(): void {\n    // Initialize common node templates\n    this.nodeTemplates.set(WorkflowNodeType.SEND_EMAIL, {\n      name: 'Send Email',\n      description: 'Send an email to contacts',\n      config: {\n        enabled: true,\n        retryAttempts: 3,\n        timeoutMs: 30000,\n        templateId: null,\n        personalizeContent: true\n      }\n    });\n    \n    // Add more templates...\n  }\n\n  private initializePredefinedTemplates(): void {\n    // Welcome Email Sequence\n    this.predefinedTemplates.push({\n      id: 'welcome_sequence',\n      name: 'Welcome Email Sequence',\n      description: 'Automated welcome sequence for new contacts',\n      category: 'Onboarding',\n      nodes: [],\n      connections: [],\n      variables: [],\n      estimatedExecutionTime: 5000,\n      complexity: 'moderate'\n    });\n    \n    // Add more templates...\n  }\n\n  private isTriggerNode(type: WorkflowNodeType): boolean {\n    return [\n      WorkflowNodeType.FORM_SUBMISSION,\n      WorkflowNodeType.TIME_TRIGGER,\n      WorkflowNodeType.WEBHOOK,\n      WorkflowNodeType.EMAIL_RECEIVED,\n      WorkflowNodeType.CONTACT_CREATED,\n      WorkflowNodeType.CONTACT_UPDATED,\n      WorkflowNodeType.CAMPAIGN_COMPLETED\n    ].includes(type);\n  }\n\n  private isIntegrationNode(type: WorkflowNodeType): boolean {\n    return [\n      WorkflowNodeType.ZAPIER,\n      WorkflowNodeType.SALESFORCE,\n      WorkflowNodeType.HUBSPOT,\n      WorkflowNodeType.SLACK,\n      WorkflowNodeType.TEAMS\n    ].includes(type);\n  }\n\n  private hasCircularDependencies(connections: WorkflowConnection[]): boolean {\n    // Simple cycle detection\n    const graph = new Map<string, string[]>();\n    \n    connections.forEach(conn => {\n      if (!graph.has(conn.sourceNodeId)) {\n        graph.set(conn.sourceNodeId, []);\n      }\n      graph.get(conn.sourceNodeId)!.push(conn.targetNodeId);\n    });\n    \n    const visited = new Set<string>();\n    const recursionStack = new Set<string>();\n    \n    const hasCycle = (nodeId: string): boolean => {\n      if (recursionStack.has(nodeId)) return true;\n      if (visited.has(nodeId)) return false;\n      \n      visited.add(nodeId);\n      recursionStack.add(nodeId);\n      \n      const neighbors = graph.get(nodeId) || [];\n      for (const neighbor of neighbors) {\n        if (hasCycle(neighbor)) return true;\n      }\n      \n      recursionStack.delete(nodeId);\n      return false;\n    };\n    \n    for (const nodeId of graph.keys()) {\n      if (hasCycle(nodeId)) return true;\n    }\n    \n    return false;\n  }\n\n  private findReachableNodes(nodes: WorkflowNode[], connections: WorkflowConnection[]): Set<string> {\n    const reachable = new Set<string>();\n    const triggerNodes = nodes.filter(node => this.isTriggerNode(node.type));\n    \n    const graph = new Map<string, string[]>();\n    connections.forEach(conn => {\n      if (!graph.has(conn.sourceNodeId)) {\n        graph.set(conn.sourceNodeId, []);\n      }\n      graph.get(conn.sourceNodeId)!.push(conn.targetNodeId);\n    });\n    \n    const dfs = (nodeId: string) => {\n      if (reachable.has(nodeId)) return;\n      reachable.add(nodeId);\n      \n      const neighbors = graph.get(nodeId) || [];\n      neighbors.forEach(neighbor => dfs(neighbor));\n    };\n    \n    triggerNodes.forEach(trigger => dfs(trigger.id));\n    \n    return reachable;\n  }\n\n  private extractQuotedText(text: string, keyword: string): string | null {\n    const regex = new RegExp(`${keyword}\\\\s*[:\"']([^\"']+)[\"']`, 'i');\n    const match = text.match(regex);\n    return match ? match[1] : null;\n  }\n\n  private convertToMs(value: number, unit: string): number {\n    switch (unit.toLowerCase()) {\n      case 'second': return value * 1000;\n      case 'minute': return value * 60 * 1000;\n      case 'hour': return value * 60 * 60 * 1000;\n      case 'day': return value * 24 * 60 * 60 * 1000;\n      default: return value * 1000;\n    }\n  }\n\n  private generateNodeName(type: WorkflowNodeType, description: string): string {\n    const baseNames = {\n      [WorkflowNodeType.SEND_EMAIL]: 'Send Email',\n      [WorkflowNodeType.SEND_SMS]: 'Send SMS',\n      [WorkflowNodeType.DELAY]: 'Wait',\n      [WorkflowNodeType.CONDITION]: 'If/Then',\n      [WorkflowNodeType.UPDATE_CONTACT]: 'Update Contact'\n    };\n    \n    return baseNames[type] || type.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n  }\n\n  private getDefaultNodeName(type: WorkflowNodeType): string {\n    return this.generateNodeName(type, '');\n  }\n\n  private getEstimatedExecutionTime(type: WorkflowNodeType): number {\n    const times = {\n      [WorkflowNodeType.SEND_EMAIL]: 2000,\n      [WorkflowNodeType.SEND_SMS]: 1000,\n      [WorkflowNodeType.UPDATE_CONTACT]: 500,\n      [WorkflowNodeType.CONDITION]: 100,\n      [WorkflowNodeType.API_CALL]: 3000\n    };\n    \n    return times[type] || 1000;\n  }\n}\n\n// Export singleton instance\nexport const workflowNodeBuilder = new WorkflowNodeBuilder();"],"names":["WorkflowNodeBuilder","WorkflowNodeType","workflowNodeBuilder","constructor","nodeTemplates","Map","predefinedTemplates","initializeNodeTemplates","initializePredefinedTemplates","buildWorkflowFromDescription","request","userId","userRole","organizationId","canCreateWorkflows","AuthorizationService","hasPermission","Permission","CREATE_WORKFLOW","success","nodes","connections","variables","estimatedComplexity","estimatedExecutionTime","suggestions","warnings","errors","logger","info","description","substring","trigger","actionCount","actions","length","parsedWorkflow","parseWorkflowDescription","buildNodes","options","createConnections","extractVariables","complexity","calculateComplexity","estimatedTime","calculateExecutionTime","generateSuggestions","generateWarnings","workflowId","generatePreview","createWorkflowInDatabase","error","Error","message","String","createNodeFromDescription","nodeType","position","parsedNode","parseNodeDescription","node","id","Date","now","Math","random","toString","substr","type","name","x","y","config","inputs","outputs","conditions","metadata","createdAt","updatedAt","executionCount","averageExecutionTime","getWorkflowTemplates","category","filter","template","toLowerCase","customizeTemplate","templateId","customizations","find","t","customizedNodes","map","nodeIdMap","forEach","oldNode","index","set","customizedConnections","conn","sourceNodeId","get","targetNodeId","autoConnect","optimizeForPerformance","validateWorkflow","triggerNodes","isTriggerNode","push","connectedNodeIds","Set","c","orphanedNodes","has","hasCircularDependencies","reachableNodes","findReachableNodes","size","isValid","optimizeWorkflow","optimizedNodes","delayMs","triggerType","extractTriggerType","actionTypes","action","extractActionType","condition","parseCondition","integrations","lowerTrigger","includes","lowerAction","field","operator","value","lowerDesc","enabled","retryAttempts","timeoutMs","subject","extractQuotedText","fromEmail","personalizeContent","delayMatch","match","convertToMs","Number","parseInt","generateNodeName","undefined","triggerNode","createNodeFromType","yPos","actionType","actionNode","conditionNode","getDefaultNodeName","getEstimatedExecutionTime","i","connection","sourcePort","targetPort","required","nodeCount","connectionCount","conditionNodes","n","integrationNodes","isIntegrationNode","reduce","total","delayNodes","some","apiNodes","TransactionManager","startTransaction","graph","visited","recursionStack","hasCycle","nodeId","add","neighbors","neighbor","delete","keys","reachable","dfs","text","keyword","regex","RegExp","unit","baseNames","replace","l","toUpperCase","times"],"mappings":"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"}