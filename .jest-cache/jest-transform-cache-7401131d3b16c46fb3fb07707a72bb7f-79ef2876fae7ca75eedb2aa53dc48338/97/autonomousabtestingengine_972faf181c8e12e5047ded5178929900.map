{"version":3,"sources":["/Users/supreme/Desktop/marketsage/src/lib/ai/autonomous-ab-testing-engine.ts"],"sourcesContent":["/**\n * Autonomous A/B Testing Engine\n * =============================\n * AI-powered autonomous testing framework that automatically designs, executes, and optimizes A/B tests\n * Builds upon the existing comprehensive A/B testing system with intelligent automation\n */\n\nimport { logger } from '@/lib/logger';\nimport { trace } from '@opentelemetry/api';\nimport { EventEmitter } from 'events';\nimport prisma from '@/lib/db/prisma';\nimport { strategicDecisionEngine } from './strategic-decision-engine';\nimport { multiAgentCoordinator } from './multi-agent-coordinator';\n\nexport interface AutonomousTestConfiguration {\n  id: string;\n  name: string;\n  type: 'email_campaign' | 'form_optimization' | 'landing_page' | 'workflow' | 'cross_channel';\n  priority: 'low' | 'medium' | 'high' | 'critical';\n  objectives: TestObjective[];\n  constraints: TestConstraints;\n  targetMetrics: TestMetric[];\n  autoApprovalThreshold: number; // Confidence threshold for auto-applying winners\n  maxTestDuration: number; // Maximum test duration in hours\n  minSampleSize: number;\n  trafficAllocation: number; // Percentage of traffic to use for testing\n  created: Date;\n  status: 'pending' | 'designing' | 'waiting_approval' | 'running' | 'analyzing' | 'completed' | 'paused' | 'failed';\n}\n\nexport interface TestObjective {\n  metric: 'conversion_rate' | 'open_rate' | 'click_rate' | 'revenue' | 'engagement_time' | 'form_completion';\n  targetImprovement: number; // Percentage improvement goal\n  weight: number; // 0-1, importance of this objective\n  currentBaseline?: number;\n}\n\nexport interface TestConstraints {\n  maxVariants: number;\n  minTrafficPerVariant: number;\n  excludeSegments?: string[];\n  includeSegments?: string[];\n  businessHours?: boolean;\n  africanTimezones?: boolean;\n  budgetLimit?: number;\n  complianceRequirements?: string[];\n}\n\nexport interface TestMetric {\n  name: string;\n  type: 'primary' | 'secondary' | 'guardrail';\n  threshold: number;\n  direction: 'increase' | 'decrease' | 'maintain';\n}\n\nexport interface AutonomousTestResult {\n  testId: string;\n  configurationId: string;\n  winnerVariantId?: string;\n  confidenceLevel: number;\n  improvementPercentage: number;\n  significanceReached: boolean;\n  recommendedAction: 'apply_winner' | 'continue_testing' | 'stop_inconclusive' | 'redesign_test';\n  insights: TestInsight[];\n  nextActions: AutonomousAction[];\n  completedAt?: Date;\n}\n\nexport interface TestInsight {\n  type: 'performance' | 'segment_behavior' | 'timing_pattern' | 'content_preference' | 'technical_issue';\n  insight: string;\n  confidence: number;\n  actionable: boolean;\n  impact: 'low' | 'medium' | 'high';\n  suggestedFollowUp?: string;\n}\n\nexport interface AutonomousAction {\n  type: 'create_followup_test' | 'apply_winner' | 'optimize_variant' | 'expand_test' | 'alert_human';\n  description: string;\n  priority: 'low' | 'medium' | 'high';\n  estimatedImpact: number;\n  autoExecute: boolean;\n  requiresApproval: boolean;\n}\n\nexport interface TestDesignRequest {\n  campaignId?: string;\n  formId?: string;\n  workflowId?: string;\n  channel: 'email' | 'sms' | 'whatsapp' | 'form' | 'landing_page';\n  objective: string;\n  currentPerformance?: any;\n  constraints?: Partial<TestConstraints>;\n}\n\nclass AutonomousABTestingEngine extends EventEmitter {\n  private activeTests: Map<string, AutonomousTestConfiguration> = new Map();\n  private testResults: Map<string, AutonomousTestResult> = new Map();\n  private designQueue: TestDesignRequest[] = [];\n  private processingInterval: NodeJS.Timeout | null = null;\n  private analysisInterval: NodeJS.Timeout | null = null;\n\n  constructor() {\n    super();\n    this.initializeEngine();\n  }\n\n  /**\n   * Initialize the autonomous testing engine\n   */\n  private async initializeEngine() {\n    try {\n      logger.info('Initializing autonomous A/B testing engine...');\n\n      // Start processing loops\n      this.startTestProcessing();\n      this.startResultAnalysis();\n      this.startContinuousOptimization();\n\n      // Connect to existing systems\n      this.connectToExistingSystems();\n\n      logger.info('Autonomous A/B testing engine initialized successfully');\n\n    } catch (error) {\n      logger.error('Failed to initialize autonomous A/B testing engine', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Connect to existing MarketSage systems\n   */\n  private connectToExistingSystems() {\n    // Listen to campaign events for automatic test opportunities\n    this.on('campaign_created', (campaign) => {\n      this.evaluateAutomaticTestingOpportunity(campaign);\n    });\n\n    // Listen to performance degradation for test recommendations\n    this.on('performance_decline', (metrics) => {\n      this.recommendTestingStrategy(metrics);\n    });\n\n    // Connect to strategic decision engine for test prioritization\n    strategicDecisionEngine.on('optimization_opportunity', (opportunity) => {\n      this.evaluateTestingOpportunity(opportunity);\n    });\n\n    logger.info('Connected to existing MarketSage systems for autonomous testing');\n  }\n\n  /**\n   * Automatically design an A/B test based on objectives and constraints\n   */\n  async designAutonomousTest(request: TestDesignRequest): Promise<AutonomousTestConfiguration> {\n    const tracer = trace.getTracer('autonomous-ab-testing');\n    \n    return tracer.startActiveSpan('design-autonomous-test', async (span) => {\n      try {\n        span.setAttributes({\n          'test.channel': request.channel,\n          'test.objective': request.objective\n        });\n\n        logger.info('Designing autonomous A/B test', {\n          channel: request.channel,\n          objective: request.objective,\n          campaignId: request.campaignId\n        });\n\n        // Analyze current performance and identify optimization opportunities\n        const currentPerformance = await this.analyzeCurrentPerformance(request);\n        \n        // Generate test objectives based on AI analysis\n        const objectives = await this.generateTestObjectives(request, currentPerformance);\n        \n        // Design test variants using AI\n        const variants = await this.designTestVariants(request, objectives);\n        \n        // Calculate optimal test parameters\n        const testParameters = await this.calculateOptimalTestParameters(objectives, request.constraints);\n\n        // Create autonomous test configuration\n        const testConfig: AutonomousTestConfiguration = {\n          id: `auto_test_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n          name: `Autonomous ${request.channel} Optimization - ${request.objective}`,\n          type: this.mapChannelToTestType(request.channel),\n          priority: this.determinePriority(objectives, currentPerformance),\n          objectives,\n          constraints: {\n            maxVariants: 4,\n            minTrafficPerVariant: 10,\n            africanTimezones: true,\n            businessHours: true,\n            ...request.constraints\n          },\n          targetMetrics: this.generateTargetMetrics(objectives),\n          autoApprovalThreshold: 0.95, // 95% confidence for auto-application\n          maxTestDuration: 168, // 7 days\n          minSampleSize: testParameters.minSampleSize,\n          trafficAllocation: testParameters.trafficAllocation,\n          created: new Date(),\n          status: 'designing'\n        };\n\n        // Add to active tests\n        this.activeTests.set(testConfig.id, testConfig);\n\n        // Emit event for monitoring\n        this.emit('test_designed', {\n          testId: testConfig.id,\n          type: testConfig.type,\n          objectives: objectives.length,\n          estimatedDuration: testConfig.maxTestDuration\n        });\n\n        span.setAttributes({\n          'test.id': testConfig.id,\n          'test.variants': variants.length,\n          'test.objectives': objectives.length\n        });\n\n        return testConfig;\n\n      } catch (error) {\n        span.setStatus({ code: 2, message: String(error) });\n        logger.error('Test design failed', {\n          error: error instanceof Error ? error.message : String(error),\n          request\n        });\n        throw error;\n      } finally {\n        span.end();\n      }\n    });\n  }\n\n  /**\n   * Automatically execute and manage an A/B test\n   */\n  async executeAutonomousTest(testId: string, autoApprove = false): Promise<boolean> {\n    try {\n      const testConfig = this.activeTests.get(testId);\n      if (!testConfig) {\n        throw new Error(`Test configuration not found: ${testId}`);\n      }\n\n      logger.info('Executing autonomous A/B test', {\n        testId,\n        type: testConfig.type,\n        autoApprove\n      });\n\n      // Check if test requires approval\n      if (!autoApprove && this.requiresHumanApproval(testConfig)) {\n        testConfig.status = 'waiting_approval';\n        this.emit('test_requires_approval', {\n          testId,\n          config: testConfig,\n          reason: 'High impact test requires human approval'\n        });\n        return false;\n      }\n\n      // Create actual A/B test using existing infrastructure\n      const abTestId = await this.createActualABTest(testConfig);\n      \n      // Start the test\n      await this.startTest(abTestId, testConfig);\n      \n      // Update status\n      testConfig.status = 'running';\n      this.activeTests.set(testId, testConfig);\n\n      // Schedule automated analysis\n      this.scheduleAutomatedAnalysis(testId, abTestId);\n\n      logger.info('Autonomous A/B test started successfully', {\n        testId,\n        abTestId,\n        duration: testConfig.maxTestDuration\n      });\n\n      return true;\n\n    } catch (error) {\n      logger.error('Failed to execute autonomous test', {\n        testId,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      \n      // Update test status\n      const testConfig = this.activeTests.get(testId);\n      if (testConfig) {\n        testConfig.status = 'failed';\n        this.activeTests.set(testId, testConfig);\n      }\n      \n      throw error;\n    }\n  }\n\n  /**\n   * Analyze test results and make autonomous decisions\n   */\n  async analyzeTestResults(testId: string): Promise<AutonomousTestResult> {\n    try {\n      const testConfig = this.activeTests.get(testId);\n      if (!testConfig) {\n        throw new Error(`Test configuration not found: ${testId}`);\n      }\n\n      logger.info('Analyzing autonomous test results', { testId });\n\n      // Get actual test results from existing A/B testing system\n      const rawResults = await this.getTestResults(testId);\n      \n      // Perform statistical analysis\n      const statisticalAnalysis = await this.performStatisticalAnalysis(rawResults, testConfig);\n      \n      // Generate AI insights\n      const insights = await this.generateAIInsights(rawResults, testConfig);\n      \n      // Determine recommended actions\n      const recommendedActions = await this.determineRecommendedActions(\n        statisticalAnalysis, \n        insights, \n        testConfig\n      );\n\n      // Create autonomous test result\n      const result: AutonomousTestResult = {\n        testId,\n        configurationId: testConfig.id,\n        winnerVariantId: statisticalAnalysis.winnerVariantId,\n        confidenceLevel: statisticalAnalysis.confidenceLevel,\n        improvementPercentage: statisticalAnalysis.improvementPercentage,\n        significanceReached: statisticalAnalysis.significanceReached,\n        recommendedAction: this.determineRecommendedAction(statisticalAnalysis, testConfig),\n        insights,\n        nextActions: recommendedActions,\n        completedAt: new Date()\n      };\n\n      // Store results\n      this.testResults.set(testId, result);\n\n      // Execute autonomous actions if confidence is high enough\n      if (result.confidenceLevel >= testConfig.autoApprovalThreshold) {\n        await this.executeAutonomousActions(result);\n      }\n\n      // Update test status\n      testConfig.status = 'completed';\n      this.activeTests.set(testId, testConfig);\n\n      // Emit completion event\n      this.emit('test_completed', {\n        testId,\n        result,\n        autoApplied: result.confidenceLevel >= testConfig.autoApprovalThreshold\n      });\n\n      return result;\n\n    } catch (error) {\n      logger.error('Test analysis failed', {\n        testId,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Continuously monitor and optimize all active tests\n   */\n  private startContinuousOptimization() {\n    setInterval(async () => {\n      try {\n        await this.optimizeActiveTests();\n      } catch (error) {\n        logger.error('Continuous optimization failed', {\n          error: error instanceof Error ? error.message : String(error)\n        });\n      }\n    }, 3600000); // Every hour\n\n    logger.info('Continuous optimization started');\n  }\n\n  /**\n   * Start processing test design queue\n   */\n  private startTestProcessing() {\n    this.processingInterval = setInterval(async () => {\n      try {\n        await this.processDesignQueue();\n      } catch (error) {\n        logger.error('Test processing failed', {\n          error: error instanceof Error ? error.message : String(error)\n        });\n      }\n    }, 300000); // Every 5 minutes\n\n    logger.info('Test processing started');\n  }\n\n  /**\n   * Start automated result analysis\n   */\n  private startResultAnalysis() {\n    this.analysisInterval = setInterval(async () => {\n      try {\n        await this.analyzeAllActiveTests();\n      } catch (error) {\n        logger.error('Result analysis failed', {\n          error: error instanceof Error ? error.message : String(error)\n        });\n      }\n    }, 1800000); // Every 30 minutes\n\n    logger.info('Result analysis started');\n  }\n\n  /**\n   * Analyze current performance to identify testing opportunities\n   */\n  private async analyzeCurrentPerformance(request: TestDesignRequest): Promise<any> {\n    try {\n      // Get performance data from the existing system\n      const performance = await this.getPerformanceData(request);\n      \n      // Identify optimization opportunities\n      const opportunities = this.identifyOptimizationOpportunities(performance);\n      \n      return {\n        current: performance,\n        opportunities,\n        benchmarks: await this.getBenchmarkData(request.channel)\n      };\n    } catch (error) {\n      logger.error('Performance analysis failed', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n      return {};\n    }\n  }\n\n  /**\n   * Generate test objectives based on AI analysis\n   */\n  private async generateTestObjectives(request: TestDesignRequest, performance: any): Promise<TestObjective[]> {\n    const objectives: TestObjective[] = [];\n\n    // Primary objective based on request\n    if (request.objective.includes('conversion')) {\n      objectives.push({\n        metric: 'conversion_rate',\n        targetImprovement: 15, // 15% improvement goal\n        weight: 1.0,\n        currentBaseline: performance.current?.conversionRate\n      });\n    }\n\n    if (request.objective.includes('engagement') || request.channel === 'email') {\n      objectives.push({\n        metric: 'open_rate',\n        targetImprovement: 10,\n        weight: 0.8,\n        currentBaseline: performance.current?.openRate\n      });\n\n      objectives.push({\n        metric: 'click_rate',\n        targetImprovement: 20,\n        weight: 0.9,\n        currentBaseline: performance.current?.clickRate\n      });\n    }\n\n    // Add revenue objective for high-value campaigns\n    if (performance.current?.revenue && performance.current.revenue > 1000) {\n      objectives.push({\n        metric: 'revenue',\n        targetImprovement: 25,\n        weight: 1.0,\n        currentBaseline: performance.current.revenue\n      });\n    }\n\n    return objectives;\n  }\n\n  /**\n   * Design test variants using AI\n   */\n  private async designTestVariants(request: TestDesignRequest, objectives: TestObjective[]): Promise<any[]> {\n    // This would use AI to generate variants based on best practices\n    // For now, return structured variant designs\n    const variants = [\n      { name: 'Control', isControl: true },\n      { name: 'Optimized Copy', modifications: ['subject_line', 'cta_text'] },\n      { name: 'Visual Enhancement', modifications: ['layout', 'images'] },\n      { name: 'Personalized', modifications: ['personalization', 'timing'] }\n    ];\n\n    return variants.slice(0, Math.min(4, request.constraints?.maxVariants || 4));\n  }\n\n  /**\n   * Calculate optimal test parameters\n   */\n  private async calculateOptimalTestParameters(objectives: TestObjective[], constraints?: Partial<TestConstraints>): Promise<{\n    minSampleSize: number;\n    trafficAllocation: number;\n    estimatedDuration: number;\n  }> {\n    // Statistical power calculation for minimum sample size\n    const targetPower = 0.8;\n    const alpha = 0.05;\n    const minDetectableEffect = Math.min(...objectives.map(o => o.targetImprovement / 100));\n    \n    // Simplified sample size calculation (would use proper statistical formulas)\n    const minSampleSize = Math.ceil(16 / (minDetectableEffect * minDetectableEffect));\n    \n    return {\n      minSampleSize: Math.max(1000, minSampleSize),\n      trafficAllocation: constraints?.minTrafficPerVariant ? \n        Math.max(20, constraints.minTrafficPerVariant * 4) : 50,\n      estimatedDuration: Math.ceil(minSampleSize / 100) // Rough estimate in hours\n    };\n  }\n\n  // Helper methods\n  private mapChannelToTestType(channel: string): AutonomousTestConfiguration['type'] {\n    const mapping: Record<string, AutonomousTestConfiguration['type']> = {\n      'email': 'email_campaign',\n      'form': 'form_optimization',\n      'landing_page': 'landing_page',\n      'workflow': 'workflow'\n    };\n    return mapping[channel] || 'email_campaign';\n  }\n\n  private determinePriority(objectives: TestObjective[], performance: any): 'low' | 'medium' | 'high' | 'critical' {\n    const avgWeight = objectives.reduce((sum, obj) => sum + obj.weight, 0) / objectives.length;\n    const hasRevenue = objectives.some(obj => obj.metric === 'revenue');\n    \n    if (hasRevenue && avgWeight > 0.8) return 'high';\n    if (avgWeight > 0.6) return 'medium';\n    return 'low';\n  }\n\n  private generateTargetMetrics(objectives: TestObjective[]): TestMetric[] {\n    return objectives.map(obj => ({\n      name: obj.metric,\n      type: obj.weight >= 0.8 ? 'primary' : 'secondary' as 'primary' | 'secondary',\n      threshold: obj.targetImprovement,\n      direction: 'increase' as const\n    }));\n  }\n\n  private requiresHumanApproval(config: AutonomousTestConfiguration): boolean {\n    return config.priority === 'critical' || \n           config.trafficAllocation > 80 ||\n           config.objectives.some(obj => obj.metric === 'revenue' && obj.targetImprovement > 50);\n  }\n\n  // Placeholder methods for integration with existing A/B testing system\n  private async createActualABTest(config: AutonomousTestConfiguration): Promise<string> {\n    // Integration with existing A/B testing API\n    return `ab_test_${config.id}`;\n  }\n\n  private async startTest(abTestId: string, config: AutonomousTestConfiguration): Promise<void> {\n    // Start the actual test using existing infrastructure\n  }\n\n  private async getTestResults(testId: string): Promise<any> {\n    // Get results from existing A/B testing system\n    return {};\n  }\n\n  private async performStatisticalAnalysis(results: any, config: AutonomousTestConfiguration): Promise<any> {\n    // Use existing statistical analysis\n    return {\n      winnerVariantId: 'variant_1',\n      confidenceLevel: 0.96,\n      improvementPercentage: 18.5,\n      significanceReached: true\n    };\n  }\n\n  private async generateAIInsights(results: any, config: AutonomousTestConfiguration): Promise<TestInsight[]> {\n    return [\n      {\n        type: 'performance',\n        insight: 'Subject line optimization shows strongest impact on open rates',\n        confidence: 0.9,\n        actionable: true,\n        impact: 'high',\n        suggestedFollowUp: 'Create follow-up test focusing on subject line variations'\n      }\n    ];\n  }\n\n  private async determineRecommendedActions(analysis: any, insights: TestInsight[], config: AutonomousTestConfiguration): Promise<AutonomousAction[]> {\n    return [\n      {\n        type: 'apply_winner',\n        description: 'Apply winning variant to campaign',\n        priority: 'high',\n        estimatedImpact: analysis.improvementPercentage,\n        autoExecute: analysis.confidenceLevel >= config.autoApprovalThreshold,\n        requiresApproval: false\n      }\n    ];\n  }\n\n  private determineRecommendedAction(analysis: any, config: AutonomousTestConfiguration): AutonomousTestResult['recommendedAction'] {\n    if (analysis.significanceReached && analysis.confidenceLevel >= config.autoApprovalThreshold) {\n      return 'apply_winner';\n    }\n    if (analysis.confidenceLevel >= 0.8) {\n      return 'continue_testing';\n    }\n    return 'stop_inconclusive';\n  }\n\n  private async executeAutonomousActions(result: AutonomousTestResult): Promise<void> {\n    for (const action of result.nextActions) {\n      if (action.autoExecute && !action.requiresApproval) {\n        try {\n          await this.executeAction(action, result);\n        } catch (error) {\n          logger.error('Failed to execute autonomous action', {\n            action: action.type,\n            testId: result.testId,\n            error: error instanceof Error ? error.message : String(error)\n          });\n        }\n      }\n    }\n  }\n\n  private async executeAction(action: AutonomousAction, result: AutonomousTestResult): Promise<void> {\n    // Execute the specific action\n    switch (action.type) {\n      case 'apply_winner':\n        await this.applyWinningVariant(result);\n        break;\n      case 'create_followup_test':\n        await this.createFollowUpTest(result);\n        break;\n      default:\n        logger.info('Action type not implemented for autonomous execution', {\n          actionType: action.type\n        });\n    }\n  }\n\n  private async applyWinningVariant(result: AutonomousTestResult): Promise<void> {\n    // Apply winning variant using existing infrastructure\n    logger.info('Applying winning variant autonomously', {\n      testId: result.testId,\n      winnerVariantId: result.winnerVariantId,\n      improvement: result.improvementPercentage\n    });\n  }\n\n  private async createFollowUpTest(result: AutonomousTestResult): Promise<void> {\n    // Create follow-up test based on insights\n    logger.info('Creating autonomous follow-up test', {\n      originalTestId: result.testId,\n      insights: result.insights.length\n    });\n  }\n\n  // Processing methods\n  private async processDesignQueue(): Promise<void> {\n    while (this.designQueue.length > 0) {\n      const request = this.designQueue.shift();\n      if (request) {\n        try {\n          const testConfig = await this.designAutonomousTest(request);\n          await this.executeAutonomousTest(testConfig.id, true);\n        } catch (error) {\n          logger.error('Failed to process design request', {\n            request,\n            error: error instanceof Error ? error.message : String(error)\n          });\n        }\n      }\n    }\n  }\n\n  private async analyzeAllActiveTests(): Promise<void> {\n    for (const [testId, config] of this.activeTests.entries()) {\n      if (config.status === 'running') {\n        try {\n          await this.analyzeTestResults(testId);\n        } catch (error) {\n          logger.error('Failed to analyze active test', {\n            testId,\n            error: error instanceof Error ? error.message : String(error)\n          });\n        }\n      }\n    }\n  }\n\n  private async optimizeActiveTests(): Promise<void> {\n    // Continuous optimization logic\n    for (const [testId, config] of this.activeTests.entries()) {\n      if (config.status === 'running') {\n        // Check for early stopping opportunities\n        // Adjust traffic allocation if needed\n        // Identify performance issues\n      }\n    }\n  }\n\n  // Utility methods\n  private async getPerformanceData(request: TestDesignRequest): Promise<any> {\n    // Get performance data from existing analytics\n    return {};\n  }\n\n  private identifyOptimizationOpportunities(performance: any): string[] {\n    // Identify areas for improvement\n    return [];\n  }\n\n  private async getBenchmarkData(channel: string): Promise<any> {\n    // Get industry benchmarks\n    return {};\n  }\n\n  private scheduleAutomatedAnalysis(testId: string, abTestId: string): void {\n    // Schedule periodic analysis\n    setTimeout(() => {\n      this.analyzeTestResults(testId).catch(error => {\n        logger.error('Scheduled analysis failed', { testId, error });\n      });\n    }, 24 * 60 * 60 * 1000); // 24 hours\n  }\n\n  private async evaluateAutomaticTestingOpportunity(campaign: any): Promise<void> {\n    // Evaluate if campaign would benefit from testing\n  }\n\n  private async recommendTestingStrategy(metrics: any): Promise<void> {\n    // Recommend testing based on performance decline\n  }\n\n  private async evaluateTestingOpportunity(opportunity: any): Promise<void> {\n    // Evaluate strategic testing opportunities\n  }\n\n  /**\n   * Public API methods\n   */\n  async requestAutonomousTest(request: TestDesignRequest): Promise<string> {\n    this.designQueue.push(request);\n    return 'Test design request queued for autonomous processing';\n  }\n\n  async getActiveTests(): Promise<AutonomousTestConfiguration[]> {\n    return Array.from(this.activeTests.values());\n  }\n\n  async getTestResults(testId: string): Promise<AutonomousTestResult | null> {\n    return this.testResults.get(testId) || null;\n  }\n\n  async pauseTest(testId: string): Promise<boolean> {\n    const config = this.activeTests.get(testId);\n    if (config && config.status === 'running') {\n      config.status = 'paused';\n      this.activeTests.set(testId, config);\n      return true;\n    }\n    return false;\n  }\n\n  async resumeTest(testId: string): Promise<boolean> {\n    const config = this.activeTests.get(testId);\n    if (config && config.status === 'paused') {\n      config.status = 'running';\n      this.activeTests.set(testId, config);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Get autonomous testing metrics\n   */\n  async getAutonomousTestingMetrics(): Promise<{\n    activeTests: number;\n    completedTests: number;\n    averageImprovement: number;\n    autoAppliedTests: number;\n    successRate: number;\n  }> {\n    const activeCount = Array.from(this.activeTests.values()).filter(t => t.status === 'running').length;\n    const completedCount = Array.from(this.activeTests.values()).filter(t => t.status === 'completed').length;\n    const results = Array.from(this.testResults.values());\n    const avgImprovement = results.reduce((sum, r) => sum + r.improvementPercentage, 0) / Math.max(1, results.length);\n    const autoAppliedCount = results.filter(r => r.confidenceLevel >= 0.95).length;\n    const successRate = results.filter(r => r.significanceReached).length / Math.max(1, results.length);\n\n    return {\n      activeTests: activeCount,\n      completedTests: completedCount,\n      averageImprovement: avgImprovement,\n      autoAppliedTests: autoAppliedCount,\n      successRate: successRate * 100\n    };\n  }\n\n  /**\n   * Cleanup and destroy\n   */\n  destroy() {\n    if (this.processingInterval) {\n      clearInterval(this.processingInterval);\n      this.processingInterval = null;\n    }\n    \n    if (this.analysisInterval) {\n      clearInterval(this.analysisInterval);\n      this.analysisInterval = null;\n    }\n    \n    this.removeAllListeners();\n    logger.info('Autonomous A/B testing engine destroyed');\n  }\n}\n\n// Export singleton instance\nexport const autonomousABTestingEngine = new AutonomousABTestingEngine();\n\n// Export types and class\nexport { AutonomousABTestingEngine };"],"names":["AutonomousABTestingEngine","autonomousABTestingEngine","EventEmitter","constructor","activeTests","Map","testResults","designQueue","processingInterval","analysisInterval","initializeEngine","logger","info","startTestProcessing","startResultAnalysis","startContinuousOptimization","connectToExistingSystems","error","Error","message","String","on","campaign","evaluateAutomaticTestingOpportunity","metrics","recommendTestingStrategy","strategicDecisionEngine","opportunity","evaluateTestingOpportunity","designAutonomousTest","request","tracer","trace","getTracer","startActiveSpan","span","setAttributes","channel","objective","campaignId","currentPerformance","analyzeCurrentPerformance","objectives","generateTestObjectives","variants","designTestVariants","testParameters","calculateOptimalTestParameters","constraints","testConfig","id","Date","now","Math","random","toString","substr","name","type","mapChannelToTestType","priority","determinePriority","maxVariants","minTrafficPerVariant","africanTimezones","businessHours","targetMetrics","generateTargetMetrics","autoApprovalThreshold","maxTestDuration","minSampleSize","trafficAllocation","created","status","set","emit","testId","length","estimatedDuration","setStatus","code","end","executeAutonomousTest","autoApprove","get","requiresHumanApproval","config","reason","abTestId","createActualABTest","startTest","scheduleAutomatedAnalysis","duration","analyzeTestResults","rawResults","getTestResults","statisticalAnalysis","performStatisticalAnalysis","insights","generateAIInsights","recommendedActions","determineRecommendedActions","result","configurationId","winnerVariantId","confidenceLevel","improvementPercentage","significanceReached","recommendedAction","determineRecommendedAction","nextActions","completedAt","executeAutonomousActions","autoApplied","setInterval","optimizeActiveTests","processDesignQueue","analyzeAllActiveTests","performance","getPerformanceData","opportunities","identifyOptimizationOpportunities","current","benchmarks","getBenchmarkData","includes","push","metric","targetImprovement","weight","currentBaseline","conversionRate","openRate","clickRate","revenue","isControl","modifications","slice","min","targetPower","alpha","minDetectableEffect","map","o","ceil","max","mapping","avgWeight","reduce","sum","obj","hasRevenue","some","threshold","direction","results","insight","confidence","actionable","impact","suggestedFollowUp","analysis","description","estimatedImpact","autoExecute","requiresApproval","action","executeAction","applyWinningVariant","createFollowUpTest","actionType","improvement","originalTestId","shift","entries","setTimeout","catch","requestAutonomousTest","getActiveTests","Array","from","values","pauseTest","resumeTest","getAutonomousTestingMetrics","activeCount","filter","t","completedCount","avgImprovement","r","autoAppliedCount","successRate","completedTests","averageImprovement","autoAppliedTests","destroy","clearInterval","removeAllListeners"],"mappings":"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"}