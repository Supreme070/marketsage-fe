{"version":3,"sources":["/Users/supreme/Desktop/marketsage/src/lib/ml/error-handling.ts"],"sourcesContent":["/**\n * Error Handling & Type Safety Module\n * Replaces @ts-ignore statements and provides robust error handling\n */\n\nimport { logger } from '@/lib/logger';\n\n// Custom error classes for different ML scenarios\nexport class MLError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public details?: Record<string, unknown>\n  ) {\n    super(message);\n    this.name = 'MLError';\n  }\n}\n\nexport class DataValidationError extends MLError {\n  constructor(message: string, details?: Record<string, unknown>) {\n    super(message, 'DATA_VALIDATION_ERROR', details);\n    this.name = 'DataValidationError';\n  }\n}\n\nexport class ModelTrainingError extends MLError {\n  constructor(message: string, details?: Record<string, unknown>) {\n    super(message, 'MODEL_TRAINING_ERROR', details);\n    this.name = 'ModelTrainingError';\n  }\n}\n\nexport class PredictionError extends MLError {\n  constructor(message: string, details?: Record<string, unknown>) {\n    super(message, 'PREDICTION_ERROR', details);\n    this.name = 'PredictionError';\n  }\n}\n\nexport class FeatureEngineeringError extends MLError {\n  constructor(message: string, details?: Record<string, unknown>) {\n    super(message, 'FEATURE_ENGINEERING_ERROR', details);\n    this.name = 'FeatureEngineeringError';\n  }\n}\n\n// Type-safe wrappers for external libraries\nexport class SafeNLPLibrary {\n  private nlpInstance: any = null;\n  private sentimentInstance: any = null;\n\n  async initializeNLP(): Promise<boolean> {\n    try {\n      // Try to load compromise\n      const { default: nlp } = await this.safeImport('compromise');\n      this.nlpInstance = nlp;\n      return true;\n    } catch (error) {\n      logger.warn('Failed to load NLP library, using fallback', {\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      return false;\n    }\n  }\n\n  async initializeSentiment(): Promise<boolean> {\n    try {\n      // Try to load sentiment\n      const { default: Sentiment } = await this.safeImport('sentiment');\n      this.sentimentInstance = new Sentiment();\n      return true;\n    } catch (error) {\n      logger.warn('Failed to load Sentiment library, using fallback', {\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      return false;\n    }\n  }\n\n  analyzeText(text: string): {\n    words: string[];\n    sentences: string[];\n    nouns: string[];\n    verbs: string[];\n    adjectives: string[];\n  } {\n    if (!this.nlpInstance) {\n      return this.fallbackTextAnalysis(text);\n    }\n\n    try {\n      const doc = this.nlpInstance(text);\n      return {\n        words: text.split(/\\s+/).filter(w => w.length > 0),\n        sentences: text.split(/[.!?]+/).filter(s => s.trim().length > 0),\n        nouns: doc.nouns().out('array') || [],\n        verbs: doc.verbs().out('array') || [],\n        adjectives: doc.adjectives().out('array') || []\n      };\n    } catch (error) {\n      logger.warn('NLP analysis failed, using fallback', {\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      return this.fallbackTextAnalysis(text);\n    }\n  }\n\n  analyzeSentiment(text: string): {\n    score: number;\n    comparative: number;\n    positive: string[];\n    negative: string[];\n  } {\n    if (!this.sentimentInstance) {\n      return this.fallbackSentimentAnalysis(text);\n    }\n\n    try {\n      const result = this.sentimentInstance.analyze(text);\n      return {\n        score: result.score || 0,\n        comparative: result.comparative || 0,\n        positive: result.positive || [],\n        negative: result.negative || []\n      };\n    } catch (error) {\n      logger.warn('Sentiment analysis failed, using fallback', {\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      return this.fallbackSentimentAnalysis(text);\n    }\n  }\n\n  private async safeImport(moduleName: string): Promise<any> {\n    try {\n      return await import(moduleName);\n    } catch (error) {\n      throw new Error(`Failed to import ${moduleName}: ${error}`);\n    }\n  }\n\n  private fallbackTextAnalysis(text: string) {\n    const words = text.split(/\\s+/).filter(w => w.length > 0);\n    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);\n    \n    // Simple heuristic-based extraction\n    const nouns = words.filter(word => \n      word.length > 3 && \n      !['the', 'and', 'but', 'for', 'are', 'with'].includes(word.toLowerCase())\n    );\n    \n    return {\n      words,\n      sentences,\n      nouns: nouns.slice(0, 10),\n      verbs: [],\n      adjectives: []\n    };\n  }\n\n  private fallbackSentimentAnalysis(text: string) {\n    const positiveWords = ['good', 'great', 'excellent', 'amazing', 'wonderful', 'fantastic'];\n    const negativeWords = ['bad', 'terrible', 'awful', 'horrible', 'disappointing', 'poor'];\n    \n    const words = text.toLowerCase().split(/\\s+/);\n    let score = 0;\n    const positive: string[] = [];\n    const negative: string[] = [];\n    \n    words.forEach(word => {\n      if (positiveWords.includes(word)) {\n        score += 1;\n        positive.push(word);\n      } else if (negativeWords.includes(word)) {\n        score -= 1;\n        negative.push(word);\n      }\n    });\n    \n    return {\n      score,\n      comparative: score / Math.max(words.length, 1),\n      positive,\n      negative\n    };\n  }\n}\n\n// Input validation utilities\nexport class InputValidator {\n  static validateNumber(\n    value: unknown,\n    fieldName: string,\n    options: {\n      min?: number;\n      max?: number;\n      required?: boolean;\n    } = {}\n  ): number {\n    if (value === null || value === undefined) {\n      if (options.required) {\n        throw new DataValidationError(`${fieldName} is required`);\n      }\n      return 0;\n    }\n\n    const num = Number(value);\n    if (isNaN(num) || !isFinite(num)) {\n      throw new DataValidationError(`${fieldName} must be a valid number`, {\n        value,\n        fieldName\n      });\n    }\n\n    if (options.min !== undefined && num < options.min) {\n      throw new DataValidationError(`${fieldName} must be >= ${options.min}`, {\n        value: num,\n        min: options.min\n      });\n    }\n\n    if (options.max !== undefined && num > options.max) {\n      throw new DataValidationError(`${fieldName} must be <= ${options.max}`, {\n        value: num,\n        max: options.max\n      });\n    }\n\n    return num;\n  }\n\n  static validateString(\n    value: unknown,\n    fieldName: string,\n    options: {\n      minLength?: number;\n      maxLength?: number;\n      required?: boolean;\n      pattern?: RegExp;\n    } = {}\n  ): string {\n    if (value === null || value === undefined) {\n      if (options.required) {\n        throw new DataValidationError(`${fieldName} is required`);\n      }\n      return '';\n    }\n\n    const str = String(value);\n\n    if (options.minLength !== undefined && str.length < options.minLength) {\n      throw new DataValidationError(`${fieldName} must be at least ${options.minLength} characters`, {\n        value: str,\n        actualLength: str.length,\n        minLength: options.minLength\n      });\n    }\n\n    if (options.maxLength !== undefined && str.length > options.maxLength) {\n      throw new DataValidationError(`${fieldName} must be at most ${options.maxLength} characters`, {\n        value: str,\n        actualLength: str.length,\n        maxLength: options.maxLength\n      });\n    }\n\n    if (options.pattern && !options.pattern.test(str)) {\n      throw new DataValidationError(`${fieldName} format is invalid`, {\n        value: str,\n        pattern: options.pattern.toString()\n      });\n    }\n\n    return str;\n  }\n\n  static validateArray<T>(\n    value: unknown,\n    fieldName: string,\n    validator: (item: unknown, index: number) => T,\n    options: {\n      minLength?: number;\n      maxLength?: number;\n      required?: boolean;\n    } = {}\n  ): T[] {\n    if (value === null || value === undefined) {\n      if (options.required) {\n        throw new DataValidationError(`${fieldName} is required`);\n      }\n      return [];\n    }\n\n    if (!Array.isArray(value)) {\n      throw new DataValidationError(`${fieldName} must be an array`, {\n        value,\n        actualType: typeof value\n      });\n    }\n\n    if (options.minLength !== undefined && value.length < options.minLength) {\n      throw new DataValidationError(`${fieldName} must have at least ${options.minLength} items`, {\n        actualLength: value.length,\n        minLength: options.minLength\n      });\n    }\n\n    if (options.maxLength !== undefined && value.length > options.maxLength) {\n      throw new DataValidationError(`${fieldName} must have at most ${options.maxLength} items`, {\n        actualLength: value.length,\n        maxLength: options.maxLength\n      });\n    }\n\n    return value.map((item, index) => {\n      try {\n        return validator(item, index);\n      } catch (error) {\n        throw new DataValidationError(`${fieldName}[${index}] is invalid`, {\n          error: error instanceof Error ? error.message : 'Unknown error',\n          index,\n          value: item\n        });\n      }\n    });\n  }\n\n  static validateEmail(value: unknown, fieldName = 'email'): string {\n    const email = this.validateString(value, fieldName, {\n      required: true,\n      pattern: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n    });\n    return email;\n  }\n\n  static validateFeatureVector(\n    value: unknown,\n    expectedLength: number,\n    fieldName = 'features'\n  ): number[] {\n    const features = this.validateArray(\n      value,\n      fieldName,\n      (item, index) => this.validateNumber(item, `${fieldName}[${index}]`, { required: true }),\n      { required: true, minLength: expectedLength, maxLength: expectedLength }\n    );\n    return features;\n  }\n}\n\n// Safe execution wrapper\nexport class SafeExecutor {\n  static async executeWithFallback<T>(\n    primaryFn: () => Promise<T>,\n    fallbackFn: () => Promise<T>,\n    operationName: string\n  ): Promise<T> {\n    try {\n      return await primaryFn();\n    } catch (error) {\n      logger.warn(`${operationName} primary method failed, using fallback`, {\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      try {\n        return await fallbackFn();\n      } catch (fallbackError) {\n        logger.error(`${operationName} fallback also failed`, {\n          originalError: error instanceof Error ? error.message : 'Unknown error',\n          fallbackError: fallbackError instanceof Error ? fallbackError.message : 'Unknown error'\n        });\n        throw fallbackError;\n      }\n    }\n  }\n\n  static executeWithRetry<T>(\n    fn: () => T,\n    maxRetries = 3,\n    delay = 1000\n  ): Promise<T> {\n    return new Promise((resolve, reject) => {\n      let attempts = 0;\n\n      const attempt = () => {\n        try {\n          const result = fn();\n          resolve(result);\n        } catch (error) {\n          attempts++;\n          if (attempts >= maxRetries) {\n            reject(error);\n          } else {\n            setTimeout(attempt, delay * attempts);\n          }\n        }\n      };\n\n      attempt();\n    });\n  }\n\n  static validateAndExecute<T>(\n    data: unknown,\n    validator: (data: unknown) => void,\n    executor: (data: any) => T,\n    operationName: string\n  ): T {\n    try {\n      validator(data);\n      return executor(data);\n    } catch (error) {\n      if (error instanceof DataValidationError) {\n        throw error;\n      }\n      throw new MLError(`${operationName} execution failed`, 'EXECUTION_ERROR', {\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n    }\n  }\n}\n\n// Configuration validation\nexport interface MLConfig {\n  modelType: 'churn' | 'ltv' | 'content' | 'engagement';\n  features: string[];\n  scalingMethod: 'minmax' | 'standard' | 'robust' | 'quantile';\n  validationSplit: number;\n  maxTrainingTime: number;\n  enableFallbacks: boolean;\n}\n\nexport class ConfigValidator {\n  static validateMLConfig(config: unknown): MLConfig {\n    if (!config || typeof config !== 'object') {\n      throw new DataValidationError('Configuration must be an object');\n    }\n\n    const c = config as Record<string, unknown>;\n\n    const modelType = InputValidator.validateString(c.modelType, 'modelType', {\n      required: true\n    });\n\n    if (!['churn', 'ltv', 'content', 'engagement'].includes(modelType)) {\n      throw new DataValidationError('Invalid model type', {\n        validTypes: ['churn', 'ltv', 'content', 'engagement'],\n        provided: modelType\n      });\n    }\n\n    const features = InputValidator.validateArray(\n      c.features,\n      'features',\n      (item) => InputValidator.validateString(item, 'feature', { required: true }),\n      { required: true, minLength: 1 }\n    );\n\n    const scalingMethod = InputValidator.validateString(c.scalingMethod, 'scalingMethod', {\n      required: true\n    });\n\n    if (!['minmax', 'standard', 'robust', 'quantile'].includes(scalingMethod)) {\n      throw new DataValidationError('Invalid scaling method', {\n        validMethods: ['minmax', 'standard', 'robust', 'quantile'],\n        provided: scalingMethod\n      });\n    }\n\n    const validationSplit = InputValidator.validateNumber(c.validationSplit, 'validationSplit', {\n      required: true,\n      min: 0.1,\n      max: 0.5\n    });\n\n    const maxTrainingTime = InputValidator.validateNumber(c.maxTrainingTime, 'maxTrainingTime', {\n      required: true,\n      min: 1000,\n      max: 300000\n    });\n\n    const enableFallbacks = Boolean(c.enableFallbacks);\n\n    return {\n      modelType: modelType as MLConfig['modelType'],\n      features,\n      scalingMethod: scalingMethod as MLConfig['scalingMethod'],\n      validationSplit,\n      maxTrainingTime,\n      enableFallbacks\n    };\n  }\n}\n\n// Global error boundary for ML operations\nexport class MLErrorBoundary {\n  private static instance: MLErrorBoundary;\n  private errorHandlers: Map<string, (error: MLError) => void> = new Map();\n\n  static getInstance(): MLErrorBoundary {\n    if (!this.instance) {\n      this.instance = new MLErrorBoundary();\n    }\n    return this.instance;\n  }\n\n  registerErrorHandler(errorType: string, handler: (error: MLError) => void): void {\n    this.errorHandlers.set(errorType, handler);\n  }\n\n  handleError(error: unknown, context: string): never {\n    let mlError: MLError;\n\n    if (error instanceof MLError) {\n      mlError = error;\n    } else if (error instanceof Error) {\n      mlError = new MLError(error.message, 'UNKNOWN_ERROR', { context });\n    } else {\n      mlError = new MLError('Unknown error occurred', 'UNKNOWN_ERROR', { context, error });\n    }\n\n    // Log error\n    logger.error(`ML Error in ${context}`, {\n      code: mlError.code,\n      message: mlError.message,\n      details: mlError.details\n    });\n\n    // Call registered handler if available\n    const handler = this.errorHandlers.get(mlError.code);\n    if (handler) {\n      try {\n        handler(mlError);\n      } catch (handlerError) {\n        logger.error('Error handler failed', {\n          originalError: mlError.message,\n          handlerError: handlerError instanceof Error ? handlerError.message : 'Unknown'\n        });\n      }\n    }\n\n    throw mlError;\n  }\n}\n\n// Export instances\nexport const safeNLP = new SafeNLPLibrary();\nexport const errorBoundary = MLErrorBoundary.getInstance(); "],"names":["ConfigValidator","DataValidationError","FeatureEngineeringError","InputValidator","MLError","MLErrorBoundary","ModelTrainingError","PredictionError","SafeExecutor","SafeNLPLibrary","errorBoundary","safeNLP","Error","constructor","message","code","details","name","initializeNLP","default","nlp","safeImport","nlpInstance","error","logger","warn","initializeSentiment","Sentiment","sentimentInstance","analyzeText","text","fallbackTextAnalysis","doc","words","split","filter","w","length","sentences","s","trim","nouns","out","verbs","adjectives","analyzeSentiment","fallbackSentimentAnalysis","result","analyze","score","comparative","positive","negative","moduleName","word","includes","toLowerCase","slice","positiveWords","negativeWords","forEach","push","Math","max","validateNumber","value","fieldName","options","undefined","required","num","Number","isNaN","isFinite","min","validateString","str","String","minLength","actualLength","maxLength","pattern","test","toString","validateArray","validator","Array","isArray","actualType","map","item","index","validateEmail","email","validateFeatureVector","expectedLength","features","executeWithFallback","primaryFn","fallbackFn","operationName","fallbackError","originalError","executeWithRetry","fn","maxRetries","delay","Promise","resolve","reject","attempts","attempt","setTimeout","validateAndExecute","data","executor","validateMLConfig","config","c","modelType","validTypes","provided","scalingMethod","validMethods","validationSplit","maxTrainingTime","enableFallbacks","Boolean","getInstance","instance","registerErrorHandler","errorType","handler","errorHandlers","set","handleError","context","mlError","get","handlerError","Map"],"mappings":"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"}