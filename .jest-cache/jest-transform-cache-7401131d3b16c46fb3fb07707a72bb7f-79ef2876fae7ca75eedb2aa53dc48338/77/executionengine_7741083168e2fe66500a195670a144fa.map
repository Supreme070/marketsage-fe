{"version":3,"sources":["/Users/supreme/Desktop/marketsage/src/lib/workflow/execution-engine.ts"],"sourcesContent":["import prisma from '@/lib/db/prisma';\nimport { logger } from '@/lib/logger';\nimport { workflowQueue, delayQueue, type WorkflowJobData } from '@/lib/queue';\nimport { sendTrackedEmail } from '@/lib/email-service';\nimport { sendSMS } from '@/lib/sms-service';\nimport { workflowABTestingService } from '@/lib/workflow/ab-testing-service';\nimport { workflowRetryManager } from '@/lib/workflow/retry-mechanism';\nimport { workflowCostTracker } from '@/lib/workflow/cost-tracking';\nimport { v4 as uuidv4 } from 'uuid';\nimport { \n  workflowRateLimiter, \n  emailRateLimiter, \n  smsRateLimiter,\n  systemWorkflowRateLimiter,\n  checkMultipleRateLimits \n} from '@/lib/rate-limiter';\nimport { \n  executeGenericApiCall,\n  executeCrmAction,\n  executePaymentWebhook,\n  type GenericApiConfiguration,\n  type CrmActionConfiguration,\n  type PaymentWebhookConfiguration\n} from '@/lib/workflow/api-integration-nodes';\n\n// Types\ninterface WorkflowNode {\n  id: string;\n  type: string;\n  data: {\n    label: string;\n    description?: string;\n    properties: Record<string, any>;\n  };\n  position: { x: number; y: number };\n}\n\ninterface WorkflowEdge {\n  id: string;\n  source: string;\n  target: string;\n  sourceHandle?: string;\n  targetHandle?: string;\n}\n\ninterface WorkflowDefinition {\n  nodes: WorkflowNode[];\n  edges: WorkflowEdge[];\n  metadata?: Record<string, any>;\n}\n\ninterface ExecutionContext {\n  contact: any;\n  workflow: any;\n  variables: Record<string, any>;\n  stepOutputs: Record<string, any>;\n}\n\nexport class WorkflowExecutionEngine {\n  /**\n   * Start a new workflow execution for a contact\n   */\n  async startWorkflowExecution(\n    workflowId: string, \n    contactId: string, \n    triggerData?: Record<string, any>\n  ): Promise<string> {\n    try {\n      // Check rate limits before starting workflow\n      const rateLimitCheck = await checkMultipleRateLimits([\n        { \n          limiter: workflowRateLimiter, \n          identifier: contactId, \n          name: 'user_workflow' \n        },\n        { \n          limiter: systemWorkflowRateLimiter, \n          identifier: 'global', \n          name: 'system_workflow' \n        }\n      ]);\n\n      if (!rateLimitCheck.allowed) {\n        const error = `Workflow rate limit exceeded: ${rateLimitCheck.failedCheck}`;\n        logger.warn(error, { workflowId, contactId, rateLimitCheck });\n        throw new Error(error);\n      }\n\n      // Check if execution already exists\n      const existingExecution = await prisma.workflowExecution.findUnique({\n        where: { workflowId_contactId: { workflowId, contactId } },\n      });\n\n      if (existingExecution && existingExecution.status === 'RUNNING') {\n        logger.info(`Workflow execution already running`, { workflowId, contactId });\n        return existingExecution.id;\n      }\n\n      // Get workflow and contact data\n      const [workflow, contact] = await Promise.all([\n        prisma.workflow.findUnique({ where: { id: workflowId } }),\n        prisma.contact.findUnique({ where: { id: contactId } }),\n      ]);\n\n      if (!workflow || !contact) {\n        throw new Error(`Workflow or contact not found: ${workflowId}, ${contactId}`);\n      }\n\n      if (workflow.status !== 'ACTIVE') {\n        throw new Error(`Workflow is not active: ${workflowId}`);\n      }\n\n      // Parse workflow definition\n      let definition: WorkflowDefinition = JSON.parse(workflow.definition);\n      \n      // Check for A/B test variant (safe integration point)\n      try {\n        const abTestVariant = await workflowABTestingService.assignWorkflowVariant(workflowId, contactId);\n        if (abTestVariant) {\n          definition = abTestVariant.workflowDefinition;\n          logger.info('Using A/B test variant for workflow execution', {\n            workflowId,\n            contactId,\n            variantId: abTestVariant.variantId\n          });\n        }\n      } catch (abTestError) {\n        // A/B testing errors should not break workflow execution\n        logger.warn('A/B test assignment failed, using original workflow', {\n          workflowId,\n          contactId,\n          error: abTestError.message\n        });\n      }\n      \n      // Find trigger nodes\n      const triggerNodes = definition.nodes.filter(node => node.type === 'triggerNode');\n      if (triggerNodes.length === 0) {\n        throw new Error(`No trigger nodes found in workflow: ${workflowId}`);\n      }\n\n      // Create execution record\n      const execution = await prisma.workflowExecution.create({\n        data: {\n          id: uuidv4(),\n          workflowId,\n          contactId,\n          status: 'RUNNING',\n          context: JSON.stringify({\n            triggerData: triggerData || {},\n            variables: {},\n            stepOutputs: {},\n            rateLimits: rateLimitCheck.results, // Store rate limit info\n          }),\n          startedAt: new Date(),\n        },\n      });\n\n      // Start from the first trigger node\n      const firstTrigger = triggerNodes[0];\n      await this.executeStep(execution.id, firstTrigger.id);\n\n      logger.info(`Started workflow execution`, { \n        executionId: execution.id, \n        workflowId, \n        contactId,\n        remainingWorkflowLimits: rateLimitCheck.results\n      });\n\n      return execution.id;\n    } catch (error) {\n      logger.error('Failed to start workflow execution', { error, workflowId, contactId });\n      throw error;\n    }\n  }\n\n  /**\n   * Execute a workflow step retry (called from retry queue)\n   */\n  async executeWorkflowStep(executionId: string, stepId: string): Promise<void> {\n    logger.info('Executing workflow step retry', { executionId, stepId });\n    \n    try {\n      // Get execution to ensure it's still valid\n      const execution = await prisma.workflowExecution.findUnique({\n        where: { id: executionId },\n        select: { status: true }\n      });\n      \n      if (!execution) {\n        throw new Error(`Execution not found: ${executionId}`);\n      }\n      \n      if (execution.status !== 'RUNNING') {\n        logger.warn('Skipping retry for non-running execution', { executionId, status: execution.status });\n        return;\n      }\n      \n      // Execute the step\n      await this.executeStep(executionId, stepId);\n      \n    } catch (error) {\n      logger.error('Failed to execute workflow step retry', { error, executionId, stepId });\n      throw error;\n    }\n  }\n\n  /**\n   * Execute a specific workflow step\n   */\n  async executeStep(executionId: string, stepId: string): Promise<void> {\n    try {\n      // Get execution data\n      const execution = await prisma.workflowExecution.findUnique({\n        where: { id: executionId },\n        include: { workflow: true, contact: true },\n      });\n\n      if (!execution || execution.status !== 'RUNNING') {\n        logger.warn(`Execution not found or not running: ${executionId}`);\n        return;\n      }\n\n      // Parse workflow definition\n      const definition: WorkflowDefinition = JSON.parse(execution.workflow.definition);\n      const node = definition.nodes.find(n => n.id === stepId);\n      \n      if (!node) {\n        throw new Error(`Step not found: ${stepId}`);\n      }\n\n      // Create step execution record\n      const stepExecution = await prisma.workflowExecutionStep.create({\n        data: {\n          id: uuidv4(),\n          executionId,\n          stepId,\n          stepType: node.type,\n          status: 'RUNNING',\n          startedAt: new Date(),\n        },\n      });\n\n      // Parse execution context\n      const context: ExecutionContext = JSON.parse(execution.context);\n      context.contact = execution.contact;\n      context.workflow = execution.workflow;\n\n      // Execute the step based on its type\n      let stepResult: any = null;\n      \n      switch (node.type) {\n        case 'triggerNode':\n          stepResult = await this.executeTriggerNode(node, context);\n          break;\n        case 'actionNode':\n          stepResult = await this.executeActionNode(node, context);\n          break;\n        case 'conditionNode':\n          stepResult = await this.executeConditionNode(node, context);\n          break;\n        case 'webhookNode':\n          stepResult = await this.executeWebhookNode(node, context);\n          break;\n        case 'databaseNode':\n          stepResult = await this.executeDatabaseNode(node, context);\n          break;\n        case 'delayNode':\n          stepResult = await this.executeDelayNode(node, context);\n          break;\n        case 'splitNode':\n          stepResult = await this.executeSplitNode(node, context);\n          break;\n        case 'transformNode':\n          stepResult = await this.executeTransformNode(node, context);\n          break;\n        case 'apiCallNode':\n          stepResult = await this.executeApiCallNode(node, context);\n          break;\n        case 'crmActionNode':\n          stepResult = await this.executeCrmActionNode(node, context);\n          break;\n        case 'paymentWebhookNode':\n          stepResult = await this.executePaymentWebhookNode(node, context);\n          break;\n        default:\n          throw new Error(`Unknown node type: ${node.type}`);\n      }\n\n      // Update step execution\n      await prisma.workflowExecutionStep.update({\n        where: { id: stepExecution.id },\n        data: {\n          status: 'COMPLETED',\n          completedAt: new Date(),\n          output: JSON.stringify(stepResult),\n        },\n      });\n      \n      // Mark step as successful in retry manager\n      await workflowRetryManager.markStepSuccess(executionId, stepId);\n\n      // Store step output in context\n      context.stepOutputs[stepId] = stepResult;\n\n      // Update execution context\n      await prisma.workflowExecution.update({\n        where: { id: executionId },\n        data: {\n          context: JSON.stringify(context),\n          currentStepId: stepId,\n          lastExecutedAt: new Date(),\n        },\n      });\n\n      // Find and execute next steps\n      await this.executeNextSteps(executionId, stepId, stepResult, definition);\n\n    } catch (error) {\n      logger.error('Failed to execute step', { error, executionId, stepId });\n      \n      const stepError = error instanceof Error ? error : new Error(String(error));\n      \n      // Check if step should be retried\n      const shouldRetry = await workflowRetryManager.shouldRetryStep(\n        executionId,\n        stepId,\n        node.type,\n        stepError\n      );\n      \n      if (shouldRetry) {\n        logger.info('Attempting to retry failed step', { executionId, stepId, error: stepError.message });\n        \n        // Schedule retry\n        const retryResult = await workflowRetryManager.scheduleRetry(\n          executionId,\n          stepId,\n          node.type,\n          stepError\n        );\n        \n        if (retryResult.scheduled) {\n          // Mark step as retrying\n          await prisma.workflowExecutionStep.updateMany({\n            where: { executionId, stepId, status: 'RUNNING' },\n            data: {\n              status: 'RETRYING',\n              errorMessage: stepError.message,\n              completedAt: new Date(),\n            },\n          });\n          \n          logger.info('Step retry scheduled', {\n            executionId,\n            stepId,\n            nextRetryAt: retryResult.nextRetryAt,\n            delayMs: retryResult.delayMs\n          });\n          \n          // Don't throw error for retryable steps\n          return;\n        }\n      }\n      \n      // Mark step as permanently failed\n      await prisma.workflowExecutionStep.updateMany({\n        where: { executionId, stepId, status: 'RUNNING' },\n        data: {\n          status: 'FAILED',\n          errorMessage: stepError.message,\n          completedAt: new Date(),\n        },\n      });\n      \n      // Mark entire execution as failed if step cannot be retried\n      await prisma.workflowExecution.update({\n        where: { id: executionId },\n        data: {\n          status: 'FAILED',\n          error: `Step ${stepId} failed: ${stepError.message}`,\n          completedAt: new Date(),\n        },\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Execute trigger node (usually just passes through)\n   */\n  private async executeTriggerNode(node: WorkflowNode, context: ExecutionContext): Promise<any> {\n    logger.info(`Executing trigger node: ${node.id}`, { \n      trigger: node.data.label,\n      contactId: context.contact.id \n    });\n\n    return {\n      triggered: true,\n      triggerType: node.data.properties?.type || 'unknown',\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  /**\n   * Execute action node (email, SMS, WhatsApp, wait, etc.)\n   */\n  private async executeActionNode(node: WorkflowNode, context: ExecutionContext): Promise<any> {\n    const action = node.data.label.toLowerCase();\n    const properties = node.data.properties || {};\n\n    logger.info(`Executing action node: ${node.id}`, { \n      action: node.data.label,\n      contactId: context.contact.id \n    });\n\n    if (action.includes('email')) {\n      return await this.executeEmailAction(properties, context);\n    } else if (action.includes('sms')) {\n      return await this.executeSMSAction(properties, context);\n    } else if (action.includes('whatsapp')) {\n      return await this.executeWhatsAppAction(properties, context);\n    } else if (action.includes('wait')) {\n      return await this.executeWaitAction(properties, context);\n    } else if (action.includes('tag')) {\n      return await this.executeTagAction(properties, context);\n    }\n\n    throw new Error(`Unknown action type: ${action}`);\n  }\n\n  /**\n   * Execute condition node (branching logic)\n   */\n  private async executeConditionNode(node: WorkflowNode, context: ExecutionContext): Promise<any> {\n    const properties = node.data.properties || {};\n    \n    logger.info(`Executing condition node: ${node.id}`, { \n      condition: node.data.label,\n      contactId: context.contact.id \n    });\n\n    // Evaluate condition based on type\n    let conditionResult = false;\n\n    if (properties.conditionType === 'email') {\n      conditionResult = await this.evaluateEmailCondition(properties, context);\n    } else if (properties.conditionType === 'custom') {\n      conditionResult = await this.evaluateCustomCondition(properties, context);\n    } else if (properties.conditionType === 'contact_property') {\n      conditionResult = await this.evaluateContactPropertyCondition(properties, context);\n    }\n\n    return {\n      conditionMet: conditionResult,\n      conditionType: properties.conditionType,\n      evaluatedAt: new Date().toISOString(),\n    };\n  }\n\n  /**\n   * Execute email action with rate limiting and proper campaign tracking\n   */\n  private async executeEmailAction(properties: any, context: ExecutionContext): Promise<any> {\n    // Check email rate limit\n    const rateLimitResult = await emailRateLimiter.check(context.contact.id);\n    \n    if (!rateLimitResult.allowed) {\n      const error = `Email rate limit exceeded for contact ${context.contact.id}. ${rateLimitResult.error}`;\n      logger.warn(error, { \n        contactId: context.contact.id,\n        remaining: rateLimitResult.remaining,\n        resetTime: new Date(rateLimitResult.resetTime)\n      });\n      throw new Error(error);\n    }\n\n    const subject = this.replaceVariables(properties.subject || 'MarketSage Message', context);\n    const templateName = properties.templateName || 'Default Template';\n\n    // Create or use campaign ID for proper tracking\n    let campaignId = properties.campaignId;\n    \n    if (!campaignId) {\n      // Create a workflow email campaign for tracking if none specified\n      try {\n        const workflowCampaign = await prisma.emailCampaign.create({\n          data: {\n            id: `workflow-${context.workflow.id}-${Date.now()}`,\n            name: `Workflow: ${context.workflow.name} - ${templateName}`,\n            subject,\n            htmlContent: this.generateEmailContent(templateName, context),\n            textContent: this.generateEmailContent(templateName, context, true),\n            status: 'SENT',\n            fromEmail: 'noreply@marketsage.com',\n            fromName: 'MarketSage Workflow',\n            // Link to the workflow that created this campaign\n            metadata: JSON.stringify({\n              workflowId: context.workflow.id,\n              workflowName: context.workflow.name,\n              templateName,\n              createdBy: 'workflow-automation'\n            })\n          }\n        });\n        campaignId = workflowCampaign.id;\n        \n        logger.info('Created workflow email campaign for tracking', {\n          campaignId,\n          workflowId: context.workflow.id,\n          templateName\n        });\n      } catch (campaignError) {\n        logger.warn('Failed to create workflow campaign, using mock ID', {\n          error: campaignError,\n          workflowId: context.workflow.id\n        });\n        campaignId = `workflow-${context.workflow.id}-${Date.now()}`;\n      }\n    }\n\n    logger.info('Sending workflow email', {\n      contactId: context.contact.id,\n      campaignId,\n      subject,\n      templateName,\n      emailsRemaining: rateLimitResult.remaining\n    });\n\n    const result = await sendTrackedEmail(\n      context.contact,\n      campaignId,\n      {\n        subject,\n        from: properties.fromEmail || 'noreply@marketsage.com',\n        html: this.generateEmailContent(templateName, context),\n        text: this.generateEmailContent(templateName, context, true),\n        metadata: {\n          workflowId: context.workflow.id,\n          workflowExecutionId: context.workflow.executionId,\n          templateName\n        }\n      }\n    );\n\n    // Track email cost if sent successfully\n    if (result.success) {\n      try {\n        await workflowCostTracker.recordEmailCost(\n          context.workflow.id,\n          context.workflow.executionId,\n          1, // One email sent\n          properties.emailProvider || 'default'\n        );\n      } catch (costError) {\n        logger.warn('Failed to track email cost', { error: costError });\n      }\n    }\n\n    return {\n      sent: result.success,\n      messageId: result.messageId,\n      campaignId,\n      subject,\n      templateName,\n      rateLimitInfo: {\n        remaining: rateLimitResult.remaining,\n        resetTime: rateLimitResult.resetTime\n      },\n      error: result.error?.message,\n    };\n  }\n\n  /**\n   * Execute SMS action with rate limiting and campaign tracking\n   */\n  private async executeSMSAction(properties: any, context: ExecutionContext): Promise<any> {\n    if (!context.contact.phone) {\n      throw new Error('Contact has no phone number');\n    }\n\n    // Check SMS rate limit\n    const rateLimitResult = await smsRateLimiter.check(context.contact.id);\n    \n    if (!rateLimitResult.allowed) {\n      const error = `SMS rate limit exceeded for contact ${context.contact.id}. ${rateLimitResult.error}`;\n      logger.warn(error, { \n        contactId: context.contact.id,\n        remaining: rateLimitResult.remaining,\n        resetTime: new Date(rateLimitResult.resetTime)\n      });\n      throw new Error(error);\n    }\n\n    const message = this.replaceVariables(\n      properties.message || 'Hello from MarketSage!', \n      context\n    );\n    const templateName = properties.templateName || 'Default SMS Template';\n\n    // Create or use campaign ID for proper tracking\n    let campaignId = properties.campaignId;\n    \n    if (!campaignId) {\n      // Create a workflow SMS campaign for tracking if none specified\n      try {\n        const workflowCampaign = await prisma.sMSCampaign.create({\n          data: {\n            id: `workflow-sms-${context.workflow.id}-${Date.now()}`,\n            name: `Workflow SMS: ${context.workflow.name} - ${templateName}`,\n            content: message,\n            status: 'SENT',\n            from: properties.fromPhone || 'MarketSage',\n            createdById: 'system', // System-generated campaign\n            // Link to the workflow that created this campaign\n            description: `SMS campaign created by workflow: ${context.workflow.name} (${context.workflow.id})`\n          }\n        });\n        campaignId = workflowCampaign.id;\n        \n        logger.info('Created workflow SMS campaign for tracking', {\n          campaignId,\n          workflowId: context.workflow.id,\n          templateName,\n          message: message.substring(0, 50) + '...'\n        });\n      } catch (campaignError) {\n        logger.warn('Failed to create workflow SMS campaign, using mock ID', {\n          error: campaignError,\n          workflowId: context.workflow.id\n        });\n        campaignId = `workflow-sms-${context.workflow.id}-${Date.now()}`;\n      }\n    }\n\n    logger.info('Sending workflow SMS', {\n      contactId: context.contact.id,\n      phone: context.contact.phone,\n      campaignId,\n      message: message.substring(0, 50) + '...',\n      smsRemaining: rateLimitResult.remaining\n    });\n\n    // Send SMS using the proper SMS service\n    let result;\n    try {\n      result = await sendSMS(context.contact.phone, message);\n    } catch (smsError) {\n      logger.error('SMS sending failed', {\n        error: smsError,\n        contactId: context.contact.id,\n        phone: context.contact.phone,\n        campaignId\n      });\n      result = {\n        success: false,\n        error: {\n          message: smsError instanceof Error ? smsError.message : 'SMS sending failed',\n          code: 'SMS_SEND_ERROR'\n        }\n      };\n    }\n\n    // Track SMS cost if sent successfully\n    if (result.success) {\n      try {\n        await workflowCostTracker.recordSmsCost(\n          context.workflow.id,\n          context.workflow.executionId,\n          1, // One SMS sent\n          properties.smsProvider || 'default',\n          properties.region || 'default'\n        );\n      } catch (costError) {\n        logger.warn('Failed to track SMS cost', { error: costError });\n      }\n    }\n\n    // Track SMS activity for analytics if campaign exists\n    if (result.success && campaignId) {\n      try {\n        await prisma.sMSActivity.create({\n          data: {\n            campaignId,\n            contactId: context.contact.id,\n            type: 'SENT',\n            metadata: JSON.stringify({\n              workflowId: context.workflow.id,\n              workflowExecutionId: context.workflow.executionId,\n              templateName,\n              provider: result.provider || 'unknown',\n              messageId: result.messageId\n            })\n          }\n        });\n        \n        logger.info('SMS activity tracked', {\n          campaignId,\n          contactId: context.contact.id,\n          messageId: result.messageId\n        });\n      } catch (trackingError) {\n        logger.warn('Failed to track SMS activity', {\n          error: trackingError,\n          campaignId,\n          contactId: context.contact.id\n        });\n      }\n    }\n\n    return {\n      sent: result.success,\n      messageId: result.messageId,\n      campaignId,\n      message,\n      templateName,\n      provider: result.provider,\n      rateLimitInfo: {\n        remaining: rateLimitResult.remaining,\n        resetTime: rateLimitResult.resetTime\n      },\n      error: result.error?.message,\n    };\n  }\n\n  /**\n   * Execute WhatsApp action with cost tracking\n   */\n  private async executeWhatsAppAction(properties: any, context: ExecutionContext): Promise<any> {\n    if (!context.contact.phone) {\n      throw new Error('Contact has no phone number');\n    }\n\n    const message = this.replaceVariables(\n      properties.message || 'Hello from MarketSage!', \n      context\n    );\n    const templateName = properties.templateName || 'Default WhatsApp Template';\n\n    logger.info('Sending workflow WhatsApp message', {\n      contactId: context.contact.id,\n      phone: context.contact.phone,\n      templateName,\n      message: message.substring(0, 50) + '...'\n    });\n\n    // Mock WhatsApp sending for now - replace with actual WhatsApp service integration\n    let result;\n    try {\n      // TODO: Replace with actual WhatsApp service call\n      // result = await sendWhatsApp(context.contact.phone, message);\n      result = {\n        success: true,\n        messageId: `whatsapp-${Date.now()}`,\n        provider: 'whatsapp-business'\n      };\n    } catch (whatsappError) {\n      logger.error('WhatsApp sending failed', {\n        error: whatsappError,\n        contactId: context.contact.id,\n        phone: context.contact.phone\n      });\n      result = {\n        success: false,\n        error: {\n          message: whatsappError instanceof Error ? whatsappError.message : 'WhatsApp sending failed',\n          code: 'WHATSAPP_SEND_ERROR'\n        }\n      };\n    }\n\n    // Track WhatsApp cost if sent successfully\n    if (result.success) {\n      try {\n        await workflowCostTracker.recordWhatsAppCost(\n          context.workflow.id,\n          context.workflow.executionId,\n          1, // One WhatsApp message sent\n          properties.whatsappProvider || 'whatsapp-business'\n        );\n      } catch (costError) {\n        logger.warn('Failed to track WhatsApp cost', { error: costError });\n      }\n    }\n\n    return {\n      sent: result.success,\n      messageId: result.messageId,\n      message,\n      templateName,\n      provider: result.provider,\n      error: result.error?.message,\n    };\n  }\n\n  /**\n   * Execute wait action (schedule next step)\n   */\n  private async executeWaitAction(properties: any, context: ExecutionContext): Promise<any> {\n    const waitAmount = properties.waitAmount || 1;\n    const waitUnit = properties.waitUnit || 'days';\n    \n    let delayMs = 0;\n    switch (waitUnit) {\n      case 'minutes':\n        delayMs = waitAmount * 60 * 1000;\n        break;\n      case 'hours':\n        delayMs = waitAmount * 60 * 60 * 1000;\n        break;\n      case 'days':\n        delayMs = waitAmount * 24 * 60 * 60 * 1000;\n        break;\n      default:\n        delayMs = waitAmount * 60 * 1000; // default to minutes\n    }\n\n    return {\n      waitAmount,\n      waitUnit,\n      delayMs,\n      scheduledFor: new Date(Date.now() + delayMs).toISOString(),\n    };\n  }\n\n  /**\n   * Execute tag action\n   */\n  private async executeTagAction(properties: any, context: ExecutionContext): Promise<any> {\n    const tagName = properties.tagName || properties.tag;\n    \n    if (!tagName) {\n      throw new Error('No tag specified');\n    }\n\n    // For now, just log the tag action since customFields column has issues\n    logger.info('Tag action executed', {\n      contactId: context.contact.id,\n      tagName: tagName\n    });\n\n    return {\n      tagAdded: tagName,\n      allTags: [tagName],\n    };\n  }\n\n  /**\n   * Find and execute next steps in the workflow\n   */\n  private async executeNextSteps(\n    executionId: string,\n    currentStepId: string,\n    stepResult: any,\n    definition: WorkflowDefinition\n  ): Promise<void> {\n    const outgoingEdges = definition.edges.filter(edge => edge.source === currentStepId);\n    \n    for (const edge of outgoingEdges) {\n      let shouldExecute = true;\n\n      // For condition nodes, check which path to take\n      if (stepResult.conditionMet !== undefined) {\n        const isYesPath = edge.sourceHandle === 'yes' || edge.sourceHandle === 'true';\n        const isNoPath = edge.sourceHandle === 'no' || edge.sourceHandle === 'false';\n        \n        if (isYesPath && !stepResult.conditionMet) {\n          shouldExecute = false;\n        } else if (isNoPath && stepResult.conditionMet) {\n          shouldExecute = false;\n        }\n      }\n\n      if (shouldExecute) {\n        // For wait actions, schedule the next step\n        if (stepResult.delayMs) {\n          await delayQueue.add(\n            'delayed-step',\n            { executionId, stepId: edge.target, delayMs: stepResult.delayMs },\n            { delay: stepResult.delayMs }\n          );\n        } else {\n          // Execute immediately\n          await workflowQueue.add('execute-step', { \n            executionId, \n            stepId: edge.target \n          });\n        }\n      }\n    }\n\n    // Check if workflow is complete (no more steps to execute)\n    if (outgoingEdges.length === 0) {\n      const execution = await prisma.workflowExecution.update({\n        where: { id: executionId },\n        data: {\n          status: 'COMPLETED',\n          completedAt: new Date(),\n        },\n        include: {\n          workflow: true,\n          contact: true,\n        },\n      });\n\n      logger.info(`Workflow execution completed: ${executionId}`);\n\n      // Record A/B test results (safe - won't break on error)\n      try {\n        if (execution.startedAt && execution.completedAt) {\n          const executionTime = execution.completedAt.getTime() - execution.startedAt.getTime();\n          \n          // Record completion rate (1.0 for completed workflows)\n          await workflowABTestingService.recordWorkflowTestResult(\n            execution.workflowId,\n            execution.contactId,\n            'COMPLETION_RATE',\n            1.0\n          );\n          \n          // Record execution time\n          await workflowABTestingService.recordWorkflowTestResult(\n            execution.workflowId,\n            execution.contactId,\n            'EXECUTION_TIME',\n            executionTime\n          );\n        }\n      } catch (abTestError) {\n        logger.warn('Failed to record A/B test results for completed workflow', {\n          executionId,\n          error: abTestError.message\n        });\n      }\n    }\n  }\n\n  /**\n   * Replace variables in text with actual values\n   */\n  private replaceVariables(text: string, context: ExecutionContext): string {\n    return text\n      .replace(/\\{\\{contact\\.firstName\\}\\}/g, context.contact.firstName || '')\n      .replace(/\\{\\{contact\\.lastName\\}\\}/g, context.contact.lastName || '')\n      .replace(/\\{\\{contact\\.email\\}\\}/g, context.contact.email || '')\n      .replace(/\\{\\{contact\\.company\\}\\}/g, context.contact.company || '')\n      .replace(/\\{\\{workflow\\.name\\}\\}/g, context.workflow.name || '');\n  }\n\n  /**\n   * Generate email content (simplified)\n   */\n  private generateEmailContent(templateName: string, context: ExecutionContext, isText = false): string {\n    const greeting = `Hello ${context.contact.firstName || 'there'}!`;\n    const signature = 'Best regards,\\nThe MarketSage Team';\n    \n    if (isText) {\n      return `${greeting}\\n\\nThis is a message from your ${templateName} workflow.\\n\\n${signature}`;\n    }\n    \n    return `\n      <html>\n        <body>\n          <p>${greeting}</p>\n          <p>This is a message from your <strong>${templateName}</strong> workflow.</p>\n          <p>${signature.replace('\\n', '<br>')}</p>\n        </body>\n      </html>\n    `;\n  }\n\n  /**\n   * Evaluate email-based conditions\n   */\n  private async evaluateEmailCondition(properties: any, context: ExecutionContext): Promise<boolean> {\n    // Check email engagement from recent activities\n    const recentActivity = await prisma.emailActivity.findFirst({\n      where: {\n        contactId: context.contact.id,\n        timestamp: { gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) }, // Last 7 days\n      },\n      orderBy: { timestamp: 'desc' },\n    });\n\n    if (properties.property === 'opened') {\n      return recentActivity?.type === 'OPENED';\n    } else if (properties.property === 'clicked') {\n      return recentActivity?.type === 'CLICKED';\n    }\n\n    return false;\n  }\n\n  /**\n   * Evaluate custom conditions\n   */\n  private async evaluateCustomCondition(properties: any, context: ExecutionContext): Promise<boolean> {\n    const condition = properties.customCondition || '';\n    \n    // Simple condition evaluation (expand as needed)\n    if (condition.includes('contact.events.includes')) {\n      const eventType = condition.match(/'([^']+)'/)?.[1];\n      if (eventType) {\n        const hasEvent = await prisma.workflowEvent.findFirst({\n          where: {\n            contactId: context.contact.id,\n            eventType,\n            createdAt: { gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) }, // Last 30 days\n          },\n        });\n        return !!hasEvent;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Evaluate contact property conditions\n   */\n  private async evaluateContactPropertyCondition(properties: any, context: ExecutionContext): Promise<boolean> {\n    const property = properties.property;\n    const operator = properties.operator || 'equals';\n    const value = properties.value;\n\n    const contactValue = (context.contact as any)[property];\n\n    switch (operator) {\n      case 'equals':\n        return contactValue === value;\n      case 'not_equals':\n        return contactValue !== value;\n      case 'contains':\n        return String(contactValue).includes(value);\n      case 'exists':\n        return contactValue != null && contactValue !== '';\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Execute webhook node - make HTTP requests to external APIs\n   */\n  private async executeWebhookNode(node: WorkflowNode, context: ExecutionContext): Promise<any> {\n    const properties = node.data.properties || {};\n    const { url, method = 'POST', headers = {}, timeout = 10000 } = properties;\n\n    logger.info(`Executing webhook node: ${node.id}`, {\n      url: url?.substring(0, 100), // Log only first 100 chars for security\n      method,\n      contactId: context.contact.id\n    });\n\n    if (!url) {\n      throw new Error('Webhook URL is required');\n    }\n\n    // Security validation - only allow HTTPS URLs\n    if (!url.startsWith('https://')) {\n      throw new Error('Only HTTPS URLs are allowed for webhook calls');\n    }\n\n    // Prepare payload with contact data and context\n    const payload = {\n      contact: {\n        id: context.contact.id,\n        email: context.contact.email,\n        firstName: context.contact.firstName,\n        lastName: context.contact.lastName,\n        // Only include safe fields\n      },\n      workflow: {\n        id: context.workflow.id,\n        name: context.workflow.name\n      },\n      variables: context.variables,\n      timestamp: new Date().toISOString()\n    };\n\n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n      const response = await fetch(url, {\n        method,\n        headers: {\n          'Content-Type': 'application/json',\n          'User-Agent': 'MarketSage-Workflow/1.0',\n          ...headers\n        },\n        body: method !== 'GET' ? JSON.stringify(payload) : undefined,\n        signal: controller.signal\n      });\n\n      clearTimeout(timeoutId);\n\n      const responseData = response.ok ? await response.json() : null;\n\n      // Track webhook cost if successful\n      if (response.ok) {\n        try {\n          await workflowCostTracker.recordApiCost(\n            context.workflow.id,\n            context.workflow.executionId,\n            1, // One API call\n            'webhook',\n            url\n          );\n        } catch (costError) {\n          logger.warn('Failed to track webhook cost', { error: costError });\n        }\n      }\n\n      return {\n        success: response.ok,\n        status: response.status,\n        statusText: response.statusText,\n        data: responseData,\n        executedAt: new Date().toISOString()\n      };\n    } catch (error) {\n      logger.error('Webhook execution failed', { error, url: url.substring(0, 50) });\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        executedAt: new Date().toISOString()\n      };\n    }\n  }\n\n  /**\n   * Execute database node - perform safe database operations\n   */\n  private async executeDatabaseNode(node: WorkflowNode, context: ExecutionContext): Promise<any> {\n    const properties = node.data.properties || {};\n    const { operation, table, data, conditions } = properties;\n\n    logger.info(`Executing database node: ${node.id}`, {\n      operation,\n      table,\n      contactId: context.contact.id\n    });\n\n    // Security: only allow specific operations and tables\n    const allowedOperations = ['read', 'update_contact', 'create_activity'];\n    const allowedTables = ['contact', 'emailActivity', 'workflowExecution'];\n\n    if (!allowedOperations.includes(operation)) {\n      throw new Error(`Database operation '${operation}' is not allowed`);\n    }\n\n    if (!allowedTables.includes(table)) {\n      throw new Error(`Database table '${table}' is not allowed`);\n    }\n\n    try {\n      let result;\n\n      switch (operation) {\n        case 'read':\n          if (table === 'contact') {\n            result = await prisma.contact.findUnique({\n              where: { id: context.contact.id },\n              select: {\n                id: true,\n                email: true,\n                firstName: true,\n                lastName: true,\n                leadScore: true,\n                tags: true,\n                createdAt: true\n              }\n            });\n          }\n          break;\n\n        case 'update_contact':\n          // Only allow safe field updates\n          const safeUpdateData: any = {};\n          if (data.tags) safeUpdateData.tags = data.tags;\n          if (data.leadScore) safeUpdateData.leadScore = Math.max(0, Math.min(100, data.leadScore));\n          if (data.customFields) safeUpdateData.customFields = data.customFields;\n\n          result = await prisma.contact.update({\n            where: { id: context.contact.id },\n            data: safeUpdateData\n          });\n          break;\n\n        case 'create_activity':\n          result = await prisma.emailActivity.create({\n            data: {\n              id: `workflow-${context.workflow.id}-${Date.now()}`,\n              contactId: context.contact.id,\n              campaignId: data.campaignId || `workflow-${context.workflow.id}`,\n              type: data.type || 'WORKFLOW_ACTION',\n              metadata: JSON.stringify({\n                workflowId: context.workflow.id,\n                nodeId: node.id,\n                ...data.metadata\n              })\n            }\n          });\n          break;\n\n        default:\n          throw new Error(`Unsupported database operation: ${operation}`);\n      }\n\n      return {\n        success: true,\n        operation,\n        result,\n        executedAt: new Date().toISOString()\n      };\n    } catch (error) {\n      logger.error('Database operation failed', { error, operation, table });\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Database operation failed',\n        executedAt: new Date().toISOString()\n      };\n    }\n  }\n\n  /**\n   * Execute delay node - schedule future execution\n   */\n  private async executeDelayNode(node: WorkflowNode, context: ExecutionContext): Promise<any> {\n    const properties = node.data.properties || {};\n    const { delayType, delayValue, delayUnit = 'minutes' } = properties;\n\n    logger.info(`Executing delay node: ${node.id}`, {\n      delayType,\n      delayValue,\n      delayUnit,\n      contactId: context.contact.id\n    });\n\n    let delayMs = 0;\n\n    if (delayType === 'fixed') {\n      const multipliers = {\n        seconds: 1000,\n        minutes: 60 * 1000,\n        hours: 60 * 60 * 1000,\n        days: 24 * 60 * 60 * 1000\n      };\n\n      const multiplier = multipliers[delayUnit as keyof typeof multipliers] || multipliers.minutes;\n      delayMs = delayValue * multiplier;\n\n      // Limit maximum delay to 30 days for safety\n      const maxDelay = 30 * 24 * 60 * 60 * 1000;\n      if (delayMs > maxDelay) {\n        throw new Error('Delay cannot exceed 30 days');\n      }\n    } else if (delayType === 'optimal_time') {\n      // Use engagement tracking to find optimal send time\n      try {\n        // TODO: Implement getBestSendTime function\n        const optimalTime = new Date(Date.now() + 60 * 60 * 1000); // Default to 1 hour from now\n        delayMs = Math.max(0, optimalTime.getTime() - Date.now());\n      } catch (error) {\n        logger.warn('Failed to get optimal time, using default delay', { error });\n        delayMs = 60 * 60 * 1000; // Default to 1 hour\n      }\n    }\n\n    // Schedule the delay using the queue system\n    if (delayMs > 0) {\n      await delayQueue.add(\n        'delayed-workflow-step',\n        {\n          executionId: context.workflow.executionId,\n          stepId: node.id,\n          nextStepId: properties.nextStepId\n        },\n        {\n          delay: delayMs,\n          attempts: 3,\n          backoff: {\n            type: 'exponential',\n            delay: 2000\n          }\n        }\n      );\n    }\n\n    return {\n      delayed: true,\n      delayMs,\n      delayType,\n      scheduledFor: new Date(Date.now() + delayMs).toISOString(),\n      executedAt: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Execute split node - for A/B testing or random distribution\n   */\n  private async executeSplitNode(node: WorkflowNode, context: ExecutionContext): Promise<any> {\n    const properties = node.data.properties || {};\n    const { splitType, branches = [] } = properties;\n\n    logger.info(`Executing split node: ${node.id}`, {\n      splitType,\n      branchCount: branches.length,\n      contactId: context.contact.id\n    });\n\n    let selectedBranch;\n\n    if (splitType === 'random') {\n      // Random distribution based on percentages\n      const random = Math.random() * 100;\n      let cumulative = 0;\n\n      for (const branch of branches) {\n        cumulative += branch.percentage || 0;\n        if (random <= cumulative) {\n          selectedBranch = branch;\n          break;\n        }\n      }\n    } else if (splitType === 'property') {\n      // Split based on contact property\n      const { property, conditions } = properties;\n      const contactValue = (context.contact as any)[property];\n\n      selectedBranch = branches.find((branch: any) => {\n        return branch.conditions?.some((condition: any) => {\n          switch (condition.operator) {\n            case 'equals':\n              return contactValue === condition.value;\n            case 'contains':\n              return String(contactValue).includes(condition.value);\n            case 'greater_than':\n              return Number(contactValue) > Number(condition.value);\n            default:\n              return false;\n          }\n        });\n      });\n    }\n\n    // Default to first branch if no match\n    if (!selectedBranch && branches.length > 0) {\n      selectedBranch = branches[0];\n    }\n\n    return {\n      selectedBranch: selectedBranch?.id || null,\n      splitType,\n      executedAt: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Execute transform node - data transformation and variable manipulation\n   */\n  private async executeTransformNode(node: WorkflowNode, context: ExecutionContext): Promise<any> {\n    const properties = node.data.properties || {};\n    const { transformations = [] } = properties;\n\n    logger.info(`Executing transform node: ${node.id}`, {\n      transformationCount: transformations.length,\n      contactId: context.contact.id\n    });\n\n    const results: any = {};\n\n    for (const transformation of transformations) {\n      const { operation, sourceField, targetField, value, format } = transformation;\n\n      try {\n        switch (operation) {\n          case 'copy':\n            results[targetField] = (context.contact as any)[sourceField];\n            break;\n\n          case 'set':\n            results[targetField] = this.replaceVariables(value, context);\n            break;\n\n          case 'concatenate':\n            const values = sourceField.split(',').map((field: string) => \n              (context.contact as any)[field.trim()] || ''\n            );\n            results[targetField] = values.join(' ').trim();\n            break;\n\n          case 'format_date':\n            const dateValue = new Date((context.contact as any)[sourceField]);\n            if (isNaN(dateValue.getTime())) {\n              results[targetField] = '';\n            } else {\n              results[targetField] = dateValue.toLocaleDateString();\n            }\n            break;\n\n          case 'calculate_score':\n            // Simple lead scoring based on available data\n            let score = 0;\n            if (context.contact.email) score += 20;\n            if (context.contact.firstName) score += 10;\n            if (context.contact.company) score += 15;\n            if (context.contact.phone) score += 10;\n            results[targetField] = Math.min(100, score);\n            break;\n\n          default:\n            logger.warn(`Unknown transformation operation: ${operation}`);\n        }\n      } catch (error) {\n        logger.error('Transformation failed', { error, transformation });\n        results[targetField] = null;\n      }\n    }\n\n    // Update context variables with transformation results\n    context.variables = { ...context.variables, ...results };\n\n    return {\n      success: true,\n      transformations: results,\n      executedAt: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Execute generic API call node\n   */\n  private async executeApiCallNode(node: WorkflowNode, context: ExecutionContext): Promise<any> {\n    const properties = node.data.properties || {};\n    \n    logger.info(`Executing API call node: ${node.id}`, {\n      method: properties.method,\n      url: properties.url?.substring(0, 100),\n      contactId: context.contact.id\n    });\n\n    try {\n      const config: GenericApiConfiguration = {\n        url: properties.url,\n        method: properties.method || 'POST',\n        headers: properties.headers || {},\n        timeout: properties.timeout || 30000,\n        retryCount: properties.retryCount || 3,\n        retryDelay: properties.retryDelay || 1000,\n        authentication: properties.authentication,\n        bodyTemplate: properties.bodyTemplate,\n        responseMapping: properties.responseMapping,\n        successCondition: properties.successCondition,\n      };\n\n      const result = await executeGenericApiCall(config, context);\n      \n      // Store successful response data in context for subsequent steps\n      if (result.success && result.data) {\n        context.variables = {\n          ...context.variables,\n          [`${node.id}_response`]: result.data,\n        };\n      }\n\n      return result;\n    } catch (error) {\n      logger.error('API call node execution failed', { \n        error: error instanceof Error ? error.message : String(error),\n        nodeId: node.id,\n        contactId: context.contact.id\n      });\n      \n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        executedAt: new Date().toISOString(),\n      };\n    }\n  }\n\n  /**\n   * Execute CRM action node\n   */\n  private async executeCrmActionNode(node: WorkflowNode, context: ExecutionContext): Promise<any> {\n    const properties = node.data.properties || {};\n    \n    logger.info(`Executing CRM action node: ${node.id}`, {\n      actionType: properties.actionType,\n      provider: properties.provider,\n      contactId: context.contact.id\n    });\n\n    try {\n      const config: CrmActionConfiguration = {\n        url: properties.url,\n        method: properties.method || 'POST',\n        headers: properties.headers || {},\n        timeout: properties.timeout || 30000,\n        retryCount: properties.retryCount || 3,\n        retryDelay: properties.retryDelay || 1000,\n        authentication: properties.authentication,\n        actionType: properties.actionType,\n        provider: properties.provider,\n        fieldMapping: properties.fieldMapping || {},\n      };\n\n      const result = await executeCrmAction(config, context);\n      \n      // Store successful CRM response data in context\n      if (result.success && result.data) {\n        context.variables = {\n          ...context.variables,\n          [`${node.id}_crm_response`]: result.data,\n          [`${node.id}_crm_action`]: properties.actionType,\n        };\n      }\n\n      return result;\n    } catch (error) {\n      logger.error('CRM action node execution failed', { \n        error: error instanceof Error ? error.message : String(error),\n        nodeId: node.id,\n        actionType: properties.actionType,\n        provider: properties.provider,\n        contactId: context.contact.id\n      });\n      \n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        actionType: properties.actionType,\n        provider: properties.provider,\n        executedAt: new Date().toISOString(),\n      };\n    }\n  }\n\n  /**\n   * Execute payment webhook node\n   */\n  private async executePaymentWebhookNode(node: WorkflowNode, context: ExecutionContext): Promise<any> {\n    const properties = node.data.properties || {};\n    \n    logger.info(`Executing payment webhook node: ${node.id}`, {\n      provider: properties.provider,\n      webhookType: properties.webhookType,\n      contactId: context.contact.id\n    });\n\n    try {\n      const config: PaymentWebhookConfiguration = {\n        url: properties.url,\n        method: properties.method || 'POST',\n        headers: properties.headers || {},\n        timeout: properties.timeout || 30000,\n        retryCount: properties.retryCount || 3,\n        retryDelay: properties.retryDelay || 1000,\n        authentication: properties.authentication,\n        provider: properties.provider,\n        webhookType: properties.webhookType,\n        eventData: properties.eventData || {},\n        secretKey: properties.secretKey,\n      };\n\n      const result = await executePaymentWebhook(config, context);\n      \n      // Store successful webhook response data in context\n      if (result.success && result.data) {\n        context.variables = {\n          ...context.variables,\n          [`${node.id}_payment_response`]: result.data,\n          [`${node.id}_payment_provider`]: properties.provider,\n          [`${node.id}_webhook_type`]: properties.webhookType,\n        };\n      }\n\n      return result;\n    } catch (error) {\n      logger.error('Payment webhook node execution failed', { \n        error: error instanceof Error ? error.message : String(error),\n        nodeId: node.id,\n        provider: properties.provider,\n        webhookType: properties.webhookType,\n        contactId: context.contact.id\n      });\n      \n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        provider: properties.provider,\n        webhookType: properties.webhookType,\n        executedAt: new Date().toISOString(),\n      };\n    }\n  }\n}\n\n// Export singleton instance\nexport const workflowEngine = new WorkflowExecutionEngine(); "],"names":["WorkflowExecutionEngine","workflowEngine","startWorkflowExecution","workflowId","contactId","triggerData","rateLimitCheck","checkMultipleRateLimits","limiter","workflowRateLimiter","identifier","name","systemWorkflowRateLimiter","allowed","error","failedCheck","logger","warn","Error","existingExecution","prisma","workflowExecution","findUnique","where","workflowId_contactId","status","info","id","workflow","contact","Promise","all","definition","JSON","parse","abTestVariant","workflowABTestingService","assignWorkflowVariant","workflowDefinition","variantId","abTestError","message","triggerNodes","nodes","filter","node","type","length","execution","create","data","uuidv4","context","stringify","variables","stepOutputs","rateLimits","results","startedAt","Date","firstTrigger","executeStep","executionId","remainingWorkflowLimits","executeWorkflowStep","stepId","select","include","find","n","stepExecution","workflowExecutionStep","stepType","stepResult","executeTriggerNode","executeActionNode","executeConditionNode","executeWebhookNode","executeDatabaseNode","executeDelayNode","executeSplitNode","executeTransformNode","executeApiCallNode","executeCrmActionNode","executePaymentWebhookNode","update","completedAt","output","workflowRetryManager","markStepSuccess","currentStepId","lastExecutedAt","executeNextSteps","stepError","String","shouldRetry","shouldRetryStep","retryResult","scheduleRetry","scheduled","updateMany","errorMessage","nextRetryAt","delayMs","trigger","label","triggered","triggerType","properties","timestamp","toISOString","action","toLowerCase","includes","executeEmailAction","executeSMSAction","executeWhatsAppAction","executeWaitAction","executeTagAction","condition","conditionResult","conditionType","evaluateEmailCondition","evaluateCustomCondition","evaluateContactPropertyCondition","conditionMet","evaluatedAt","rateLimitResult","emailRateLimiter","check","remaining","resetTime","subject","replaceVariables","templateName","campaignId","workflowCampaign","emailCampaign","now","htmlContent","generateEmailContent","textContent","fromEmail","fromName","metadata","workflowName","createdBy","campaignError","emailsRemaining","result","sendTrackedEmail","from","html","text","workflowExecutionId","success","workflowCostTracker","recordEmailCost","emailProvider","costError","sent","messageId","rateLimitInfo","phone","smsRateLimiter","sMSCampaign","content","fromPhone","createdById","description","substring","smsRemaining","sendSMS","smsError","code","recordSmsCost","smsProvider","region","sMSActivity","provider","trackingError","whatsappError","recordWhatsAppCost","whatsappProvider","waitAmount","waitUnit","scheduledFor","tagName","tag","tagAdded","allTags","outgoingEdges","edges","edge","source","shouldExecute","undefined","isYesPath","sourceHandle","isNoPath","delayQueue","add","target","delay","workflowQueue","executionTime","getTime","recordWorkflowTestResult","replace","firstName","lastName","email","company","isText","greeting","signature","recentActivity","emailActivity","findFirst","gte","orderBy","property","customCondition","eventType","match","hasEvent","workflowEvent","createdAt","operator","value","contactValue","url","method","headers","timeout","startsWith","payload","controller","AbortController","timeoutId","setTimeout","abort","response","fetch","body","signal","clearTimeout","responseData","ok","json","recordApiCost","statusText","executedAt","operation","table","conditions","allowedOperations","allowedTables","leadScore","tags","safeUpdateData","Math","max","min","customFields","nodeId","delayType","delayValue","delayUnit","multipliers","seconds","minutes","hours","days","multiplier","maxDelay","optimalTime","nextStepId","attempts","backoff","delayed","splitType","branches","branchCount","selectedBranch","random","cumulative","branch","percentage","some","Number","transformations","transformationCount","transformation","sourceField","targetField","format","values","split","map","field","trim","join","dateValue","isNaN","toLocaleDateString","score","config","retryCount","retryDelay","authentication","bodyTemplate","responseMapping","successCondition","executeGenericApiCall","actionType","fieldMapping","executeCrmAction","webhookType","eventData","secretKey","executePaymentWebhook"],"mappings":";;;;;;;;;;;IA0DaA,uBAAuB;eAAvBA;;IAwgDAC,cAAc;eAAdA;;;+DAlkDM;wBACI;uBACyC;8BAC/B;4BACT;kCACiB;gCACJ;8BACD;sBACP;6BAOtB;qCAQA;;;;;;AAmCA,MAAMD;IACX;;GAEC,GACD,MAAME,uBACJC,UAAkB,EAClBC,SAAiB,EACjBC,WAAiC,EAChB;QACjB,IAAI;YACF,6CAA6C;YAC7C,MAAMC,iBAAiB,MAAMC,IAAAA,oCAAuB,EAAC;gBACnD;oBACEC,SAASC,gCAAmB;oBAC5BC,YAAYN;oBACZO,MAAM;gBACR;gBACA;oBACEH,SAASI,sCAAyB;oBAClCF,YAAY;oBACZC,MAAM;gBACR;aACD;YAED,IAAI,CAACL,eAAeO,OAAO,EAAE;gBAC3B,MAAMC,QAAQ,CAAC,8BAA8B,EAAER,eAAeS,WAAW,EAAE;gBAC3EC,cAAM,CAACC,IAAI,CAACH,OAAO;oBAAEX;oBAAYC;oBAAWE;gBAAe;gBAC3D,MAAM,IAAIY,MAAMJ;YAClB;YAEA,oCAAoC;YACpC,MAAMK,oBAAoB,MAAMC,eAAM,CAACC,iBAAiB,CAACC,UAAU,CAAC;gBAClEC,OAAO;oBAAEC,sBAAsB;wBAAErB;wBAAYC;oBAAU;gBAAE;YAC3D;YAEA,IAAIe,qBAAqBA,kBAAkBM,MAAM,KAAK,WAAW;gBAC/DT,cAAM,CAACU,IAAI,CAAC,CAAC,kCAAkC,CAAC,EAAE;oBAAEvB;oBAAYC;gBAAU;gBAC1E,OAAOe,kBAAkBQ,EAAE;YAC7B;YAEA,gCAAgC;YAChC,MAAM,CAACC,UAAUC,QAAQ,GAAG,MAAMC,QAAQC,GAAG,CAAC;gBAC5CX,eAAM,CAACQ,QAAQ,CAACN,UAAU,CAAC;oBAAEC,OAAO;wBAAEI,IAAIxB;oBAAW;gBAAE;gBACvDiB,eAAM,CAACS,OAAO,CAACP,UAAU,CAAC;oBAAEC,OAAO;wBAAEI,IAAIvB;oBAAU;gBAAE;aACtD;YAED,IAAI,CAACwB,YAAY,CAACC,SAAS;gBACzB,MAAM,IAAIX,MAAM,CAAC,+BAA+B,EAAEf,WAAW,EAAE,EAAEC,WAAW;YAC9E;YAEA,IAAIwB,SAASH,MAAM,KAAK,UAAU;gBAChC,MAAM,IAAIP,MAAM,CAAC,wBAAwB,EAAEf,YAAY;YACzD;YAEA,4BAA4B;YAC5B,IAAI6B,aAAiCC,KAAKC,KAAK,CAACN,SAASI,UAAU;YAEnE,sDAAsD;YACtD,IAAI;gBACF,MAAMG,gBAAgB,MAAMC,0CAAwB,CAACC,qBAAqB,CAAClC,YAAYC;gBACvF,IAAI+B,eAAe;oBACjBH,aAAaG,cAAcG,kBAAkB;oBAC7CtB,cAAM,CAACU,IAAI,CAAC,iDAAiD;wBAC3DvB;wBACAC;wBACAmC,WAAWJ,cAAcI,SAAS;oBACpC;gBACF;YACF,EAAE,OAAOC,aAAa;gBACpB,yDAAyD;gBACzDxB,cAAM,CAACC,IAAI,CAAC,uDAAuD;oBACjEd;oBACAC;oBACAU,OAAO0B,YAAYC,OAAO;gBAC5B;YACF;YAEA,qBAAqB;YACrB,MAAMC,eAAeV,WAAWW,KAAK,CAACC,MAAM,CAACC,CAAAA,QAAQA,MAAKC,IAAI,KAAK;YACnE,IAAIJ,aAAaK,MAAM,KAAK,GAAG;gBAC7B,MAAM,IAAI7B,MAAM,CAAC,oCAAoC,EAAEf,YAAY;YACrE;YAEA,0BAA0B;YAC1B,MAAM6C,YAAY,MAAM5B,eAAM,CAACC,iBAAiB,CAAC4B,MAAM,CAAC;gBACtDC,MAAM;oBACJvB,IAAIwB,IAAAA,QAAM;oBACVhD;oBACAC;oBACAqB,QAAQ;oBACR2B,SAASnB,KAAKoB,SAAS,CAAC;wBACtBhD,aAAaA,eAAe,CAAC;wBAC7BiD,WAAW,CAAC;wBACZC,aAAa,CAAC;wBACdC,YAAYlD,eAAemD,OAAO;oBACpC;oBACAC,WAAW,IAAIC;gBACjB;YACF;YAEA,oCAAoC;YACpC,MAAMC,eAAelB,YAAY,CAAC,EAAE;YACpC,MAAM,IAAI,CAACmB,WAAW,CAACb,UAAUrB,EAAE,EAAEiC,aAAajC,EAAE;YAEpDX,cAAM,CAACU,IAAI,CAAC,CAAC,0BAA0B,CAAC,EAAE;gBACxCoC,aAAad,UAAUrB,EAAE;gBACzBxB;gBACAC;gBACA2D,yBAAyBzD,eAAemD,OAAO;YACjD;YAEA,OAAOT,UAAUrB,EAAE;QACrB,EAAE,OAAOb,OAAO;YACdE,cAAM,CAACF,KAAK,CAAC,sCAAsC;gBAAEA;gBAAOX;gBAAYC;YAAU;YAClF,MAAMU;QACR;IACF;IAEA;;GAEC,GACD,MAAMkD,oBAAoBF,WAAmB,EAAEG,MAAc,EAAiB;QAC5EjD,cAAM,CAACU,IAAI,CAAC,iCAAiC;YAAEoC;YAAaG;QAAO;QAEnE,IAAI;YACF,2CAA2C;YAC3C,MAAMjB,YAAY,MAAM5B,eAAM,CAACC,iBAAiB,CAACC,UAAU,CAAC;gBAC1DC,OAAO;oBAAEI,IAAImC;gBAAY;gBACzBI,QAAQ;oBAAEzC,QAAQ;gBAAK;YACzB;YAEA,IAAI,CAACuB,WAAW;gBACd,MAAM,IAAI9B,MAAM,CAAC,qBAAqB,EAAE4C,aAAa;YACvD;YAEA,IAAId,UAAUvB,MAAM,KAAK,WAAW;gBAClCT,cAAM,CAACC,IAAI,CAAC,4CAA4C;oBAAE6C;oBAAarC,QAAQuB,UAAUvB,MAAM;gBAAC;gBAChG;YACF;YAEA,mBAAmB;YACnB,MAAM,IAAI,CAACoC,WAAW,CAACC,aAAaG;QAEtC,EAAE,OAAOnD,OAAO;YACdE,cAAM,CAACF,KAAK,CAAC,yCAAyC;gBAAEA;gBAAOgD;gBAAaG;YAAO;YACnF,MAAMnD;QACR;IACF;IAEA;;GAEC,GACD,MAAM+C,YAAYC,WAAmB,EAAEG,MAAc,EAAiB;QACpE,IAAI;YACF,qBAAqB;YACrB,MAAMjB,YAAY,MAAM5B,eAAM,CAACC,iBAAiB,CAACC,UAAU,CAAC;gBAC1DC,OAAO;oBAAEI,IAAImC;gBAAY;gBACzBK,SAAS;oBAAEvC,UAAU;oBAAMC,SAAS;gBAAK;YAC3C;YAEA,IAAI,CAACmB,aAAaA,UAAUvB,MAAM,KAAK,WAAW;gBAChDT,cAAM,CAACC,IAAI,CAAC,CAAC,oCAAoC,EAAE6C,aAAa;gBAChE;YACF;YAEA,4BAA4B;YAC5B,MAAM9B,aAAiCC,KAAKC,KAAK,CAACc,UAAUpB,QAAQ,CAACI,UAAU;YAC/E,MAAMa,QAAOb,WAAWW,KAAK,CAACyB,IAAI,CAACC,CAAAA,IAAKA,EAAE1C,EAAE,KAAKsC;YAEjD,IAAI,CAACpB,OAAM;gBACT,MAAM,IAAI3B,MAAM,CAAC,gBAAgB,EAAE+C,QAAQ;YAC7C;YAEA,+BAA+B;YAC/B,MAAMK,gBAAgB,MAAMlD,eAAM,CAACmD,qBAAqB,CAACtB,MAAM,CAAC;gBAC9DC,MAAM;oBACJvB,IAAIwB,IAAAA,QAAM;oBACVW;oBACAG;oBACAO,UAAU3B,MAAKC,IAAI;oBACnBrB,QAAQ;oBACRiC,WAAW,IAAIC;gBACjB;YACF;YAEA,0BAA0B;YAC1B,MAAMP,UAA4BnB,KAAKC,KAAK,CAACc,UAAUI,OAAO;YAC9DA,QAAQvB,OAAO,GAAGmB,UAAUnB,OAAO;YACnCuB,QAAQxB,QAAQ,GAAGoB,UAAUpB,QAAQ;YAErC,qCAAqC;YACrC,IAAI6C,aAAkB;YAEtB,OAAQ5B,MAAKC,IAAI;gBACf,KAAK;oBACH2B,aAAa,MAAM,IAAI,CAACC,kBAAkB,CAAC7B,OAAMO;oBACjD;gBACF,KAAK;oBACHqB,aAAa,MAAM,IAAI,CAACE,iBAAiB,CAAC9B,OAAMO;oBAChD;gBACF,KAAK;oBACHqB,aAAa,MAAM,IAAI,CAACG,oBAAoB,CAAC/B,OAAMO;oBACnD;gBACF,KAAK;oBACHqB,aAAa,MAAM,IAAI,CAACI,kBAAkB,CAAChC,OAAMO;oBACjD;gBACF,KAAK;oBACHqB,aAAa,MAAM,IAAI,CAACK,mBAAmB,CAACjC,OAAMO;oBAClD;gBACF,KAAK;oBACHqB,aAAa,MAAM,IAAI,CAACM,gBAAgB,CAAClC,OAAMO;oBAC/C;gBACF,KAAK;oBACHqB,aAAa,MAAM,IAAI,CAACO,gBAAgB,CAACnC,OAAMO;oBAC/C;gBACF,KAAK;oBACHqB,aAAa,MAAM,IAAI,CAACQ,oBAAoB,CAACpC,OAAMO;oBACnD;gBACF,KAAK;oBACHqB,aAAa,MAAM,IAAI,CAACS,kBAAkB,CAACrC,OAAMO;oBACjD;gBACF,KAAK;oBACHqB,aAAa,MAAM,IAAI,CAACU,oBAAoB,CAACtC,OAAMO;oBACnD;gBACF,KAAK;oBACHqB,aAAa,MAAM,IAAI,CAACW,yBAAyB,CAACvC,OAAMO;oBACxD;gBACF;oBACE,MAAM,IAAIlC,MAAM,CAAC,mBAAmB,EAAE2B,MAAKC,IAAI,EAAE;YACrD;YAEA,wBAAwB;YACxB,MAAM1B,eAAM,CAACmD,qBAAqB,CAACc,MAAM,CAAC;gBACxC9D,OAAO;oBAAEI,IAAI2C,cAAc3C,EAAE;gBAAC;gBAC9BuB,MAAM;oBACJzB,QAAQ;oBACR6D,aAAa,IAAI3B;oBACjB4B,QAAQtD,KAAKoB,SAAS,CAACoB;gBACzB;YACF;YAEA,2CAA2C;YAC3C,MAAMe,oCAAoB,CAACC,eAAe,CAAC3B,aAAaG;YAExD,+BAA+B;YAC/Bb,QAAQG,WAAW,CAACU,OAAO,GAAGQ;YAE9B,2BAA2B;YAC3B,MAAMrD,eAAM,CAACC,iBAAiB,CAACgE,MAAM,CAAC;gBACpC9D,OAAO;oBAAEI,IAAImC;gBAAY;gBACzBZ,MAAM;oBACJE,SAASnB,KAAKoB,SAAS,CAACD;oBACxBsC,eAAezB;oBACf0B,gBAAgB,IAAIhC;gBACtB;YACF;YAEA,8BAA8B;YAC9B,MAAM,IAAI,CAACiC,gBAAgB,CAAC9B,aAAaG,QAAQQ,YAAYzC;QAE/D,EAAE,OAAOlB,OAAO;YACdE,cAAM,CAACF,KAAK,CAAC,0BAA0B;gBAAEA;gBAAOgD;gBAAaG;YAAO;YAEpE,MAAM4B,YAAY/E,iBAAiBI,QAAQJ,QAAQ,IAAII,MAAM4E,OAAOhF;YAEpE,kCAAkC;YAClC,MAAMiF,cAAc,MAAMP,oCAAoB,CAACQ,eAAe,CAC5DlC,aACAG,QACApB,KAAKC,IAAI,EACT+C;YAGF,IAAIE,aAAa;gBACf/E,cAAM,CAACU,IAAI,CAAC,mCAAmC;oBAAEoC;oBAAaG;oBAAQnD,OAAO+E,UAAUpD,OAAO;gBAAC;gBAE/F,iBAAiB;gBACjB,MAAMwD,cAAc,MAAMT,oCAAoB,CAACU,aAAa,CAC1DpC,aACAG,QACApB,KAAKC,IAAI,EACT+C;gBAGF,IAAII,YAAYE,SAAS,EAAE;oBACzB,wBAAwB;oBACxB,MAAM/E,eAAM,CAACmD,qBAAqB,CAAC6B,UAAU,CAAC;wBAC5C7E,OAAO;4BAAEuC;4BAAaG;4BAAQxC,QAAQ;wBAAU;wBAChDyB,MAAM;4BACJzB,QAAQ;4BACR4E,cAAcR,UAAUpD,OAAO;4BAC/B6C,aAAa,IAAI3B;wBACnB;oBACF;oBAEA3C,cAAM,CAACU,IAAI,CAAC,wBAAwB;wBAClCoC;wBACAG;wBACAqC,aAAaL,YAAYK,WAAW;wBACpCC,SAASN,YAAYM,OAAO;oBAC9B;oBAEA,wCAAwC;oBACxC;gBACF;YACF;YAEA,kCAAkC;YAClC,MAAMnF,eAAM,CAACmD,qBAAqB,CAAC6B,UAAU,CAAC;gBAC5C7E,OAAO;oBAAEuC;oBAAaG;oBAAQxC,QAAQ;gBAAU;gBAChDyB,MAAM;oBACJzB,QAAQ;oBACR4E,cAAcR,UAAUpD,OAAO;oBAC/B6C,aAAa,IAAI3B;gBACnB;YACF;YAEA,4DAA4D;YAC5D,MAAMvC,eAAM,CAACC,iBAAiB,CAACgE,MAAM,CAAC;gBACpC9D,OAAO;oBAAEI,IAAImC;gBAAY;gBACzBZ,MAAM;oBACJzB,QAAQ;oBACRX,OAAO,CAAC,KAAK,EAAEmD,OAAO,SAAS,EAAE4B,UAAUpD,OAAO,EAAE;oBACpD6C,aAAa,IAAI3B;gBACnB;YACF;YAEA,MAAM7C;QACR;IACF;IAEA;;GAEC,GACD,MAAc4D,mBAAmB7B,KAAkB,EAAEO,OAAyB,EAAgB;QAC5FpC,cAAM,CAACU,IAAI,CAAC,CAAC,wBAAwB,EAAEmB,MAAKlB,EAAE,EAAE,EAAE;YAChD6E,SAAS3D,MAAKK,IAAI,CAACuD,KAAK;YACxBrG,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;QAC/B;QAEA,OAAO;YACL+E,WAAW;YACXC,aAAa9D,MAAKK,IAAI,CAAC0D,UAAU,EAAE9D,QAAQ;YAC3C+D,WAAW,IAAIlD,OAAOmD,WAAW;QACnC;IACF;IAEA;;GAEC,GACD,MAAcnC,kBAAkB9B,KAAkB,EAAEO,OAAyB,EAAgB;QAC3F,MAAM2D,SAASlE,MAAKK,IAAI,CAACuD,KAAK,CAACO,WAAW;QAC1C,MAAMJ,aAAa/D,MAAKK,IAAI,CAAC0D,UAAU,IAAI,CAAC;QAE5C5F,cAAM,CAACU,IAAI,CAAC,CAAC,uBAAuB,EAAEmB,MAAKlB,EAAE,EAAE,EAAE;YAC/CoF,QAAQlE,MAAKK,IAAI,CAACuD,KAAK;YACvBrG,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;QAC/B;QAEA,IAAIoF,OAAOE,QAAQ,CAAC,UAAU;YAC5B,OAAO,MAAM,IAAI,CAACC,kBAAkB,CAACN,YAAYxD;QACnD,OAAO,IAAI2D,OAAOE,QAAQ,CAAC,QAAQ;YACjC,OAAO,MAAM,IAAI,CAACE,gBAAgB,CAACP,YAAYxD;QACjD,OAAO,IAAI2D,OAAOE,QAAQ,CAAC,aAAa;YACtC,OAAO,MAAM,IAAI,CAACG,qBAAqB,CAACR,YAAYxD;QACtD,OAAO,IAAI2D,OAAOE,QAAQ,CAAC,SAAS;YAClC,OAAO,MAAM,IAAI,CAACI,iBAAiB,CAACT,YAAYxD;QAClD,OAAO,IAAI2D,OAAOE,QAAQ,CAAC,QAAQ;YACjC,OAAO,MAAM,IAAI,CAACK,gBAAgB,CAACV,YAAYxD;QACjD;QAEA,MAAM,IAAIlC,MAAM,CAAC,qBAAqB,EAAE6F,QAAQ;IAClD;IAEA;;GAEC,GACD,MAAcnC,qBAAqB/B,KAAkB,EAAEO,OAAyB,EAAgB;QAC9F,MAAMwD,aAAa/D,MAAKK,IAAI,CAAC0D,UAAU,IAAI,CAAC;QAE5C5F,cAAM,CAACU,IAAI,CAAC,CAAC,0BAA0B,EAAEmB,MAAKlB,EAAE,EAAE,EAAE;YAClD4F,WAAW1E,MAAKK,IAAI,CAACuD,KAAK;YAC1BrG,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;QAC/B;QAEA,mCAAmC;QACnC,IAAI6F,kBAAkB;QAEtB,IAAIZ,WAAWa,aAAa,KAAK,SAAS;YACxCD,kBAAkB,MAAM,IAAI,CAACE,sBAAsB,CAACd,YAAYxD;QAClE,OAAO,IAAIwD,WAAWa,aAAa,KAAK,UAAU;YAChDD,kBAAkB,MAAM,IAAI,CAACG,uBAAuB,CAACf,YAAYxD;QACnE,OAAO,IAAIwD,WAAWa,aAAa,KAAK,oBAAoB;YAC1DD,kBAAkB,MAAM,IAAI,CAACI,gCAAgC,CAAChB,YAAYxD;QAC5E;QAEA,OAAO;YACLyE,cAAcL;YACdC,eAAeb,WAAWa,aAAa;YACvCK,aAAa,IAAInE,OAAOmD,WAAW;QACrC;IACF;IAEA;;GAEC,GACD,MAAcI,mBAAmBN,UAAe,EAAExD,OAAyB,EAAgB;QACzF,yBAAyB;QACzB,MAAM2E,kBAAkB,MAAMC,6BAAgB,CAACC,KAAK,CAAC7E,QAAQvB,OAAO,CAACF,EAAE;QAEvE,IAAI,CAACoG,gBAAgBlH,OAAO,EAAE;YAC5B,MAAMC,QAAQ,CAAC,sCAAsC,EAAEsC,QAAQvB,OAAO,CAACF,EAAE,CAAC,EAAE,EAAEoG,gBAAgBjH,KAAK,EAAE;YACrGE,cAAM,CAACC,IAAI,CAACH,OAAO;gBACjBV,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;gBAC7BuG,WAAWH,gBAAgBG,SAAS;gBACpCC,WAAW,IAAIxE,KAAKoE,gBAAgBI,SAAS;YAC/C;YACA,MAAM,IAAIjH,MAAMJ;QAClB;QAEA,MAAMsH,UAAU,IAAI,CAACC,gBAAgB,CAACzB,WAAWwB,OAAO,IAAI,sBAAsBhF;QAClF,MAAMkF,eAAe1B,WAAW0B,YAAY,IAAI;QAEhD,gDAAgD;QAChD,IAAIC,aAAa3B,WAAW2B,UAAU;QAEtC,IAAI,CAACA,YAAY;YACf,kEAAkE;YAClE,IAAI;gBACF,MAAMC,mBAAmB,MAAMpH,eAAM,CAACqH,aAAa,CAACxF,MAAM,CAAC;oBACzDC,MAAM;wBACJvB,IAAI,CAAC,SAAS,EAAEyB,QAAQxB,QAAQ,CAACD,EAAE,CAAC,CAAC,EAAEgC,KAAK+E,GAAG,IAAI;wBACnD/H,MAAM,CAAC,UAAU,EAAEyC,QAAQxB,QAAQ,CAACjB,IAAI,CAAC,GAAG,EAAE2H,cAAc;wBAC5DF;wBACAO,aAAa,IAAI,CAACC,oBAAoB,CAACN,cAAclF;wBACrDyF,aAAa,IAAI,CAACD,oBAAoB,CAACN,cAAclF,SAAS;wBAC9D3B,QAAQ;wBACRqH,WAAW;wBACXC,UAAU;wBACV,kDAAkD;wBAClDC,UAAU/G,KAAKoB,SAAS,CAAC;4BACvBlD,YAAYiD,QAAQxB,QAAQ,CAACD,EAAE;4BAC/BsH,cAAc7F,QAAQxB,QAAQ,CAACjB,IAAI;4BACnC2H;4BACAY,WAAW;wBACb;oBACF;gBACF;gBACAX,aAAaC,iBAAiB7G,EAAE;gBAEhCX,cAAM,CAACU,IAAI,CAAC,gDAAgD;oBAC1D6G;oBACApI,YAAYiD,QAAQxB,QAAQ,CAACD,EAAE;oBAC/B2G;gBACF;YACF,EAAE,OAAOa,eAAe;gBACtBnI,cAAM,CAACC,IAAI,CAAC,qDAAqD;oBAC/DH,OAAOqI;oBACPhJ,YAAYiD,QAAQxB,QAAQ,CAACD,EAAE;gBACjC;gBACA4G,aAAa,CAAC,SAAS,EAAEnF,QAAQxB,QAAQ,CAACD,EAAE,CAAC,CAAC,EAAEgC,KAAK+E,GAAG,IAAI;YAC9D;QACF;QAEA1H,cAAM,CAACU,IAAI,CAAC,0BAA0B;YACpCtB,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;YAC7B4G;YACAH;YACAE;YACAc,iBAAiBrB,gBAAgBG,SAAS;QAC5C;QAEA,MAAMmB,SAAS,MAAMC,IAAAA,8BAAgB,EACnClG,QAAQvB,OAAO,EACf0G,YACA;YACEH;YACAmB,MAAM3C,WAAWkC,SAAS,IAAI;YAC9BU,MAAM,IAAI,CAACZ,oBAAoB,CAACN,cAAclF;YAC9CqG,MAAM,IAAI,CAACb,oBAAoB,CAACN,cAAclF,SAAS;YACvD4F,UAAU;gBACR7I,YAAYiD,QAAQxB,QAAQ,CAACD,EAAE;gBAC/B+H,qBAAqBtG,QAAQxB,QAAQ,CAACkC,WAAW;gBACjDwE;YACF;QACF;QAGF,wCAAwC;QACxC,IAAIe,OAAOM,OAAO,EAAE;YAClB,IAAI;gBACF,MAAMC,iCAAmB,CAACC,eAAe,CACvCzG,QAAQxB,QAAQ,CAACD,EAAE,EACnByB,QAAQxB,QAAQ,CAACkC,WAAW,EAC5B,GACA8C,WAAWkD,aAAa,IAAI;YAEhC,EAAE,OAAOC,WAAW;gBAClB/I,cAAM,CAACC,IAAI,CAAC,8BAA8B;oBAAEH,OAAOiJ;gBAAU;YAC/D;QACF;QAEA,OAAO;YACLC,MAAMX,OAAOM,OAAO;YACpBM,WAAWZ,OAAOY,SAAS;YAC3B1B;YACAH;YACAE;YACA4B,eAAe;gBACbhC,WAAWH,gBAAgBG,SAAS;gBACpCC,WAAWJ,gBAAgBI,SAAS;YACtC;YACArH,OAAOuI,OAAOvI,KAAK,EAAE2B;QACvB;IACF;IAEA;;GAEC,GACD,MAAc0E,iBAAiBP,UAAe,EAAExD,OAAyB,EAAgB;QACvF,IAAI,CAACA,QAAQvB,OAAO,CAACsI,KAAK,EAAE;YAC1B,MAAM,IAAIjJ,MAAM;QAClB;QAEA,uBAAuB;QACvB,MAAM6G,kBAAkB,MAAMqC,2BAAc,CAACnC,KAAK,CAAC7E,QAAQvB,OAAO,CAACF,EAAE;QAErE,IAAI,CAACoG,gBAAgBlH,OAAO,EAAE;YAC5B,MAAMC,QAAQ,CAAC,oCAAoC,EAAEsC,QAAQvB,OAAO,CAACF,EAAE,CAAC,EAAE,EAAEoG,gBAAgBjH,KAAK,EAAE;YACnGE,cAAM,CAACC,IAAI,CAACH,OAAO;gBACjBV,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;gBAC7BuG,WAAWH,gBAAgBG,SAAS;gBACpCC,WAAW,IAAIxE,KAAKoE,gBAAgBI,SAAS;YAC/C;YACA,MAAM,IAAIjH,MAAMJ;QAClB;QAEA,MAAM2B,UAAU,IAAI,CAAC4F,gBAAgB,CACnCzB,WAAWnE,OAAO,IAAI,0BACtBW;QAEF,MAAMkF,eAAe1B,WAAW0B,YAAY,IAAI;QAEhD,gDAAgD;QAChD,IAAIC,aAAa3B,WAAW2B,UAAU;QAEtC,IAAI,CAACA,YAAY;YACf,gEAAgE;YAChE,IAAI;gBACF,MAAMC,mBAAmB,MAAMpH,eAAM,CAACiJ,WAAW,CAACpH,MAAM,CAAC;oBACvDC,MAAM;wBACJvB,IAAI,CAAC,aAAa,EAAEyB,QAAQxB,QAAQ,CAACD,EAAE,CAAC,CAAC,EAAEgC,KAAK+E,GAAG,IAAI;wBACvD/H,MAAM,CAAC,cAAc,EAAEyC,QAAQxB,QAAQ,CAACjB,IAAI,CAAC,GAAG,EAAE2H,cAAc;wBAChEgC,SAAS7H;wBACThB,QAAQ;wBACR8H,MAAM3C,WAAW2D,SAAS,IAAI;wBAC9BC,aAAa;wBACb,kDAAkD;wBAClDC,aAAa,CAAC,kCAAkC,EAAErH,QAAQxB,QAAQ,CAACjB,IAAI,CAAC,EAAE,EAAEyC,QAAQxB,QAAQ,CAACD,EAAE,CAAC,CAAC,CAAC;oBACpG;gBACF;gBACA4G,aAAaC,iBAAiB7G,EAAE;gBAEhCX,cAAM,CAACU,IAAI,CAAC,8CAA8C;oBACxD6G;oBACApI,YAAYiD,QAAQxB,QAAQ,CAACD,EAAE;oBAC/B2G;oBACA7F,SAASA,QAAQiI,SAAS,CAAC,GAAG,MAAM;gBACtC;YACF,EAAE,OAAOvB,eAAe;gBACtBnI,cAAM,CAACC,IAAI,CAAC,yDAAyD;oBACnEH,OAAOqI;oBACPhJ,YAAYiD,QAAQxB,QAAQ,CAACD,EAAE;gBACjC;gBACA4G,aAAa,CAAC,aAAa,EAAEnF,QAAQxB,QAAQ,CAACD,EAAE,CAAC,CAAC,EAAEgC,KAAK+E,GAAG,IAAI;YAClE;QACF;QAEA1H,cAAM,CAACU,IAAI,CAAC,wBAAwB;YAClCtB,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;YAC7BwI,OAAO/G,QAAQvB,OAAO,CAACsI,KAAK;YAC5B5B;YACA9F,SAASA,QAAQiI,SAAS,CAAC,GAAG,MAAM;YACpCC,cAAc5C,gBAAgBG,SAAS;QACzC;QAEA,wCAAwC;QACxC,IAAImB;QACJ,IAAI;YACFA,SAAS,MAAMuB,IAAAA,mBAAO,EAACxH,QAAQvB,OAAO,CAACsI,KAAK,EAAE1H;QAChD,EAAE,OAAOoI,UAAU;YACjB7J,cAAM,CAACF,KAAK,CAAC,sBAAsB;gBACjCA,OAAO+J;gBACPzK,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;gBAC7BwI,OAAO/G,QAAQvB,OAAO,CAACsI,KAAK;gBAC5B5B;YACF;YACAc,SAAS;gBACPM,SAAS;gBACT7I,OAAO;oBACL2B,SAASoI,oBAAoB3J,QAAQ2J,SAASpI,OAAO,GAAG;oBACxDqI,MAAM;gBACR;YACF;QACF;QAEA,sCAAsC;QACtC,IAAIzB,OAAOM,OAAO,EAAE;YAClB,IAAI;gBACF,MAAMC,iCAAmB,CAACmB,aAAa,CACrC3H,QAAQxB,QAAQ,CAACD,EAAE,EACnByB,QAAQxB,QAAQ,CAACkC,WAAW,EAC5B,GACA8C,WAAWoE,WAAW,IAAI,WAC1BpE,WAAWqE,MAAM,IAAI;YAEzB,EAAE,OAAOlB,WAAW;gBAClB/I,cAAM,CAACC,IAAI,CAAC,4BAA4B;oBAAEH,OAAOiJ;gBAAU;YAC7D;QACF;QAEA,sDAAsD;QACtD,IAAIV,OAAOM,OAAO,IAAIpB,YAAY;YAChC,IAAI;gBACF,MAAMnH,eAAM,CAAC8J,WAAW,CAACjI,MAAM,CAAC;oBAC9BC,MAAM;wBACJqF;wBACAnI,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;wBAC7BmB,MAAM;wBACNkG,UAAU/G,KAAKoB,SAAS,CAAC;4BACvBlD,YAAYiD,QAAQxB,QAAQ,CAACD,EAAE;4BAC/B+H,qBAAqBtG,QAAQxB,QAAQ,CAACkC,WAAW;4BACjDwE;4BACA6C,UAAU9B,OAAO8B,QAAQ,IAAI;4BAC7BlB,WAAWZ,OAAOY,SAAS;wBAC7B;oBACF;gBACF;gBAEAjJ,cAAM,CAACU,IAAI,CAAC,wBAAwB;oBAClC6G;oBACAnI,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;oBAC7BsI,WAAWZ,OAAOY,SAAS;gBAC7B;YACF,EAAE,OAAOmB,eAAe;gBACtBpK,cAAM,CAACC,IAAI,CAAC,gCAAgC;oBAC1CH,OAAOsK;oBACP7C;oBACAnI,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;gBAC/B;YACF;QACF;QAEA,OAAO;YACLqI,MAAMX,OAAOM,OAAO;YACpBM,WAAWZ,OAAOY,SAAS;YAC3B1B;YACA9F;YACA6F;YACA6C,UAAU9B,OAAO8B,QAAQ;YACzBjB,eAAe;gBACbhC,WAAWH,gBAAgBG,SAAS;gBACpCC,WAAWJ,gBAAgBI,SAAS;YACtC;YACArH,OAAOuI,OAAOvI,KAAK,EAAE2B;QACvB;IACF;IAEA;;GAEC,GACD,MAAc2E,sBAAsBR,UAAe,EAAExD,OAAyB,EAAgB;QAC5F,IAAI,CAACA,QAAQvB,OAAO,CAACsI,KAAK,EAAE;YAC1B,MAAM,IAAIjJ,MAAM;QAClB;QAEA,MAAMuB,UAAU,IAAI,CAAC4F,gBAAgB,CACnCzB,WAAWnE,OAAO,IAAI,0BACtBW;QAEF,MAAMkF,eAAe1B,WAAW0B,YAAY,IAAI;QAEhDtH,cAAM,CAACU,IAAI,CAAC,qCAAqC;YAC/CtB,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;YAC7BwI,OAAO/G,QAAQvB,OAAO,CAACsI,KAAK;YAC5B7B;YACA7F,SAASA,QAAQiI,SAAS,CAAC,GAAG,MAAM;QACtC;QAEA,mFAAmF;QACnF,IAAIrB;QACJ,IAAI;YACF,kDAAkD;YAClD,+DAA+D;YAC/DA,SAAS;gBACPM,SAAS;gBACTM,WAAW,CAAC,SAAS,EAAEtG,KAAK+E,GAAG,IAAI;gBACnCyC,UAAU;YACZ;QACF,EAAE,OAAOE,eAAe;YACtBrK,cAAM,CAACF,KAAK,CAAC,2BAA2B;gBACtCA,OAAOuK;gBACPjL,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;gBAC7BwI,OAAO/G,QAAQvB,OAAO,CAACsI,KAAK;YAC9B;YACAd,SAAS;gBACPM,SAAS;gBACT7I,OAAO;oBACL2B,SAAS4I,yBAAyBnK,QAAQmK,cAAc5I,OAAO,GAAG;oBAClEqI,MAAM;gBACR;YACF;QACF;QAEA,2CAA2C;QAC3C,IAAIzB,OAAOM,OAAO,EAAE;YAClB,IAAI;gBACF,MAAMC,iCAAmB,CAAC0B,kBAAkB,CAC1ClI,QAAQxB,QAAQ,CAACD,EAAE,EACnByB,QAAQxB,QAAQ,CAACkC,WAAW,EAC5B,GACA8C,WAAW2E,gBAAgB,IAAI;YAEnC,EAAE,OAAOxB,WAAW;gBAClB/I,cAAM,CAACC,IAAI,CAAC,iCAAiC;oBAAEH,OAAOiJ;gBAAU;YAClE;QACF;QAEA,OAAO;YACLC,MAAMX,OAAOM,OAAO;YACpBM,WAAWZ,OAAOY,SAAS;YAC3BxH;YACA6F;YACA6C,UAAU9B,OAAO8B,QAAQ;YACzBrK,OAAOuI,OAAOvI,KAAK,EAAE2B;QACvB;IACF;IAEA;;GAEC,GACD,MAAc4E,kBAAkBT,UAAe,EAAExD,OAAyB,EAAgB;QACxF,MAAMoI,aAAa5E,WAAW4E,UAAU,IAAI;QAC5C,MAAMC,WAAW7E,WAAW6E,QAAQ,IAAI;QAExC,IAAIlF,UAAU;QACd,OAAQkF;YACN,KAAK;gBACHlF,UAAUiF,aAAa,KAAK;gBAC5B;YACF,KAAK;gBACHjF,UAAUiF,aAAa,KAAK,KAAK;gBACjC;YACF,KAAK;gBACHjF,UAAUiF,aAAa,KAAK,KAAK,KAAK;gBACtC;YACF;gBACEjF,UAAUiF,aAAa,KAAK,MAAM,qBAAqB;QAC3D;QAEA,OAAO;YACLA;YACAC;YACAlF;YACAmF,cAAc,IAAI/H,KAAKA,KAAK+E,GAAG,KAAKnC,SAASO,WAAW;QAC1D;IACF;IAEA;;GAEC,GACD,MAAcQ,iBAAiBV,UAAe,EAAExD,OAAyB,EAAgB;QACvF,MAAMuI,UAAU/E,WAAW+E,OAAO,IAAI/E,WAAWgF,GAAG;QAEpD,IAAI,CAACD,SAAS;YACZ,MAAM,IAAIzK,MAAM;QAClB;QAEA,wEAAwE;QACxEF,cAAM,CAACU,IAAI,CAAC,uBAAuB;YACjCtB,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;YAC7BgK,SAASA;QACX;QAEA,OAAO;YACLE,UAAUF;YACVG,SAAS;gBAACH;aAAQ;QACpB;IACF;IAEA;;GAEC,GACD,MAAc/F,iBACZ9B,WAAmB,EACnB4B,aAAqB,EACrBjB,UAAe,EACfzC,UAA8B,EACf;QACf,MAAM+J,gBAAgB/J,WAAWgK,KAAK,CAACpJ,MAAM,CAACqJ,CAAAA,OAAQA,KAAKC,MAAM,KAAKxG;QAEtE,KAAK,MAAMuG,QAAQF,cAAe;YAChC,IAAII,gBAAgB;YAEpB,gDAAgD;YAChD,IAAI1H,WAAWoD,YAAY,KAAKuE,WAAW;gBACzC,MAAMC,YAAYJ,KAAKK,YAAY,KAAK,SAASL,KAAKK,YAAY,KAAK;gBACvE,MAAMC,WAAWN,KAAKK,YAAY,KAAK,QAAQL,KAAKK,YAAY,KAAK;gBAErE,IAAID,aAAa,CAAC5H,WAAWoD,YAAY,EAAE;oBACzCsE,gBAAgB;gBAClB,OAAO,IAAII,YAAY9H,WAAWoD,YAAY,EAAE;oBAC9CsE,gBAAgB;gBAClB;YACF;YAEA,IAAIA,eAAe;gBACjB,2CAA2C;gBAC3C,IAAI1H,WAAW8B,OAAO,EAAE;oBACtB,MAAMiG,iBAAU,CAACC,GAAG,CAClB,gBACA;wBAAE3I;wBAAaG,QAAQgI,KAAKS,MAAM;wBAAEnG,SAAS9B,WAAW8B,OAAO;oBAAC,GAChE;wBAAEoG,OAAOlI,WAAW8B,OAAO;oBAAC;gBAEhC,OAAO;oBACL,sBAAsB;oBACtB,MAAMqG,oBAAa,CAACH,GAAG,CAAC,gBAAgB;wBACtC3I;wBACAG,QAAQgI,KAAKS,MAAM;oBACrB;gBACF;YACF;QACF;QAEA,2DAA2D;QAC3D,IAAIX,cAAchJ,MAAM,KAAK,GAAG;YAC9B,MAAMC,YAAY,MAAM5B,eAAM,CAACC,iBAAiB,CAACgE,MAAM,CAAC;gBACtD9D,OAAO;oBAAEI,IAAImC;gBAAY;gBACzBZ,MAAM;oBACJzB,QAAQ;oBACR6D,aAAa,IAAI3B;gBACnB;gBACAQ,SAAS;oBACPvC,UAAU;oBACVC,SAAS;gBACX;YACF;YAEAb,cAAM,CAACU,IAAI,CAAC,CAAC,8BAA8B,EAAEoC,aAAa;YAE1D,wDAAwD;YACxD,IAAI;gBACF,IAAId,UAAUU,SAAS,IAAIV,UAAUsC,WAAW,EAAE;oBAChD,MAAMuH,gBAAgB7J,UAAUsC,WAAW,CAACwH,OAAO,KAAK9J,UAAUU,SAAS,CAACoJ,OAAO;oBAEnF,uDAAuD;oBACvD,MAAM1K,0CAAwB,CAAC2K,wBAAwB,CACrD/J,UAAU7C,UAAU,EACpB6C,UAAU5C,SAAS,EACnB,mBACA;oBAGF,wBAAwB;oBACxB,MAAMgC,0CAAwB,CAAC2K,wBAAwB,CACrD/J,UAAU7C,UAAU,EACpB6C,UAAU5C,SAAS,EACnB,kBACAyM;gBAEJ;YACF,EAAE,OAAOrK,aAAa;gBACpBxB,cAAM,CAACC,IAAI,CAAC,4DAA4D;oBACtE6C;oBACAhD,OAAO0B,YAAYC,OAAO;gBAC5B;YACF;QACF;IACF;IAEA;;GAEC,GACD,AAAQ4F,iBAAiBoB,IAAY,EAAErG,OAAyB,EAAU;QACxE,OAAOqG,KACJuD,OAAO,CAAC,+BAA+B5J,QAAQvB,OAAO,CAACoL,SAAS,IAAI,IACpED,OAAO,CAAC,8BAA8B5J,QAAQvB,OAAO,CAACqL,QAAQ,IAAI,IAClEF,OAAO,CAAC,2BAA2B5J,QAAQvB,OAAO,CAACsL,KAAK,IAAI,IAC5DH,OAAO,CAAC,6BAA6B5J,QAAQvB,OAAO,CAACuL,OAAO,IAAI,IAChEJ,OAAO,CAAC,2BAA2B5J,QAAQxB,QAAQ,CAACjB,IAAI,IAAI;IACjE;IAEA;;GAEC,GACD,AAAQiI,qBAAqBN,YAAoB,EAAElF,OAAyB,EAAEiK,SAAS,KAAK,EAAU;QACpG,MAAMC,WAAW,CAAC,MAAM,EAAElK,QAAQvB,OAAO,CAACoL,SAAS,IAAI,QAAQ,CAAC,CAAC;QACjE,MAAMM,YAAY;QAElB,IAAIF,QAAQ;YACV,OAAO,GAAGC,SAAS,gCAAgC,EAAEhF,aAAa,cAAc,EAAEiF,WAAW;QAC/F;QAEA,OAAO,CAAC;;;aAGC,EAAED,SAAS;iDACyB,EAAEhF,aAAa;aACnD,EAAEiF,UAAUP,OAAO,CAAC,MAAM,QAAQ;;;IAG3C,CAAC;IACH;IAEA;;GAEC,GACD,MAActF,uBAAuBd,UAAe,EAAExD,OAAyB,EAAoB;QACjG,gDAAgD;QAChD,MAAMoK,iBAAiB,MAAMpM,eAAM,CAACqM,aAAa,CAACC,SAAS,CAAC;YAC1DnM,OAAO;gBACLnB,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;gBAC7BkF,WAAW;oBAAE8G,KAAK,IAAIhK,KAAKA,KAAK+E,GAAG,KAAK,IAAI,KAAK,KAAK,KAAK;gBAAM;YACnE;YACAkF,SAAS;gBAAE/G,WAAW;YAAO;QAC/B;QAEA,IAAID,WAAWiH,QAAQ,KAAK,UAAU;YACpC,OAAOL,gBAAgB1K,SAAS;QAClC,OAAO,IAAI8D,WAAWiH,QAAQ,KAAK,WAAW;YAC5C,OAAOL,gBAAgB1K,SAAS;QAClC;QAEA,OAAO;IACT;IAEA;;GAEC,GACD,MAAc6E,wBAAwBf,UAAe,EAAExD,OAAyB,EAAoB;QAClG,MAAMmE,YAAYX,WAAWkH,eAAe,IAAI;QAEhD,iDAAiD;QACjD,IAAIvG,UAAUN,QAAQ,CAAC,4BAA4B;YACjD,MAAM8G,YAAYxG,UAAUyG,KAAK,CAAC,cAAc,CAAC,EAAE;YACnD,IAAID,WAAW;gBACb,MAAME,WAAW,MAAM7M,eAAM,CAAC8M,aAAa,CAACR,SAAS,CAAC;oBACpDnM,OAAO;wBACLnB,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;wBAC7BoM;wBACAI,WAAW;4BAAER,KAAK,IAAIhK,KAAKA,KAAK+E,GAAG,KAAK,KAAK,KAAK,KAAK,KAAK;wBAAM;oBACpE;gBACF;gBACA,OAAO,CAAC,CAACuF;YACX;QACF;QAEA,OAAO;IACT;IAEA;;GAEC,GACD,MAAcrG,iCAAiChB,UAAe,EAAExD,OAAyB,EAAoB;QAC3G,MAAMyK,WAAWjH,WAAWiH,QAAQ;QACpC,MAAMO,WAAWxH,WAAWwH,QAAQ,IAAI;QACxC,MAAMC,QAAQzH,WAAWyH,KAAK;QAE9B,MAAMC,eAAe,AAAClL,QAAQvB,OAAO,AAAQ,CAACgM,SAAS;QAEvD,OAAQO;YACN,KAAK;gBACH,OAAOE,iBAAiBD;YAC1B,KAAK;gBACH,OAAOC,iBAAiBD;YAC1B,KAAK;gBACH,OAAOvI,OAAOwI,cAAcrH,QAAQ,CAACoH;YACvC,KAAK;gBACH,OAAOC,gBAAgB,QAAQA,iBAAiB;YAClD;gBACE,OAAO;QACX;IACF;IAEA;;GAEC,GACD,MAAczJ,mBAAmBhC,KAAkB,EAAEO,OAAyB,EAAgB;QAC5F,MAAMwD,aAAa/D,MAAKK,IAAI,CAAC0D,UAAU,IAAI,CAAC;QAC5C,MAAM,EAAE2H,GAAG,EAAEC,SAAS,MAAM,EAAEC,UAAU,CAAC,CAAC,EAAEC,UAAU,KAAK,EAAE,GAAG9H;QAEhE5F,cAAM,CAACU,IAAI,CAAC,CAAC,wBAAwB,EAAEmB,MAAKlB,EAAE,EAAE,EAAE;YAChD4M,KAAKA,KAAK7D,UAAU,GAAG;YACvB8D;YACApO,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;QAC/B;QAEA,IAAI,CAAC4M,KAAK;YACR,MAAM,IAAIrN,MAAM;QAClB;QAEA,8CAA8C;QAC9C,IAAI,CAACqN,IAAII,UAAU,CAAC,aAAa;YAC/B,MAAM,IAAIzN,MAAM;QAClB;QAEA,gDAAgD;QAChD,MAAM0N,UAAU;YACd/M,SAAS;gBACPF,IAAIyB,QAAQvB,OAAO,CAACF,EAAE;gBACtBwL,OAAO/J,QAAQvB,OAAO,CAACsL,KAAK;gBAC5BF,WAAW7J,QAAQvB,OAAO,CAACoL,SAAS;gBACpCC,UAAU9J,QAAQvB,OAAO,CAACqL,QAAQ;YAEpC;YACAtL,UAAU;gBACRD,IAAIyB,QAAQxB,QAAQ,CAACD,EAAE;gBACvBhB,MAAMyC,QAAQxB,QAAQ,CAACjB,IAAI;YAC7B;YACA2C,WAAWF,QAAQE,SAAS;YAC5BuD,WAAW,IAAIlD,OAAOmD,WAAW;QACnC;QAEA,IAAI;YACF,MAAM+H,aAAa,IAAIC;YACvB,MAAMC,YAAYC,WAAW,IAAMH,WAAWI,KAAK,IAAIP;YAEvD,MAAMQ,WAAW,MAAMC,MAAMZ,KAAK;gBAChCC;gBACAC,SAAS;oBACP,gBAAgB;oBAChB,cAAc;oBACd,GAAGA,OAAO;gBACZ;gBACAW,MAAMZ,WAAW,QAAQvM,KAAKoB,SAAS,CAACuL,WAAWxC;gBACnDiD,QAAQR,WAAWQ,MAAM;YAC3B;YAEAC,aAAaP;YAEb,MAAMQ,eAAeL,SAASM,EAAE,GAAG,MAAMN,SAASO,IAAI,KAAK;YAE3D,mCAAmC;YACnC,IAAIP,SAASM,EAAE,EAAE;gBACf,IAAI;oBACF,MAAM5F,iCAAmB,CAAC8F,aAAa,CACrCtM,QAAQxB,QAAQ,CAACD,EAAE,EACnByB,QAAQxB,QAAQ,CAACkC,WAAW,EAC5B,GACA,WACAyK;gBAEJ,EAAE,OAAOxE,WAAW;oBAClB/I,cAAM,CAACC,IAAI,CAAC,gCAAgC;wBAAEH,OAAOiJ;oBAAU;gBACjE;YACF;YAEA,OAAO;gBACLJ,SAASuF,SAASM,EAAE;gBACpB/N,QAAQyN,SAASzN,MAAM;gBACvBkO,YAAYT,SAASS,UAAU;gBAC/BzM,MAAMqM;gBACNK,YAAY,IAAIjM,OAAOmD,WAAW;YACpC;QACF,EAAE,OAAOhG,OAAO;YACdE,cAAM,CAACF,KAAK,CAAC,4BAA4B;gBAAEA;gBAAOyN,KAAKA,IAAI7D,SAAS,CAAC,GAAG;YAAI;YAC5E,OAAO;gBACLf,SAAS;gBACT7I,OAAOA,iBAAiBI,QAAQJ,MAAM2B,OAAO,GAAG;gBAChDmN,YAAY,IAAIjM,OAAOmD,WAAW;YACpC;QACF;IACF;IAEA;;GAEC,GACD,MAAchC,oBAAoBjC,KAAkB,EAAEO,OAAyB,EAAgB;QAC7F,MAAMwD,aAAa/D,MAAKK,IAAI,CAAC0D,UAAU,IAAI,CAAC;QAC5C,MAAM,EAAEiJ,SAAS,EAAEC,KAAK,EAAE5M,IAAI,EAAE6M,UAAU,EAAE,GAAGnJ;QAE/C5F,cAAM,CAACU,IAAI,CAAC,CAAC,yBAAyB,EAAEmB,MAAKlB,EAAE,EAAE,EAAE;YACjDkO;YACAC;YACA1P,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;QAC/B;QAEA,sDAAsD;QACtD,MAAMqO,oBAAoB;YAAC;YAAQ;YAAkB;SAAkB;QACvE,MAAMC,gBAAgB;YAAC;YAAW;YAAiB;SAAoB;QAEvE,IAAI,CAACD,kBAAkB/I,QAAQ,CAAC4I,YAAY;YAC1C,MAAM,IAAI3O,MAAM,CAAC,oBAAoB,EAAE2O,UAAU,gBAAgB,CAAC;QACpE;QAEA,IAAI,CAACI,cAAchJ,QAAQ,CAAC6I,QAAQ;YAClC,MAAM,IAAI5O,MAAM,CAAC,gBAAgB,EAAE4O,MAAM,gBAAgB,CAAC;QAC5D;QAEA,IAAI;YACF,IAAIzG;YAEJ,OAAQwG;gBACN,KAAK;oBACH,IAAIC,UAAU,WAAW;wBACvBzG,SAAS,MAAMjI,eAAM,CAACS,OAAO,CAACP,UAAU,CAAC;4BACvCC,OAAO;gCAAEI,IAAIyB,QAAQvB,OAAO,CAACF,EAAE;4BAAC;4BAChCuC,QAAQ;gCACNvC,IAAI;gCACJwL,OAAO;gCACPF,WAAW;gCACXC,UAAU;gCACVgD,WAAW;gCACXC,MAAM;gCACNhC,WAAW;4BACb;wBACF;oBACF;oBACA;gBAEF,KAAK;oBACH,gCAAgC;oBAChC,MAAMiC,iBAAsB,CAAC;oBAC7B,IAAIlN,KAAKiN,IAAI,EAAEC,eAAeD,IAAI,GAAGjN,KAAKiN,IAAI;oBAC9C,IAAIjN,KAAKgN,SAAS,EAAEE,eAAeF,SAAS,GAAGG,KAAKC,GAAG,CAAC,GAAGD,KAAKE,GAAG,CAAC,KAAKrN,KAAKgN,SAAS;oBACvF,IAAIhN,KAAKsN,YAAY,EAAEJ,eAAeI,YAAY,GAAGtN,KAAKsN,YAAY;oBAEtEnH,SAAS,MAAMjI,eAAM,CAACS,OAAO,CAACwD,MAAM,CAAC;wBACnC9D,OAAO;4BAAEI,IAAIyB,QAAQvB,OAAO,CAACF,EAAE;wBAAC;wBAChCuB,MAAMkN;oBACR;oBACA;gBAEF,KAAK;oBACH/G,SAAS,MAAMjI,eAAM,CAACqM,aAAa,CAACxK,MAAM,CAAC;wBACzCC,MAAM;4BACJvB,IAAI,CAAC,SAAS,EAAEyB,QAAQxB,QAAQ,CAACD,EAAE,CAAC,CAAC,EAAEgC,KAAK+E,GAAG,IAAI;4BACnDtI,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;4BAC7B4G,YAAYrF,KAAKqF,UAAU,IAAI,CAAC,SAAS,EAAEnF,QAAQxB,QAAQ,CAACD,EAAE,EAAE;4BAChEmB,MAAMI,KAAKJ,IAAI,IAAI;4BACnBkG,UAAU/G,KAAKoB,SAAS,CAAC;gCACvBlD,YAAYiD,QAAQxB,QAAQ,CAACD,EAAE;gCAC/B8O,QAAQ5N,MAAKlB,EAAE;gCACf,GAAGuB,KAAK8F,QAAQ;4BAClB;wBACF;oBACF;oBACA;gBAEF;oBACE,MAAM,IAAI9H,MAAM,CAAC,gCAAgC,EAAE2O,WAAW;YAClE;YAEA,OAAO;gBACLlG,SAAS;gBACTkG;gBACAxG;gBACAuG,YAAY,IAAIjM,OAAOmD,WAAW;YACpC;QACF,EAAE,OAAOhG,OAAO;YACdE,cAAM,CAACF,KAAK,CAAC,6BAA6B;gBAAEA;gBAAO+O;gBAAWC;YAAM;YACpE,OAAO;gBACLnG,SAAS;gBACT7I,OAAOA,iBAAiBI,QAAQJ,MAAM2B,OAAO,GAAG;gBAChDmN,YAAY,IAAIjM,OAAOmD,WAAW;YACpC;QACF;IACF;IAEA;;GAEC,GACD,MAAc/B,iBAAiBlC,KAAkB,EAAEO,OAAyB,EAAgB;QAC1F,MAAMwD,aAAa/D,MAAKK,IAAI,CAAC0D,UAAU,IAAI,CAAC;QAC5C,MAAM,EAAE8J,SAAS,EAAEC,UAAU,EAAEC,YAAY,SAAS,EAAE,GAAGhK;QAEzD5F,cAAM,CAACU,IAAI,CAAC,CAAC,sBAAsB,EAAEmB,MAAKlB,EAAE,EAAE,EAAE;YAC9C+O;YACAC;YACAC;YACAxQ,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;QAC/B;QAEA,IAAI4E,UAAU;QAEd,IAAImK,cAAc,SAAS;YACzB,MAAMG,cAAc;gBAClBC,SAAS;gBACTC,SAAS,KAAK;gBACdC,OAAO,KAAK,KAAK;gBACjBC,MAAM,KAAK,KAAK,KAAK;YACvB;YAEA,MAAMC,aAAaL,WAAW,CAACD,UAAsC,IAAIC,YAAYE,OAAO;YAC5FxK,UAAUoK,aAAaO;YAEvB,4CAA4C;YAC5C,MAAMC,WAAW,KAAK,KAAK,KAAK,KAAK;YACrC,IAAI5K,UAAU4K,UAAU;gBACtB,MAAM,IAAIjQ,MAAM;YAClB;QACF,OAAO,IAAIwP,cAAc,gBAAgB;YACvC,oDAAoD;YACpD,IAAI;gBACF,2CAA2C;gBAC3C,MAAMU,cAAc,IAAIzN,KAAKA,KAAK+E,GAAG,KAAK,KAAK,KAAK,OAAO,6BAA6B;gBACxFnC,UAAU8J,KAAKC,GAAG,CAAC,GAAGc,YAAYtE,OAAO,KAAKnJ,KAAK+E,GAAG;YACxD,EAAE,OAAO5H,OAAO;gBACdE,cAAM,CAACC,IAAI,CAAC,mDAAmD;oBAAEH;gBAAM;gBACvEyF,UAAU,KAAK,KAAK,MAAM,oBAAoB;YAChD;QACF;QAEA,4CAA4C;QAC5C,IAAIA,UAAU,GAAG;YACf,MAAMiG,iBAAU,CAACC,GAAG,CAClB,yBACA;gBACE3I,aAAaV,QAAQxB,QAAQ,CAACkC,WAAW;gBACzCG,QAAQpB,MAAKlB,EAAE;gBACf0P,YAAYzK,WAAWyK,UAAU;YACnC,GACA;gBACE1E,OAAOpG;gBACP+K,UAAU;gBACVC,SAAS;oBACPzO,MAAM;oBACN6J,OAAO;gBACT;YACF;QAEJ;QAEA,OAAO;YACL6E,SAAS;YACTjL;YACAmK;YACAhF,cAAc,IAAI/H,KAAKA,KAAK+E,GAAG,KAAKnC,SAASO,WAAW;YACxD8I,YAAY,IAAIjM,OAAOmD,WAAW;QACpC;IACF;IAEA;;GAEC,GACD,MAAc9B,iBAAiBnC,KAAkB,EAAEO,OAAyB,EAAgB;QAC1F,MAAMwD,aAAa/D,MAAKK,IAAI,CAAC0D,UAAU,IAAI,CAAC;QAC5C,MAAM,EAAE6K,SAAS,EAAEC,WAAW,EAAE,EAAE,GAAG9K;QAErC5F,cAAM,CAACU,IAAI,CAAC,CAAC,sBAAsB,EAAEmB,MAAKlB,EAAE,EAAE,EAAE;YAC9C8P;YACAE,aAAaD,SAAS3O,MAAM;YAC5B3C,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;QAC/B;QAEA,IAAIiQ;QAEJ,IAAIH,cAAc,UAAU;YAC1B,2CAA2C;YAC3C,MAAMI,SAASxB,KAAKwB,MAAM,KAAK;YAC/B,IAAIC,aAAa;YAEjB,KAAK,MAAMC,UAAUL,SAAU;gBAC7BI,cAAcC,OAAOC,UAAU,IAAI;gBACnC,IAAIH,UAAUC,YAAY;oBACxBF,iBAAiBG;oBACjB;gBACF;YACF;QACF,OAAO,IAAIN,cAAc,YAAY;YACnC,kCAAkC;YAClC,MAAM,EAAE5D,QAAQ,EAAEkC,UAAU,EAAE,GAAGnJ;YACjC,MAAM0H,eAAe,AAAClL,QAAQvB,OAAO,AAAQ,CAACgM,SAAS;YAEvD+D,iBAAiBF,SAAStN,IAAI,CAAC,CAAC2N;gBAC9B,OAAOA,OAAOhC,UAAU,EAAEkC,KAAK,CAAC1K;oBAC9B,OAAQA,UAAU6G,QAAQ;wBACxB,KAAK;4BACH,OAAOE,iBAAiB/G,UAAU8G,KAAK;wBACzC,KAAK;4BACH,OAAOvI,OAAOwI,cAAcrH,QAAQ,CAACM,UAAU8G,KAAK;wBACtD,KAAK;4BACH,OAAO6D,OAAO5D,gBAAgB4D,OAAO3K,UAAU8G,KAAK;wBACtD;4BACE,OAAO;oBACX;gBACF;YACF;QACF;QAEA,sCAAsC;QACtC,IAAI,CAACuD,kBAAkBF,SAAS3O,MAAM,GAAG,GAAG;YAC1C6O,iBAAiBF,QAAQ,CAAC,EAAE;QAC9B;QAEA,OAAO;YACLE,gBAAgBA,gBAAgBjQ,MAAM;YACtC8P;YACA7B,YAAY,IAAIjM,OAAOmD,WAAW;QACpC;IACF;IAEA;;GAEC,GACD,MAAc7B,qBAAqBpC,KAAkB,EAAEO,OAAyB,EAAgB;QAC9F,MAAMwD,aAAa/D,MAAKK,IAAI,CAAC0D,UAAU,IAAI,CAAC;QAC5C,MAAM,EAAEuL,kBAAkB,EAAE,EAAE,GAAGvL;QAEjC5F,cAAM,CAACU,IAAI,CAAC,CAAC,0BAA0B,EAAEmB,MAAKlB,EAAE,EAAE,EAAE;YAClDyQ,qBAAqBD,gBAAgBpP,MAAM;YAC3C3C,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;QAC/B;QAEA,MAAM8B,UAAe,CAAC;QAEtB,KAAK,MAAM4O,kBAAkBF,gBAAiB;YAC5C,MAAM,EAAEtC,SAAS,EAAEyC,WAAW,EAAEC,WAAW,EAAElE,KAAK,EAAEmE,MAAM,EAAE,GAAGH;YAE/D,IAAI;gBACF,OAAQxC;oBACN,KAAK;wBACHpM,OAAO,CAAC8O,YAAY,GAAG,AAACnP,QAAQvB,OAAO,AAAQ,CAACyQ,YAAY;wBAC5D;oBAEF,KAAK;wBACH7O,OAAO,CAAC8O,YAAY,GAAG,IAAI,CAAClK,gBAAgB,CAACgG,OAAOjL;wBACpD;oBAEF,KAAK;wBACH,MAAMqP,SAASH,YAAYI,KAAK,CAAC,KAAKC,GAAG,CAAC,CAACC,QACzC,AAACxP,QAAQvB,OAAO,AAAQ,CAAC+Q,MAAMC,IAAI,GAAG,IAAI;wBAE5CpP,OAAO,CAAC8O,YAAY,GAAGE,OAAOK,IAAI,CAAC,KAAKD,IAAI;wBAC5C;oBAEF,KAAK;wBACH,MAAME,YAAY,IAAIpP,KAAK,AAACP,QAAQvB,OAAO,AAAQ,CAACyQ,YAAY;wBAChE,IAAIU,MAAMD,UAAUjG,OAAO,KAAK;4BAC9BrJ,OAAO,CAAC8O,YAAY,GAAG;wBACzB,OAAO;4BACL9O,OAAO,CAAC8O,YAAY,GAAGQ,UAAUE,kBAAkB;wBACrD;wBACA;oBAEF,KAAK;wBACH,8CAA8C;wBAC9C,IAAIC,QAAQ;wBACZ,IAAI9P,QAAQvB,OAAO,CAACsL,KAAK,EAAE+F,SAAS;wBACpC,IAAI9P,QAAQvB,OAAO,CAACoL,SAAS,EAAEiG,SAAS;wBACxC,IAAI9P,QAAQvB,OAAO,CAACuL,OAAO,EAAE8F,SAAS;wBACtC,IAAI9P,QAAQvB,OAAO,CAACsI,KAAK,EAAE+I,SAAS;wBACpCzP,OAAO,CAAC8O,YAAY,GAAGlC,KAAKE,GAAG,CAAC,KAAK2C;wBACrC;oBAEF;wBACElS,cAAM,CAACC,IAAI,CAAC,CAAC,kCAAkC,EAAE4O,WAAW;gBAChE;YACF,EAAE,OAAO/O,OAAO;gBACdE,cAAM,CAACF,KAAK,CAAC,yBAAyB;oBAAEA;oBAAOuR;gBAAe;gBAC9D5O,OAAO,CAAC8O,YAAY,GAAG;YACzB;QACF;QAEA,uDAAuD;QACvDnP,QAAQE,SAAS,GAAG;YAAE,GAAGF,QAAQE,SAAS;YAAE,GAAGG,OAAO;QAAC;QAEvD,OAAO;YACLkG,SAAS;YACTwI,iBAAiB1O;YACjBmM,YAAY,IAAIjM,OAAOmD,WAAW;QACpC;IACF;IAEA;;GAEC,GACD,MAAc5B,mBAAmBrC,KAAkB,EAAEO,OAAyB,EAAgB;QAC5F,MAAMwD,aAAa/D,MAAKK,IAAI,CAAC0D,UAAU,IAAI,CAAC;QAE5C5F,cAAM,CAACU,IAAI,CAAC,CAAC,yBAAyB,EAAEmB,MAAKlB,EAAE,EAAE,EAAE;YACjD6M,QAAQ5H,WAAW4H,MAAM;YACzBD,KAAK3H,WAAW2H,GAAG,EAAE7D,UAAU,GAAG;YAClCtK,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;QAC/B;QAEA,IAAI;YACF,MAAMwR,SAAkC;gBACtC5E,KAAK3H,WAAW2H,GAAG;gBACnBC,QAAQ5H,WAAW4H,MAAM,IAAI;gBAC7BC,SAAS7H,WAAW6H,OAAO,IAAI,CAAC;gBAChCC,SAAS9H,WAAW8H,OAAO,IAAI;gBAC/B0E,YAAYxM,WAAWwM,UAAU,IAAI;gBACrCC,YAAYzM,WAAWyM,UAAU,IAAI;gBACrCC,gBAAgB1M,WAAW0M,cAAc;gBACzCC,cAAc3M,WAAW2M,YAAY;gBACrCC,iBAAiB5M,WAAW4M,eAAe;gBAC3CC,kBAAkB7M,WAAW6M,gBAAgB;YAC/C;YAEA,MAAMpK,SAAS,MAAMqK,IAAAA,0CAAqB,EAACP,QAAQ/P;YAEnD,iEAAiE;YACjE,IAAIiG,OAAOM,OAAO,IAAIN,OAAOnG,IAAI,EAAE;gBACjCE,QAAQE,SAAS,GAAG;oBAClB,GAAGF,QAAQE,SAAS;oBACpB,CAAC,GAAGT,MAAKlB,EAAE,CAAC,SAAS,CAAC,CAAC,EAAE0H,OAAOnG,IAAI;gBACtC;YACF;YAEA,OAAOmG;QACT,EAAE,OAAOvI,OAAO;YACdE,cAAM,CAACF,KAAK,CAAC,kCAAkC;gBAC7CA,OAAOA,iBAAiBI,QAAQJ,MAAM2B,OAAO,GAAGqD,OAAOhF;gBACvD2P,QAAQ5N,MAAKlB,EAAE;gBACfvB,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;YAC/B;YAEA,OAAO;gBACLgI,SAAS;gBACT7I,OAAOA,iBAAiBI,QAAQJ,MAAM2B,OAAO,GAAG;gBAChDmN,YAAY,IAAIjM,OAAOmD,WAAW;YACpC;QACF;IACF;IAEA;;GAEC,GACD,MAAc3B,qBAAqBtC,KAAkB,EAAEO,OAAyB,EAAgB;QAC9F,MAAMwD,aAAa/D,MAAKK,IAAI,CAAC0D,UAAU,IAAI,CAAC;QAE5C5F,cAAM,CAACU,IAAI,CAAC,CAAC,2BAA2B,EAAEmB,MAAKlB,EAAE,EAAE,EAAE;YACnDgS,YAAY/M,WAAW+M,UAAU;YACjCxI,UAAUvE,WAAWuE,QAAQ;YAC7B/K,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;QAC/B;QAEA,IAAI;YACF,MAAMwR,SAAiC;gBACrC5E,KAAK3H,WAAW2H,GAAG;gBACnBC,QAAQ5H,WAAW4H,MAAM,IAAI;gBAC7BC,SAAS7H,WAAW6H,OAAO,IAAI,CAAC;gBAChCC,SAAS9H,WAAW8H,OAAO,IAAI;gBAC/B0E,YAAYxM,WAAWwM,UAAU,IAAI;gBACrCC,YAAYzM,WAAWyM,UAAU,IAAI;gBACrCC,gBAAgB1M,WAAW0M,cAAc;gBACzCK,YAAY/M,WAAW+M,UAAU;gBACjCxI,UAAUvE,WAAWuE,QAAQ;gBAC7ByI,cAAchN,WAAWgN,YAAY,IAAI,CAAC;YAC5C;YAEA,MAAMvK,SAAS,MAAMwK,IAAAA,qCAAgB,EAACV,QAAQ/P;YAE9C,gDAAgD;YAChD,IAAIiG,OAAOM,OAAO,IAAIN,OAAOnG,IAAI,EAAE;gBACjCE,QAAQE,SAAS,GAAG;oBAClB,GAAGF,QAAQE,SAAS;oBACpB,CAAC,GAAGT,MAAKlB,EAAE,CAAC,aAAa,CAAC,CAAC,EAAE0H,OAAOnG,IAAI;oBACxC,CAAC,GAAGL,MAAKlB,EAAE,CAAC,WAAW,CAAC,CAAC,EAAEiF,WAAW+M,UAAU;gBAClD;YACF;YAEA,OAAOtK;QACT,EAAE,OAAOvI,OAAO;YACdE,cAAM,CAACF,KAAK,CAAC,oCAAoC;gBAC/CA,OAAOA,iBAAiBI,QAAQJ,MAAM2B,OAAO,GAAGqD,OAAOhF;gBACvD2P,QAAQ5N,MAAKlB,EAAE;gBACfgS,YAAY/M,WAAW+M,UAAU;gBACjCxI,UAAUvE,WAAWuE,QAAQ;gBAC7B/K,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;YAC/B;YAEA,OAAO;gBACLgI,SAAS;gBACT7I,OAAOA,iBAAiBI,QAAQJ,MAAM2B,OAAO,GAAG;gBAChDkR,YAAY/M,WAAW+M,UAAU;gBACjCxI,UAAUvE,WAAWuE,QAAQ;gBAC7ByE,YAAY,IAAIjM,OAAOmD,WAAW;YACpC;QACF;IACF;IAEA;;GAEC,GACD,MAAc1B,0BAA0BvC,KAAkB,EAAEO,OAAyB,EAAgB;QACnG,MAAMwD,aAAa/D,MAAKK,IAAI,CAAC0D,UAAU,IAAI,CAAC;QAE5C5F,cAAM,CAACU,IAAI,CAAC,CAAC,gCAAgC,EAAEmB,MAAKlB,EAAE,EAAE,EAAE;YACxDwJ,UAAUvE,WAAWuE,QAAQ;YAC7B2I,aAAalN,WAAWkN,WAAW;YACnC1T,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;QAC/B;QAEA,IAAI;YACF,MAAMwR,SAAsC;gBAC1C5E,KAAK3H,WAAW2H,GAAG;gBACnBC,QAAQ5H,WAAW4H,MAAM,IAAI;gBAC7BC,SAAS7H,WAAW6H,OAAO,IAAI,CAAC;gBAChCC,SAAS9H,WAAW8H,OAAO,IAAI;gBAC/B0E,YAAYxM,WAAWwM,UAAU,IAAI;gBACrCC,YAAYzM,WAAWyM,UAAU,IAAI;gBACrCC,gBAAgB1M,WAAW0M,cAAc;gBACzCnI,UAAUvE,WAAWuE,QAAQ;gBAC7B2I,aAAalN,WAAWkN,WAAW;gBACnCC,WAAWnN,WAAWmN,SAAS,IAAI,CAAC;gBACpCC,WAAWpN,WAAWoN,SAAS;YACjC;YAEA,MAAM3K,SAAS,MAAM4K,IAAAA,0CAAqB,EAACd,QAAQ/P;YAEnD,oDAAoD;YACpD,IAAIiG,OAAOM,OAAO,IAAIN,OAAOnG,IAAI,EAAE;gBACjCE,QAAQE,SAAS,GAAG;oBAClB,GAAGF,QAAQE,SAAS;oBACpB,CAAC,GAAGT,MAAKlB,EAAE,CAAC,iBAAiB,CAAC,CAAC,EAAE0H,OAAOnG,IAAI;oBAC5C,CAAC,GAAGL,MAAKlB,EAAE,CAAC,iBAAiB,CAAC,CAAC,EAAEiF,WAAWuE,QAAQ;oBACpD,CAAC,GAAGtI,MAAKlB,EAAE,CAAC,aAAa,CAAC,CAAC,EAAEiF,WAAWkN,WAAW;gBACrD;YACF;YAEA,OAAOzK;QACT,EAAE,OAAOvI,OAAO;YACdE,cAAM,CAACF,KAAK,CAAC,yCAAyC;gBACpDA,OAAOA,iBAAiBI,QAAQJ,MAAM2B,OAAO,GAAGqD,OAAOhF;gBACvD2P,QAAQ5N,MAAKlB,EAAE;gBACfwJ,UAAUvE,WAAWuE,QAAQ;gBAC7B2I,aAAalN,WAAWkN,WAAW;gBACnC1T,WAAWgD,QAAQvB,OAAO,CAACF,EAAE;YAC/B;YAEA,OAAO;gBACLgI,SAAS;gBACT7I,OAAOA,iBAAiBI,QAAQJ,MAAM2B,OAAO,GAAG;gBAChD0I,UAAUvE,WAAWuE,QAAQ;gBAC7B2I,aAAalN,WAAWkN,WAAW;gBACnClE,YAAY,IAAIjM,OAAOmD,WAAW;YACpC;QACF;IACF;AACF;AAGO,MAAM7G,iBAAiB,IAAID"}