
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model List
 * 
 */
export type List = $Result.DefaultSelection<Prisma.$ListPayload>
/**
 * Model ListMember
 * 
 */
export type ListMember = $Result.DefaultSelection<Prisma.$ListMemberPayload>
/**
 * Model Segment
 * 
 */
export type Segment = $Result.DefaultSelection<Prisma.$SegmentPayload>
/**
 * Model EmailTemplate
 * 
 */
export type EmailTemplate = $Result.DefaultSelection<Prisma.$EmailTemplatePayload>
/**
 * Model EmailCampaign
 * 
 */
export type EmailCampaign = $Result.DefaultSelection<Prisma.$EmailCampaignPayload>
/**
 * Model EmailActivity
 * 
 */
export type EmailActivity = $Result.DefaultSelection<Prisma.$EmailActivityPayload>
/**
 * Model SMSTemplate
 * 
 */
export type SMSTemplate = $Result.DefaultSelection<Prisma.$SMSTemplatePayload>
/**
 * Model SMSCampaign
 * 
 */
export type SMSCampaign = $Result.DefaultSelection<Prisma.$SMSCampaignPayload>
/**
 * Model SMSActivity
 * 
 */
export type SMSActivity = $Result.DefaultSelection<Prisma.$SMSActivityPayload>
/**
 * Model WhatsAppTemplate
 * 
 */
export type WhatsAppTemplate = $Result.DefaultSelection<Prisma.$WhatsAppTemplatePayload>
/**
 * Model WhatsAppCampaign
 * 
 */
export type WhatsAppCampaign = $Result.DefaultSelection<Prisma.$WhatsAppCampaignPayload>
/**
 * Model WhatsAppActivity
 * 
 */
export type WhatsAppActivity = $Result.DefaultSelection<Prisma.$WhatsAppActivityPayload>
/**
 * Model Workflow
 * 
 */
export type Workflow = $Result.DefaultSelection<Prisma.$WorkflowPayload>
/**
 * Model WorkflowNode
 * 
 */
export type WorkflowNode = $Result.DefaultSelection<Prisma.$WorkflowNodePayload>
/**
 * Model Connection
 * 
 */
export type Connection = $Result.DefaultSelection<Prisma.$ConnectionPayload>
/**
 * Model WorkflowTrigger
 * 
 */
export type WorkflowTrigger = $Result.DefaultSelection<Prisma.$WorkflowTriggerPayload>
/**
 * Model Analytics
 * 
 */
export type Analytics = $Result.DefaultSelection<Prisma.$AnalyticsPayload>
/**
 * Model IntegrationConnection
 * 
 */
export type IntegrationConnection = $Result.DefaultSelection<Prisma.$IntegrationConnectionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  USER: 'USER',
  ADMIN: 'ADMIN',
  IT_ADMIN: 'IT_ADMIN',
  SUPER_ADMIN: 'SUPER_ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ContactStatus: {
  ACTIVE: 'ACTIVE',
  UNSUBSCRIBED: 'UNSUBSCRIBED',
  BOUNCED: 'BOUNCED',
  SPAM: 'SPAM'
};

export type ContactStatus = (typeof ContactStatus)[keyof typeof ContactStatus]


export const ListType: {
  STATIC: 'STATIC',
  DYNAMIC: 'DYNAMIC'
};

export type ListType = (typeof ListType)[keyof typeof ListType]


export const CampaignStatus: {
  DRAFT: 'DRAFT',
  SCHEDULED: 'SCHEDULED',
  SENDING: 'SENDING',
  SENT: 'SENT',
  PAUSED: 'PAUSED',
  CANCELLED: 'CANCELLED'
};

export type CampaignStatus = (typeof CampaignStatus)[keyof typeof CampaignStatus]


export const ActivityType: {
  SENT: 'SENT',
  DELIVERED: 'DELIVERED',
  OPENED: 'OPENED',
  CLICKED: 'CLICKED',
  BOUNCED: 'BOUNCED',
  UNSUBSCRIBED: 'UNSUBSCRIBED',
  REPLIED: 'REPLIED',
  FAILED: 'FAILED'
};

export type ActivityType = (typeof ActivityType)[keyof typeof ActivityType]


export const WATemplateStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type WATemplateStatus = (typeof WATemplateStatus)[keyof typeof WATemplateStatus]


export const WorkflowStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  PAUSED: 'PAUSED',
  ARCHIVED: 'ARCHIVED'
};

export type WorkflowStatus = (typeof WorkflowStatus)[keyof typeof WorkflowStatus]


export const WorkflowNodeType: {
  TRIGGER: 'TRIGGER',
  CONDITION: 'CONDITION',
  ACTION: 'ACTION',
  DELAY: 'DELAY',
  EMAIL: 'EMAIL',
  SMS: 'SMS',
  WHATSAPP: 'WHATSAPP',
  NOTIFICATION: 'NOTIFICATION',
  WEBHOOK: 'WEBHOOK'
};

export type WorkflowNodeType = (typeof WorkflowNodeType)[keyof typeof WorkflowNodeType]


export const TriggerType: {
  CONTACT_CREATED: 'CONTACT_CREATED',
  CONTACT_UPDATED: 'CONTACT_UPDATED',
  EMAIL_OPENED: 'EMAIL_OPENED',
  EMAIL_CLICKED: 'EMAIL_CLICKED',
  FORM_SUBMITTED: 'FORM_SUBMITTED',
  WEBHOOK: 'WEBHOOK',
  SCHEDULED: 'SCHEDULED'
};

export type TriggerType = (typeof TriggerType)[keyof typeof TriggerType]


export const EntityType: {
  EMAIL_CAMPAIGN: 'EMAIL_CAMPAIGN',
  SMS_CAMPAIGN: 'SMS_CAMPAIGN',
  WHATSAPP_CAMPAIGN: 'WHATSAPP_CAMPAIGN',
  WORKFLOW: 'WORKFLOW',
  LIST: 'LIST',
  SEGMENT: 'SEGMENT'
};

export type EntityType = (typeof EntityType)[keyof typeof EntityType]


export const AnalyticsPeriod: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY',
  YEARLY: 'YEARLY'
};

export type AnalyticsPeriod = (typeof AnalyticsPeriod)[keyof typeof AnalyticsPeriod]


export const IntegrationType: {
  ECOMMERCE_WOOCOMMERCE: 'ECOMMERCE_WOOCOMMERCE',
  ECOMMERCE_SHOPIFY: 'ECOMMERCE_SHOPIFY',
  CRM_SALESFORCE: 'CRM_SALESFORCE',
  CRM_HUBSPOT: 'CRM_HUBSPOT',
  PAYMENT_STRIPE: 'PAYMENT_STRIPE',
  PAYMENT_PAYPAL: 'PAYMENT_PAYPAL',
  WEBHOOK: 'WEBHOOK',
  API: 'API'
};

export type IntegrationType = (typeof IntegrationType)[keyof typeof IntegrationType]


export const ConnectionStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  ERROR: 'ERROR'
};

export type ConnectionStatus = (typeof ConnectionStatus)[keyof typeof ConnectionStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ContactStatus = $Enums.ContactStatus

export const ContactStatus: typeof $Enums.ContactStatus

export type ListType = $Enums.ListType

export const ListType: typeof $Enums.ListType

export type CampaignStatus = $Enums.CampaignStatus

export const CampaignStatus: typeof $Enums.CampaignStatus

export type ActivityType = $Enums.ActivityType

export const ActivityType: typeof $Enums.ActivityType

export type WATemplateStatus = $Enums.WATemplateStatus

export const WATemplateStatus: typeof $Enums.WATemplateStatus

export type WorkflowStatus = $Enums.WorkflowStatus

export const WorkflowStatus: typeof $Enums.WorkflowStatus

export type WorkflowNodeType = $Enums.WorkflowNodeType

export const WorkflowNodeType: typeof $Enums.WorkflowNodeType

export type TriggerType = $Enums.TriggerType

export const TriggerType: typeof $Enums.TriggerType

export type EntityType = $Enums.EntityType

export const EntityType: typeof $Enums.EntityType

export type AnalyticsPeriod = $Enums.AnalyticsPeriod

export const AnalyticsPeriod: typeof $Enums.AnalyticsPeriod

export type IntegrationType = $Enums.IntegrationType

export const IntegrationType: typeof $Enums.IntegrationType

export type ConnectionStatus = $Enums.ConnectionStatus

export const ConnectionStatus: typeof $Enums.ConnectionStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.list`: Exposes CRUD operations for the **List** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lists
    * const lists = await prisma.list.findMany()
    * ```
    */
  get list(): Prisma.ListDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.listMember`: Exposes CRUD operations for the **ListMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ListMembers
    * const listMembers = await prisma.listMember.findMany()
    * ```
    */
  get listMember(): Prisma.ListMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.segment`: Exposes CRUD operations for the **Segment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Segments
    * const segments = await prisma.segment.findMany()
    * ```
    */
  get segment(): Prisma.SegmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailTemplate`: Exposes CRUD operations for the **EmailTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailTemplates
    * const emailTemplates = await prisma.emailTemplate.findMany()
    * ```
    */
  get emailTemplate(): Prisma.EmailTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailCampaign`: Exposes CRUD operations for the **EmailCampaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailCampaigns
    * const emailCampaigns = await prisma.emailCampaign.findMany()
    * ```
    */
  get emailCampaign(): Prisma.EmailCampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailActivity`: Exposes CRUD operations for the **EmailActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailActivities
    * const emailActivities = await prisma.emailActivity.findMany()
    * ```
    */
  get emailActivity(): Prisma.EmailActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sMSTemplate`: Exposes CRUD operations for the **SMSTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SMSTemplates
    * const sMSTemplates = await prisma.sMSTemplate.findMany()
    * ```
    */
  get sMSTemplate(): Prisma.SMSTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sMSCampaign`: Exposes CRUD operations for the **SMSCampaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SMSCampaigns
    * const sMSCampaigns = await prisma.sMSCampaign.findMany()
    * ```
    */
  get sMSCampaign(): Prisma.SMSCampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sMSActivity`: Exposes CRUD operations for the **SMSActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SMSActivities
    * const sMSActivities = await prisma.sMSActivity.findMany()
    * ```
    */
  get sMSActivity(): Prisma.SMSActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsAppTemplate`: Exposes CRUD operations for the **WhatsAppTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsAppTemplates
    * const whatsAppTemplates = await prisma.whatsAppTemplate.findMany()
    * ```
    */
  get whatsAppTemplate(): Prisma.WhatsAppTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsAppCampaign`: Exposes CRUD operations for the **WhatsAppCampaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsAppCampaigns
    * const whatsAppCampaigns = await prisma.whatsAppCampaign.findMany()
    * ```
    */
  get whatsAppCampaign(): Prisma.WhatsAppCampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsAppActivity`: Exposes CRUD operations for the **WhatsAppActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsAppActivities
    * const whatsAppActivities = await prisma.whatsAppActivity.findMany()
    * ```
    */
  get whatsAppActivity(): Prisma.WhatsAppActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workflow`: Exposes CRUD operations for the **Workflow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workflows
    * const workflows = await prisma.workflow.findMany()
    * ```
    */
  get workflow(): Prisma.WorkflowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workflowNode`: Exposes CRUD operations for the **WorkflowNode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowNodes
    * const workflowNodes = await prisma.workflowNode.findMany()
    * ```
    */
  get workflowNode(): Prisma.WorkflowNodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.connection`: Exposes CRUD operations for the **Connection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Connections
    * const connections = await prisma.connection.findMany()
    * ```
    */
  get connection(): Prisma.ConnectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workflowTrigger`: Exposes CRUD operations for the **WorkflowTrigger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowTriggers
    * const workflowTriggers = await prisma.workflowTrigger.findMany()
    * ```
    */
  get workflowTrigger(): Prisma.WorkflowTriggerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analytics`: Exposes CRUD operations for the **Analytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Analytics
    * const analytics = await prisma.analytics.findMany()
    * ```
    */
  get analytics(): Prisma.AnalyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.integrationConnection`: Exposes CRUD operations for the **IntegrationConnection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntegrationConnections
    * const integrationConnections = await prisma.integrationConnection.findMany()
    * ```
    */
  get integrationConnection(): Prisma.IntegrationConnectionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    Contact: 'Contact',
    List: 'List',
    ListMember: 'ListMember',
    Segment: 'Segment',
    EmailTemplate: 'EmailTemplate',
    EmailCampaign: 'EmailCampaign',
    EmailActivity: 'EmailActivity',
    SMSTemplate: 'SMSTemplate',
    SMSCampaign: 'SMSCampaign',
    SMSActivity: 'SMSActivity',
    WhatsAppTemplate: 'WhatsAppTemplate',
    WhatsAppCampaign: 'WhatsAppCampaign',
    WhatsAppActivity: 'WhatsAppActivity',
    Workflow: 'Workflow',
    WorkflowNode: 'WorkflowNode',
    Connection: 'Connection',
    WorkflowTrigger: 'WorkflowTrigger',
    Analytics: 'Analytics',
    IntegrationConnection: 'IntegrationConnection'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "account" | "session" | "verificationToken" | "contact" | "list" | "listMember" | "segment" | "emailTemplate" | "emailCampaign" | "emailActivity" | "sMSTemplate" | "sMSCampaign" | "sMSActivity" | "whatsAppTemplate" | "whatsAppCampaign" | "whatsAppActivity" | "workflow" | "workflowNode" | "connection" | "workflowTrigger" | "analytics" | "integrationConnection"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      List: {
        payload: Prisma.$ListPayload<ExtArgs>
        fields: Prisma.ListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>
          }
          findFirst: {
            args: Prisma.ListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>
          }
          findMany: {
            args: Prisma.ListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>[]
          }
          create: {
            args: Prisma.ListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>
          }
          createMany: {
            args: Prisma.ListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>[]
          }
          delete: {
            args: Prisma.ListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>
          }
          update: {
            args: Prisma.ListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>
          }
          deleteMany: {
            args: Prisma.ListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ListUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>[]
          }
          upsert: {
            args: Prisma.ListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>
          }
          aggregate: {
            args: Prisma.ListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateList>
          }
          groupBy: {
            args: Prisma.ListGroupByArgs<ExtArgs>
            result: $Utils.Optional<ListGroupByOutputType>[]
          }
          count: {
            args: Prisma.ListCountArgs<ExtArgs>
            result: $Utils.Optional<ListCountAggregateOutputType> | number
          }
        }
      }
      ListMember: {
        payload: Prisma.$ListMemberPayload<ExtArgs>
        fields: Prisma.ListMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ListMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ListMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListMemberPayload>
          }
          findFirst: {
            args: Prisma.ListMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ListMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListMemberPayload>
          }
          findMany: {
            args: Prisma.ListMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListMemberPayload>[]
          }
          create: {
            args: Prisma.ListMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListMemberPayload>
          }
          createMany: {
            args: Prisma.ListMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ListMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListMemberPayload>[]
          }
          delete: {
            args: Prisma.ListMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListMemberPayload>
          }
          update: {
            args: Prisma.ListMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListMemberPayload>
          }
          deleteMany: {
            args: Prisma.ListMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ListMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ListMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListMemberPayload>[]
          }
          upsert: {
            args: Prisma.ListMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListMemberPayload>
          }
          aggregate: {
            args: Prisma.ListMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateListMember>
          }
          groupBy: {
            args: Prisma.ListMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ListMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ListMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ListMemberCountAggregateOutputType> | number
          }
        }
      }
      Segment: {
        payload: Prisma.$SegmentPayload<ExtArgs>
        fields: Prisma.SegmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SegmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SegmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>
          }
          findFirst: {
            args: Prisma.SegmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SegmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>
          }
          findMany: {
            args: Prisma.SegmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>[]
          }
          create: {
            args: Prisma.SegmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>
          }
          createMany: {
            args: Prisma.SegmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SegmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>[]
          }
          delete: {
            args: Prisma.SegmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>
          }
          update: {
            args: Prisma.SegmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>
          }
          deleteMany: {
            args: Prisma.SegmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SegmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SegmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>[]
          }
          upsert: {
            args: Prisma.SegmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>
          }
          aggregate: {
            args: Prisma.SegmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSegment>
          }
          groupBy: {
            args: Prisma.SegmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<SegmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SegmentCountArgs<ExtArgs>
            result: $Utils.Optional<SegmentCountAggregateOutputType> | number
          }
        }
      }
      EmailTemplate: {
        payload: Prisma.$EmailTemplatePayload<ExtArgs>
        fields: Prisma.EmailTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findFirst: {
            args: Prisma.EmailTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findMany: {
            args: Prisma.EmailTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          create: {
            args: Prisma.EmailTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          createMany: {
            args: Prisma.EmailTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          delete: {
            args: Prisma.EmailTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          update: {
            args: Prisma.EmailTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          deleteMany: {
            args: Prisma.EmailTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          upsert: {
            args: Prisma.EmailTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          aggregate: {
            args: Prisma.EmailTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailTemplate>
          }
          groupBy: {
            args: Prisma.EmailTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<EmailTemplateCountAggregateOutputType> | number
          }
        }
      }
      EmailCampaign: {
        payload: Prisma.$EmailCampaignPayload<ExtArgs>
        fields: Prisma.EmailCampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailCampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailCampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignPayload>
          }
          findFirst: {
            args: Prisma.EmailCampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailCampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignPayload>
          }
          findMany: {
            args: Prisma.EmailCampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignPayload>[]
          }
          create: {
            args: Prisma.EmailCampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignPayload>
          }
          createMany: {
            args: Prisma.EmailCampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailCampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignPayload>[]
          }
          delete: {
            args: Prisma.EmailCampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignPayload>
          }
          update: {
            args: Prisma.EmailCampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignPayload>
          }
          deleteMany: {
            args: Prisma.EmailCampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailCampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailCampaignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignPayload>[]
          }
          upsert: {
            args: Prisma.EmailCampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignPayload>
          }
          aggregate: {
            args: Prisma.EmailCampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailCampaign>
          }
          groupBy: {
            args: Prisma.EmailCampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailCampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailCampaignCountArgs<ExtArgs>
            result: $Utils.Optional<EmailCampaignCountAggregateOutputType> | number
          }
        }
      }
      EmailActivity: {
        payload: Prisma.$EmailActivityPayload<ExtArgs>
        fields: Prisma.EmailActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailActivityPayload>
          }
          findFirst: {
            args: Prisma.EmailActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailActivityPayload>
          }
          findMany: {
            args: Prisma.EmailActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailActivityPayload>[]
          }
          create: {
            args: Prisma.EmailActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailActivityPayload>
          }
          createMany: {
            args: Prisma.EmailActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailActivityPayload>[]
          }
          delete: {
            args: Prisma.EmailActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailActivityPayload>
          }
          update: {
            args: Prisma.EmailActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailActivityPayload>
          }
          deleteMany: {
            args: Prisma.EmailActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailActivityPayload>[]
          }
          upsert: {
            args: Prisma.EmailActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailActivityPayload>
          }
          aggregate: {
            args: Prisma.EmailActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailActivity>
          }
          groupBy: {
            args: Prisma.EmailActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailActivityCountArgs<ExtArgs>
            result: $Utils.Optional<EmailActivityCountAggregateOutputType> | number
          }
        }
      }
      SMSTemplate: {
        payload: Prisma.$SMSTemplatePayload<ExtArgs>
        fields: Prisma.SMSTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SMSTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SMSTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSTemplatePayload>
          }
          findFirst: {
            args: Prisma.SMSTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SMSTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSTemplatePayload>
          }
          findMany: {
            args: Prisma.SMSTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSTemplatePayload>[]
          }
          create: {
            args: Prisma.SMSTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSTemplatePayload>
          }
          createMany: {
            args: Prisma.SMSTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SMSTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSTemplatePayload>[]
          }
          delete: {
            args: Prisma.SMSTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSTemplatePayload>
          }
          update: {
            args: Prisma.SMSTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSTemplatePayload>
          }
          deleteMany: {
            args: Prisma.SMSTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SMSTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SMSTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSTemplatePayload>[]
          }
          upsert: {
            args: Prisma.SMSTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSTemplatePayload>
          }
          aggregate: {
            args: Prisma.SMSTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSMSTemplate>
          }
          groupBy: {
            args: Prisma.SMSTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<SMSTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.SMSTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<SMSTemplateCountAggregateOutputType> | number
          }
        }
      }
      SMSCampaign: {
        payload: Prisma.$SMSCampaignPayload<ExtArgs>
        fields: Prisma.SMSCampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SMSCampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSCampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SMSCampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSCampaignPayload>
          }
          findFirst: {
            args: Prisma.SMSCampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSCampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SMSCampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSCampaignPayload>
          }
          findMany: {
            args: Prisma.SMSCampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSCampaignPayload>[]
          }
          create: {
            args: Prisma.SMSCampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSCampaignPayload>
          }
          createMany: {
            args: Prisma.SMSCampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SMSCampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSCampaignPayload>[]
          }
          delete: {
            args: Prisma.SMSCampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSCampaignPayload>
          }
          update: {
            args: Prisma.SMSCampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSCampaignPayload>
          }
          deleteMany: {
            args: Prisma.SMSCampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SMSCampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SMSCampaignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSCampaignPayload>[]
          }
          upsert: {
            args: Prisma.SMSCampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSCampaignPayload>
          }
          aggregate: {
            args: Prisma.SMSCampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSMSCampaign>
          }
          groupBy: {
            args: Prisma.SMSCampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<SMSCampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.SMSCampaignCountArgs<ExtArgs>
            result: $Utils.Optional<SMSCampaignCountAggregateOutputType> | number
          }
        }
      }
      SMSActivity: {
        payload: Prisma.$SMSActivityPayload<ExtArgs>
        fields: Prisma.SMSActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SMSActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SMSActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSActivityPayload>
          }
          findFirst: {
            args: Prisma.SMSActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SMSActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSActivityPayload>
          }
          findMany: {
            args: Prisma.SMSActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSActivityPayload>[]
          }
          create: {
            args: Prisma.SMSActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSActivityPayload>
          }
          createMany: {
            args: Prisma.SMSActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SMSActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSActivityPayload>[]
          }
          delete: {
            args: Prisma.SMSActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSActivityPayload>
          }
          update: {
            args: Prisma.SMSActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSActivityPayload>
          }
          deleteMany: {
            args: Prisma.SMSActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SMSActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SMSActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSActivityPayload>[]
          }
          upsert: {
            args: Prisma.SMSActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMSActivityPayload>
          }
          aggregate: {
            args: Prisma.SMSActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSMSActivity>
          }
          groupBy: {
            args: Prisma.SMSActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<SMSActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.SMSActivityCountArgs<ExtArgs>
            result: $Utils.Optional<SMSActivityCountAggregateOutputType> | number
          }
        }
      }
      WhatsAppTemplate: {
        payload: Prisma.$WhatsAppTemplatePayload<ExtArgs>
        fields: Prisma.WhatsAppTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsAppTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsAppTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppTemplatePayload>
          }
          findFirst: {
            args: Prisma.WhatsAppTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsAppTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppTemplatePayload>
          }
          findMany: {
            args: Prisma.WhatsAppTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppTemplatePayload>[]
          }
          create: {
            args: Prisma.WhatsAppTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppTemplatePayload>
          }
          createMany: {
            args: Prisma.WhatsAppTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsAppTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppTemplatePayload>[]
          }
          delete: {
            args: Prisma.WhatsAppTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppTemplatePayload>
          }
          update: {
            args: Prisma.WhatsAppTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppTemplatePayload>
          }
          deleteMany: {
            args: Prisma.WhatsAppTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsAppTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhatsAppTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppTemplatePayload>[]
          }
          upsert: {
            args: Prisma.WhatsAppTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppTemplatePayload>
          }
          aggregate: {
            args: Prisma.WhatsAppTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsAppTemplate>
          }
          groupBy: {
            args: Prisma.WhatsAppTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsAppTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppTemplateCountAggregateOutputType> | number
          }
        }
      }
      WhatsAppCampaign: {
        payload: Prisma.$WhatsAppCampaignPayload<ExtArgs>
        fields: Prisma.WhatsAppCampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsAppCampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsAppCampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCampaignPayload>
          }
          findFirst: {
            args: Prisma.WhatsAppCampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsAppCampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCampaignPayload>
          }
          findMany: {
            args: Prisma.WhatsAppCampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCampaignPayload>[]
          }
          create: {
            args: Prisma.WhatsAppCampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCampaignPayload>
          }
          createMany: {
            args: Prisma.WhatsAppCampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsAppCampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCampaignPayload>[]
          }
          delete: {
            args: Prisma.WhatsAppCampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCampaignPayload>
          }
          update: {
            args: Prisma.WhatsAppCampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCampaignPayload>
          }
          deleteMany: {
            args: Prisma.WhatsAppCampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsAppCampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhatsAppCampaignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCampaignPayload>[]
          }
          upsert: {
            args: Prisma.WhatsAppCampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCampaignPayload>
          }
          aggregate: {
            args: Prisma.WhatsAppCampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsAppCampaign>
          }
          groupBy: {
            args: Prisma.WhatsAppCampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppCampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsAppCampaignCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppCampaignCountAggregateOutputType> | number
          }
        }
      }
      WhatsAppActivity: {
        payload: Prisma.$WhatsAppActivityPayload<ExtArgs>
        fields: Prisma.WhatsAppActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsAppActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsAppActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppActivityPayload>
          }
          findFirst: {
            args: Prisma.WhatsAppActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsAppActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppActivityPayload>
          }
          findMany: {
            args: Prisma.WhatsAppActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppActivityPayload>[]
          }
          create: {
            args: Prisma.WhatsAppActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppActivityPayload>
          }
          createMany: {
            args: Prisma.WhatsAppActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsAppActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppActivityPayload>[]
          }
          delete: {
            args: Prisma.WhatsAppActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppActivityPayload>
          }
          update: {
            args: Prisma.WhatsAppActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppActivityPayload>
          }
          deleteMany: {
            args: Prisma.WhatsAppActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsAppActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhatsAppActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppActivityPayload>[]
          }
          upsert: {
            args: Prisma.WhatsAppActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppActivityPayload>
          }
          aggregate: {
            args: Prisma.WhatsAppActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsAppActivity>
          }
          groupBy: {
            args: Prisma.WhatsAppActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsAppActivityCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppActivityCountAggregateOutputType> | number
          }
        }
      }
      Workflow: {
        payload: Prisma.$WorkflowPayload<ExtArgs>
        fields: Prisma.WorkflowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          findFirst: {
            args: Prisma.WorkflowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          findMany: {
            args: Prisma.WorkflowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[]
          }
          create: {
            args: Prisma.WorkflowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          createMany: {
            args: Prisma.WorkflowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[]
          }
          delete: {
            args: Prisma.WorkflowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          update: {
            args: Prisma.WorkflowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkflowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[]
          }
          upsert: {
            args: Prisma.WorkflowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          aggregate: {
            args: Prisma.WorkflowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflow>
          }
          groupBy: {
            args: Prisma.WorkflowGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowCountAggregateOutputType> | number
          }
        }
      }
      WorkflowNode: {
        payload: Prisma.$WorkflowNodePayload<ExtArgs>
        fields: Prisma.WorkflowNodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowNodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowNodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowNodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowNodePayload>
          }
          findFirst: {
            args: Prisma.WorkflowNodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowNodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowNodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowNodePayload>
          }
          findMany: {
            args: Prisma.WorkflowNodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowNodePayload>[]
          }
          create: {
            args: Prisma.WorkflowNodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowNodePayload>
          }
          createMany: {
            args: Prisma.WorkflowNodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowNodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowNodePayload>[]
          }
          delete: {
            args: Prisma.WorkflowNodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowNodePayload>
          }
          update: {
            args: Prisma.WorkflowNodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowNodePayload>
          }
          deleteMany: {
            args: Prisma.WorkflowNodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowNodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkflowNodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowNodePayload>[]
          }
          upsert: {
            args: Prisma.WorkflowNodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowNodePayload>
          }
          aggregate: {
            args: Prisma.WorkflowNodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowNode>
          }
          groupBy: {
            args: Prisma.WorkflowNodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowNodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowNodeCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowNodeCountAggregateOutputType> | number
          }
        }
      }
      Connection: {
        payload: Prisma.$ConnectionPayload<ExtArgs>
        fields: Prisma.ConnectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConnectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConnectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          findFirst: {
            args: Prisma.ConnectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConnectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          findMany: {
            args: Prisma.ConnectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>[]
          }
          create: {
            args: Prisma.ConnectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          createMany: {
            args: Prisma.ConnectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConnectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>[]
          }
          delete: {
            args: Prisma.ConnectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          update: {
            args: Prisma.ConnectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          deleteMany: {
            args: Prisma.ConnectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConnectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConnectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>[]
          }
          upsert: {
            args: Prisma.ConnectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          aggregate: {
            args: Prisma.ConnectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConnection>
          }
          groupBy: {
            args: Prisma.ConnectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConnectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConnectionCountArgs<ExtArgs>
            result: $Utils.Optional<ConnectionCountAggregateOutputType> | number
          }
        }
      }
      WorkflowTrigger: {
        payload: Prisma.$WorkflowTriggerPayload<ExtArgs>
        fields: Prisma.WorkflowTriggerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowTriggerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTriggerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowTriggerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTriggerPayload>
          }
          findFirst: {
            args: Prisma.WorkflowTriggerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTriggerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowTriggerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTriggerPayload>
          }
          findMany: {
            args: Prisma.WorkflowTriggerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTriggerPayload>[]
          }
          create: {
            args: Prisma.WorkflowTriggerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTriggerPayload>
          }
          createMany: {
            args: Prisma.WorkflowTriggerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowTriggerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTriggerPayload>[]
          }
          delete: {
            args: Prisma.WorkflowTriggerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTriggerPayload>
          }
          update: {
            args: Prisma.WorkflowTriggerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTriggerPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowTriggerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowTriggerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkflowTriggerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTriggerPayload>[]
          }
          upsert: {
            args: Prisma.WorkflowTriggerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTriggerPayload>
          }
          aggregate: {
            args: Prisma.WorkflowTriggerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowTrigger>
          }
          groupBy: {
            args: Prisma.WorkflowTriggerGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowTriggerGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowTriggerCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowTriggerCountAggregateOutputType> | number
          }
        }
      }
      Analytics: {
        payload: Prisma.$AnalyticsPayload<ExtArgs>
        fields: Prisma.AnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          findMany: {
            args: Prisma.AnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>[]
          }
          create: {
            args: Prisma.AnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          createMany: {
            args: Prisma.AnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          update: {
            args: Prisma.AnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>[]
          }
          upsert: {
            args: Prisma.AnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalytics>
          }
          groupBy: {
            args: Prisma.AnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsCountAggregateOutputType> | number
          }
        }
      }
      IntegrationConnection: {
        payload: Prisma.$IntegrationConnectionPayload<ExtArgs>
        fields: Prisma.IntegrationConnectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntegrationConnectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationConnectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntegrationConnectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationConnectionPayload>
          }
          findFirst: {
            args: Prisma.IntegrationConnectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationConnectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntegrationConnectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationConnectionPayload>
          }
          findMany: {
            args: Prisma.IntegrationConnectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationConnectionPayload>[]
          }
          create: {
            args: Prisma.IntegrationConnectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationConnectionPayload>
          }
          createMany: {
            args: Prisma.IntegrationConnectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntegrationConnectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationConnectionPayload>[]
          }
          delete: {
            args: Prisma.IntegrationConnectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationConnectionPayload>
          }
          update: {
            args: Prisma.IntegrationConnectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationConnectionPayload>
          }
          deleteMany: {
            args: Prisma.IntegrationConnectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntegrationConnectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IntegrationConnectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationConnectionPayload>[]
          }
          upsert: {
            args: Prisma.IntegrationConnectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationConnectionPayload>
          }
          aggregate: {
            args: Prisma.IntegrationConnectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegrationConnection>
          }
          groupBy: {
            args: Prisma.IntegrationConnectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntegrationConnectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntegrationConnectionCountArgs<ExtArgs>
            result: $Utils.Optional<IntegrationConnectionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    contact?: ContactOmit
    list?: ListOmit
    listMember?: ListMemberOmit
    segment?: SegmentOmit
    emailTemplate?: EmailTemplateOmit
    emailCampaign?: EmailCampaignOmit
    emailActivity?: EmailActivityOmit
    sMSTemplate?: SMSTemplateOmit
    sMSCampaign?: SMSCampaignOmit
    sMSActivity?: SMSActivityOmit
    whatsAppTemplate?: WhatsAppTemplateOmit
    whatsAppCampaign?: WhatsAppCampaignOmit
    whatsAppActivity?: WhatsAppActivityOmit
    workflow?: WorkflowOmit
    workflowNode?: WorkflowNodeOmit
    connection?: ConnectionOmit
    workflowTrigger?: WorkflowTriggerOmit
    analytics?: AnalyticsOmit
    integrationConnection?: IntegrationConnectionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    contacts: number
    emailCampaigns: number
    emailTemplates: number
    smsCampaigns: number
    smsTemplates: number
    waCampaigns: number
    waTemplates: number
    workflows: number
    lists: number
    segments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    contacts?: boolean | UserCountOutputTypeCountContactsArgs
    emailCampaigns?: boolean | UserCountOutputTypeCountEmailCampaignsArgs
    emailTemplates?: boolean | UserCountOutputTypeCountEmailTemplatesArgs
    smsCampaigns?: boolean | UserCountOutputTypeCountSmsCampaignsArgs
    smsTemplates?: boolean | UserCountOutputTypeCountSmsTemplatesArgs
    waCampaigns?: boolean | UserCountOutputTypeCountWaCampaignsArgs
    waTemplates?: boolean | UserCountOutputTypeCountWaTemplatesArgs
    workflows?: boolean | UserCountOutputTypeCountWorkflowsArgs
    lists?: boolean | UserCountOutputTypeCountListsArgs
    segments?: boolean | UserCountOutputTypeCountSegmentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailCampaignWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTemplateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSmsCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SMSCampaignWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSmsTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SMSTemplateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWaCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppCampaignWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWaTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppTemplateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSegmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SegmentWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    listMembers: number
    emailActivities: number
    smsActivities: number
    waActivities: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listMembers?: boolean | ContactCountOutputTypeCountListMembersArgs
    emailActivities?: boolean | ContactCountOutputTypeCountEmailActivitiesArgs
    smsActivities?: boolean | ContactCountOutputTypeCountSmsActivitiesArgs
    waActivities?: boolean | ContactCountOutputTypeCountWaActivitiesArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountListMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListMemberWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountEmailActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailActivityWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountSmsActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SMSActivityWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountWaActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppActivityWhereInput
  }


  /**
   * Count Type ListCountOutputType
   */

  export type ListCountOutputType = {
    members: number
    emailCampaigns: number
    smsCampaigns: number
    waCampaigns: number
  }

  export type ListCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ListCountOutputTypeCountMembersArgs
    emailCampaigns?: boolean | ListCountOutputTypeCountEmailCampaignsArgs
    smsCampaigns?: boolean | ListCountOutputTypeCountSmsCampaignsArgs
    waCampaigns?: boolean | ListCountOutputTypeCountWaCampaignsArgs
  }

  // Custom InputTypes
  /**
   * ListCountOutputType without action
   */
  export type ListCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListCountOutputType
     */
    select?: ListCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ListCountOutputType without action
   */
  export type ListCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListMemberWhereInput
  }

  /**
   * ListCountOutputType without action
   */
  export type ListCountOutputTypeCountEmailCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailCampaignWhereInput
  }

  /**
   * ListCountOutputType without action
   */
  export type ListCountOutputTypeCountSmsCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SMSCampaignWhereInput
  }

  /**
   * ListCountOutputType without action
   */
  export type ListCountOutputTypeCountWaCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppCampaignWhereInput
  }


  /**
   * Count Type SegmentCountOutputType
   */

  export type SegmentCountOutputType = {
    emailCampaigns: number
    smsCampaigns: number
    waCampaigns: number
  }

  export type SegmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailCampaigns?: boolean | SegmentCountOutputTypeCountEmailCampaignsArgs
    smsCampaigns?: boolean | SegmentCountOutputTypeCountSmsCampaignsArgs
    waCampaigns?: boolean | SegmentCountOutputTypeCountWaCampaignsArgs
  }

  // Custom InputTypes
  /**
   * SegmentCountOutputType without action
   */
  export type SegmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentCountOutputType
     */
    select?: SegmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SegmentCountOutputType without action
   */
  export type SegmentCountOutputTypeCountEmailCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailCampaignWhereInput
  }

  /**
   * SegmentCountOutputType without action
   */
  export type SegmentCountOutputTypeCountSmsCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SMSCampaignWhereInput
  }

  /**
   * SegmentCountOutputType without action
   */
  export type SegmentCountOutputTypeCountWaCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppCampaignWhereInput
  }


  /**
   * Count Type EmailTemplateCountOutputType
   */

  export type EmailTemplateCountOutputType = {
    campaigns: number
  }

  export type EmailTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | EmailTemplateCountOutputTypeCountCampaignsArgs
  }

  // Custom InputTypes
  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplateCountOutputType
     */
    select?: EmailTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailCampaignWhereInput
  }


  /**
   * Count Type EmailCampaignCountOutputType
   */

  export type EmailCampaignCountOutputType = {
    lists: number
    segments: number
    activities: number
  }

  export type EmailCampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lists?: boolean | EmailCampaignCountOutputTypeCountListsArgs
    segments?: boolean | EmailCampaignCountOutputTypeCountSegmentsArgs
    activities?: boolean | EmailCampaignCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes
  /**
   * EmailCampaignCountOutputType without action
   */
  export type EmailCampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignCountOutputType
     */
    select?: EmailCampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailCampaignCountOutputType without action
   */
  export type EmailCampaignCountOutputTypeCountListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListWhereInput
  }

  /**
   * EmailCampaignCountOutputType without action
   */
  export type EmailCampaignCountOutputTypeCountSegmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SegmentWhereInput
  }

  /**
   * EmailCampaignCountOutputType without action
   */
  export type EmailCampaignCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailActivityWhereInput
  }


  /**
   * Count Type SMSTemplateCountOutputType
   */

  export type SMSTemplateCountOutputType = {
    campaigns: number
  }

  export type SMSTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | SMSTemplateCountOutputTypeCountCampaignsArgs
  }

  // Custom InputTypes
  /**
   * SMSTemplateCountOutputType without action
   */
  export type SMSTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSTemplateCountOutputType
     */
    select?: SMSTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SMSTemplateCountOutputType without action
   */
  export type SMSTemplateCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SMSCampaignWhereInput
  }


  /**
   * Count Type SMSCampaignCountOutputType
   */

  export type SMSCampaignCountOutputType = {
    lists: number
    segments: number
    activities: number
  }

  export type SMSCampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lists?: boolean | SMSCampaignCountOutputTypeCountListsArgs
    segments?: boolean | SMSCampaignCountOutputTypeCountSegmentsArgs
    activities?: boolean | SMSCampaignCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes
  /**
   * SMSCampaignCountOutputType without action
   */
  export type SMSCampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSCampaignCountOutputType
     */
    select?: SMSCampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SMSCampaignCountOutputType without action
   */
  export type SMSCampaignCountOutputTypeCountListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListWhereInput
  }

  /**
   * SMSCampaignCountOutputType without action
   */
  export type SMSCampaignCountOutputTypeCountSegmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SegmentWhereInput
  }

  /**
   * SMSCampaignCountOutputType without action
   */
  export type SMSCampaignCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SMSActivityWhereInput
  }


  /**
   * Count Type WhatsAppTemplateCountOutputType
   */

  export type WhatsAppTemplateCountOutputType = {
    campaigns: number
  }

  export type WhatsAppTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | WhatsAppTemplateCountOutputTypeCountCampaignsArgs
  }

  // Custom InputTypes
  /**
   * WhatsAppTemplateCountOutputType without action
   */
  export type WhatsAppTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppTemplateCountOutputType
     */
    select?: WhatsAppTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WhatsAppTemplateCountOutputType without action
   */
  export type WhatsAppTemplateCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppCampaignWhereInput
  }


  /**
   * Count Type WhatsAppCampaignCountOutputType
   */

  export type WhatsAppCampaignCountOutputType = {
    lists: number
    segments: number
    activities: number
  }

  export type WhatsAppCampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lists?: boolean | WhatsAppCampaignCountOutputTypeCountListsArgs
    segments?: boolean | WhatsAppCampaignCountOutputTypeCountSegmentsArgs
    activities?: boolean | WhatsAppCampaignCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes
  /**
   * WhatsAppCampaignCountOutputType without action
   */
  export type WhatsAppCampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaignCountOutputType
     */
    select?: WhatsAppCampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WhatsAppCampaignCountOutputType without action
   */
  export type WhatsAppCampaignCountOutputTypeCountListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListWhereInput
  }

  /**
   * WhatsAppCampaignCountOutputType without action
   */
  export type WhatsAppCampaignCountOutputTypeCountSegmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SegmentWhereInput
  }

  /**
   * WhatsAppCampaignCountOutputType without action
   */
  export type WhatsAppCampaignCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppActivityWhereInput
  }


  /**
   * Count Type WorkflowCountOutputType
   */

  export type WorkflowCountOutputType = {
    nodes: number
    triggers: number
  }

  export type WorkflowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nodes?: boolean | WorkflowCountOutputTypeCountNodesArgs
    triggers?: boolean | WorkflowCountOutputTypeCountTriggersArgs
  }

  // Custom InputTypes
  /**
   * WorkflowCountOutputType without action
   */
  export type WorkflowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowCountOutputType
     */
    select?: WorkflowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkflowCountOutputType without action
   */
  export type WorkflowCountOutputTypeCountNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowNodeWhereInput
  }

  /**
   * WorkflowCountOutputType without action
   */
  export type WorkflowCountOutputTypeCountTriggersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowTriggerWhereInput
  }


  /**
   * Count Type WorkflowNodeCountOutputType
   */

  export type WorkflowNodeCountOutputType = {
    outgoing: number
    incoming: number
  }

  export type WorkflowNodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outgoing?: boolean | WorkflowNodeCountOutputTypeCountOutgoingArgs
    incoming?: boolean | WorkflowNodeCountOutputTypeCountIncomingArgs
  }

  // Custom InputTypes
  /**
   * WorkflowNodeCountOutputType without action
   */
  export type WorkflowNodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowNodeCountOutputType
     */
    select?: WorkflowNodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkflowNodeCountOutputType without action
   */
  export type WorkflowNodeCountOutputTypeCountOutgoingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionWhereInput
  }

  /**
   * WorkflowNodeCountOutputType without action
   */
  export type WorkflowNodeCountOutputTypeCountIncomingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    password: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLogin: Date | null
    isActive: boolean | null
    role: $Enums.UserRole | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    password: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLogin: Date | null
    isActive: boolean | null
    role: $Enums.UserRole | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    password: number
    image: number
    createdAt: number
    updatedAt: number
    lastLogin: number
    isActive: number
    role: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    password?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    lastLogin?: true
    isActive?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    password?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    lastLogin?: true
    isActive?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    password?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    lastLogin?: true
    isActive?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string
    emailVerified: Date | null
    password: string | null
    image: string | null
    createdAt: Date
    updatedAt: Date
    lastLogin: Date | null
    isActive: boolean
    role: $Enums.UserRole
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
    isActive?: boolean
    role?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    contacts?: boolean | User$contactsArgs<ExtArgs>
    emailCampaigns?: boolean | User$emailCampaignsArgs<ExtArgs>
    emailTemplates?: boolean | User$emailTemplatesArgs<ExtArgs>
    smsCampaigns?: boolean | User$smsCampaignsArgs<ExtArgs>
    smsTemplates?: boolean | User$smsTemplatesArgs<ExtArgs>
    waCampaigns?: boolean | User$waCampaignsArgs<ExtArgs>
    waTemplates?: boolean | User$waTemplatesArgs<ExtArgs>
    workflows?: boolean | User$workflowsArgs<ExtArgs>
    lists?: boolean | User$listsArgs<ExtArgs>
    segments?: boolean | User$segmentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
    isActive?: boolean
    role?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
    isActive?: boolean
    role?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
    isActive?: boolean
    role?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "password" | "image" | "createdAt" | "updatedAt" | "lastLogin" | "isActive" | "role", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    contacts?: boolean | User$contactsArgs<ExtArgs>
    emailCampaigns?: boolean | User$emailCampaignsArgs<ExtArgs>
    emailTemplates?: boolean | User$emailTemplatesArgs<ExtArgs>
    smsCampaigns?: boolean | User$smsCampaignsArgs<ExtArgs>
    smsTemplates?: boolean | User$smsTemplatesArgs<ExtArgs>
    waCampaigns?: boolean | User$waCampaignsArgs<ExtArgs>
    waTemplates?: boolean | User$waTemplatesArgs<ExtArgs>
    workflows?: boolean | User$workflowsArgs<ExtArgs>
    lists?: boolean | User$listsArgs<ExtArgs>
    segments?: boolean | User$segmentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      emailCampaigns: Prisma.$EmailCampaignPayload<ExtArgs>[]
      emailTemplates: Prisma.$EmailTemplatePayload<ExtArgs>[]
      smsCampaigns: Prisma.$SMSCampaignPayload<ExtArgs>[]
      smsTemplates: Prisma.$SMSTemplatePayload<ExtArgs>[]
      waCampaigns: Prisma.$WhatsAppCampaignPayload<ExtArgs>[]
      waTemplates: Prisma.$WhatsAppTemplatePayload<ExtArgs>[]
      workflows: Prisma.$WorkflowPayload<ExtArgs>[]
      lists: Prisma.$ListPayload<ExtArgs>[]
      segments: Prisma.$SegmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string
      emailVerified: Date | null
      password: string | null
      image: string | null
      createdAt: Date
      updatedAt: Date
      lastLogin: Date | null
      isActive: boolean
      role: $Enums.UserRole
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contacts<T extends User$contactsArgs<ExtArgs> = {}>(args?: Subset<T, User$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailCampaigns<T extends User$emailCampaignsArgs<ExtArgs> = {}>(args?: Subset<T, User$emailCampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailTemplates<T extends User$emailTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, User$emailTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    smsCampaigns<T extends User$smsCampaignsArgs<ExtArgs> = {}>(args?: Subset<T, User$smsCampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMSCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    smsTemplates<T extends User$smsTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, User$smsTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMSTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    waCampaigns<T extends User$waCampaignsArgs<ExtArgs> = {}>(args?: Subset<T, User$waCampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    waTemplates<T extends User$waTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, User$waTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workflows<T extends User$workflowsArgs<ExtArgs> = {}>(args?: Subset<T, User$workflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lists<T extends User$listsArgs<ExtArgs> = {}>(args?: Subset<T, User$listsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    segments<T extends User$segmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$segmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly password: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'UserRole'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.contacts
   */
  export type User$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * User.emailCampaigns
   */
  export type User$emailCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
    where?: EmailCampaignWhereInput
    orderBy?: EmailCampaignOrderByWithRelationInput | EmailCampaignOrderByWithRelationInput[]
    cursor?: EmailCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailCampaignScalarFieldEnum | EmailCampaignScalarFieldEnum[]
  }

  /**
   * User.emailTemplates
   */
  export type User$emailTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    where?: EmailTemplateWhereInput
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    cursor?: EmailTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * User.smsCampaigns
   */
  export type User$smsCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSCampaign
     */
    select?: SMSCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSCampaign
     */
    omit?: SMSCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSCampaignInclude<ExtArgs> | null
    where?: SMSCampaignWhereInput
    orderBy?: SMSCampaignOrderByWithRelationInput | SMSCampaignOrderByWithRelationInput[]
    cursor?: SMSCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SMSCampaignScalarFieldEnum | SMSCampaignScalarFieldEnum[]
  }

  /**
   * User.smsTemplates
   */
  export type User$smsTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSTemplate
     */
    select?: SMSTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSTemplate
     */
    omit?: SMSTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSTemplateInclude<ExtArgs> | null
    where?: SMSTemplateWhereInput
    orderBy?: SMSTemplateOrderByWithRelationInput | SMSTemplateOrderByWithRelationInput[]
    cursor?: SMSTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SMSTemplateScalarFieldEnum | SMSTemplateScalarFieldEnum[]
  }

  /**
   * User.waCampaigns
   */
  export type User$waCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
    where?: WhatsAppCampaignWhereInput
    orderBy?: WhatsAppCampaignOrderByWithRelationInput | WhatsAppCampaignOrderByWithRelationInput[]
    cursor?: WhatsAppCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppCampaignScalarFieldEnum | WhatsAppCampaignScalarFieldEnum[]
  }

  /**
   * User.waTemplates
   */
  export type User$waTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppTemplate
     */
    select?: WhatsAppTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppTemplate
     */
    omit?: WhatsAppTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppTemplateInclude<ExtArgs> | null
    where?: WhatsAppTemplateWhereInput
    orderBy?: WhatsAppTemplateOrderByWithRelationInput | WhatsAppTemplateOrderByWithRelationInput[]
    cursor?: WhatsAppTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppTemplateScalarFieldEnum | WhatsAppTemplateScalarFieldEnum[]
  }

  /**
   * User.workflows
   */
  export type User$workflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    cursor?: WorkflowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * User.lists
   */
  export type User$listsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    where?: ListWhereInput
    orderBy?: ListOrderByWithRelationInput | ListOrderByWithRelationInput[]
    cursor?: ListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListScalarFieldEnum | ListScalarFieldEnum[]
  }

  /**
   * User.segments
   */
  export type User$segmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    where?: SegmentWhereInput
    orderBy?: SegmentOrderByWithRelationInput | SegmentOrderByWithRelationInput[]
    cursor?: SegmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SegmentScalarFieldEnum | SegmentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    email: string | null
    phone: string | null
    firstName: string | null
    lastName: string | null
    company: string | null
    jobTitle: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    postalCode: string | null
    notes: string | null
    tagsString: string | null
    source: string | null
    status: $Enums.ContactStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    email: string | null
    phone: string | null
    firstName: string | null
    lastName: string | null
    company: string | null
    jobTitle: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    postalCode: string | null
    notes: string | null
    tagsString: string | null
    source: string | null
    status: $Enums.ContactStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    email: number
    phone: number
    firstName: number
    lastName: number
    company: number
    jobTitle: number
    address: number
    city: number
    state: number
    country: number
    postalCode: number
    notes: number
    tagsString: number
    source: number
    status: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    firstName?: true
    lastName?: true
    company?: true
    jobTitle?: true
    address?: true
    city?: true
    state?: true
    country?: true
    postalCode?: true
    notes?: true
    tagsString?: true
    source?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    firstName?: true
    lastName?: true
    company?: true
    jobTitle?: true
    address?: true
    city?: true
    state?: true
    country?: true
    postalCode?: true
    notes?: true
    tagsString?: true
    source?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    firstName?: true
    lastName?: true
    company?: true
    jobTitle?: true
    address?: true
    city?: true
    state?: true
    country?: true
    postalCode?: true
    notes?: true
    tagsString?: true
    source?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    email: string | null
    phone: string | null
    firstName: string | null
    lastName: string | null
    company: string | null
    jobTitle: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    postalCode: string | null
    notes: string | null
    tagsString: string | null
    source: string | null
    status: $Enums.ContactStatus
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    company?: boolean
    jobTitle?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postalCode?: boolean
    notes?: boolean
    tagsString?: boolean
    source?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    listMembers?: boolean | Contact$listMembersArgs<ExtArgs>
    emailActivities?: boolean | Contact$emailActivitiesArgs<ExtArgs>
    smsActivities?: boolean | Contact$smsActivitiesArgs<ExtArgs>
    waActivities?: boolean | Contact$waActivitiesArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    company?: boolean
    jobTitle?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postalCode?: boolean
    notes?: boolean
    tagsString?: boolean
    source?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    company?: boolean
    jobTitle?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postalCode?: boolean
    notes?: boolean
    tagsString?: boolean
    source?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    email?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    company?: boolean
    jobTitle?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postalCode?: boolean
    notes?: boolean
    tagsString?: boolean
    source?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "phone" | "firstName" | "lastName" | "company" | "jobTitle" | "address" | "city" | "state" | "country" | "postalCode" | "notes" | "tagsString" | "source" | "status" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    listMembers?: boolean | Contact$listMembersArgs<ExtArgs>
    emailActivities?: boolean | Contact$emailActivitiesArgs<ExtArgs>
    smsActivities?: boolean | Contact$smsActivitiesArgs<ExtArgs>
    waActivities?: boolean | Contact$waActivitiesArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      listMembers: Prisma.$ListMemberPayload<ExtArgs>[]
      emailActivities: Prisma.$EmailActivityPayload<ExtArgs>[]
      smsActivities: Prisma.$SMSActivityPayload<ExtArgs>[]
      waActivities: Prisma.$WhatsAppActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string | null
      phone: string | null
      firstName: string | null
      lastName: string | null
      company: string | null
      jobTitle: string | null
      address: string | null
      city: string | null
      state: string | null
      country: string | null
      postalCode: string | null
      notes: string | null
      tagsString: string | null
      source: string | null
      status: $Enums.ContactStatus
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    listMembers<T extends Contact$listMembersArgs<ExtArgs> = {}>(args?: Subset<T, Contact$listMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailActivities<T extends Contact$emailActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$emailActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    smsActivities<T extends Contact$smsActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$smsActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMSActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    waActivities<T extends Contact$waActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$waActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly phone: FieldRef<"Contact", 'String'>
    readonly firstName: FieldRef<"Contact", 'String'>
    readonly lastName: FieldRef<"Contact", 'String'>
    readonly company: FieldRef<"Contact", 'String'>
    readonly jobTitle: FieldRef<"Contact", 'String'>
    readonly address: FieldRef<"Contact", 'String'>
    readonly city: FieldRef<"Contact", 'String'>
    readonly state: FieldRef<"Contact", 'String'>
    readonly country: FieldRef<"Contact", 'String'>
    readonly postalCode: FieldRef<"Contact", 'String'>
    readonly notes: FieldRef<"Contact", 'String'>
    readonly tagsString: FieldRef<"Contact", 'String'>
    readonly source: FieldRef<"Contact", 'String'>
    readonly status: FieldRef<"Contact", 'ContactStatus'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
    readonly createdById: FieldRef<"Contact", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact updateManyAndReturn
   */
  export type ContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact.listMembers
   */
  export type Contact$listMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListMember
     */
    select?: ListMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListMember
     */
    omit?: ListMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListMemberInclude<ExtArgs> | null
    where?: ListMemberWhereInput
    orderBy?: ListMemberOrderByWithRelationInput | ListMemberOrderByWithRelationInput[]
    cursor?: ListMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListMemberScalarFieldEnum | ListMemberScalarFieldEnum[]
  }

  /**
   * Contact.emailActivities
   */
  export type Contact$emailActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActivity
     */
    select?: EmailActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActivity
     */
    omit?: EmailActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActivityInclude<ExtArgs> | null
    where?: EmailActivityWhereInput
    orderBy?: EmailActivityOrderByWithRelationInput | EmailActivityOrderByWithRelationInput[]
    cursor?: EmailActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailActivityScalarFieldEnum | EmailActivityScalarFieldEnum[]
  }

  /**
   * Contact.smsActivities
   */
  export type Contact$smsActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSActivity
     */
    select?: SMSActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSActivity
     */
    omit?: SMSActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSActivityInclude<ExtArgs> | null
    where?: SMSActivityWhereInput
    orderBy?: SMSActivityOrderByWithRelationInput | SMSActivityOrderByWithRelationInput[]
    cursor?: SMSActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SMSActivityScalarFieldEnum | SMSActivityScalarFieldEnum[]
  }

  /**
   * Contact.waActivities
   */
  export type Contact$waActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppActivity
     */
    select?: WhatsAppActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppActivity
     */
    omit?: WhatsAppActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppActivityInclude<ExtArgs> | null
    where?: WhatsAppActivityWhereInput
    orderBy?: WhatsAppActivityOrderByWithRelationInput | WhatsAppActivityOrderByWithRelationInput[]
    cursor?: WhatsAppActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppActivityScalarFieldEnum | WhatsAppActivityScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model List
   */

  export type AggregateList = {
    _count: ListCountAggregateOutputType | null
    _min: ListMinAggregateOutputType | null
    _max: ListMaxAggregateOutputType | null
  }

  export type ListMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.ListType | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type ListMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.ListType | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type ListCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type ListMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type ListMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type ListCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type ListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which List to aggregate.
     */
    where?: ListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lists to fetch.
     */
    orderBy?: ListOrderByWithRelationInput | ListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lists
    **/
    _count?: true | ListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListMaxAggregateInputType
  }

  export type GetListAggregateType<T extends ListAggregateArgs> = {
        [P in keyof T & keyof AggregateList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateList[P]>
      : GetScalarType<T[P], AggregateList[P]>
  }




  export type ListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListWhereInput
    orderBy?: ListOrderByWithAggregationInput | ListOrderByWithAggregationInput[]
    by: ListScalarFieldEnum[] | ListScalarFieldEnum
    having?: ListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListCountAggregateInputType | true
    _min?: ListMinAggregateInputType
    _max?: ListMaxAggregateInputType
  }

  export type ListGroupByOutputType = {
    id: string
    name: string
    description: string | null
    type: $Enums.ListType
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: ListCountAggregateOutputType | null
    _min: ListMinAggregateOutputType | null
    _max: ListMaxAggregateOutputType | null
  }

  type GetListGroupByPayload<T extends ListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListGroupByOutputType[P]>
            : GetScalarType<T[P], ListGroupByOutputType[P]>
        }
      >
    >


  export type ListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | List$membersArgs<ExtArgs>
    emailCampaigns?: boolean | List$emailCampaignsArgs<ExtArgs>
    smsCampaigns?: boolean | List$smsCampaignsArgs<ExtArgs>
    waCampaigns?: boolean | List$waCampaignsArgs<ExtArgs>
    _count?: boolean | ListCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["list"]>

  export type ListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["list"]>

  export type ListSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["list"]>

  export type ListSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type ListOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["list"]>
  export type ListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | List$membersArgs<ExtArgs>
    emailCampaigns?: boolean | List$emailCampaignsArgs<ExtArgs>
    smsCampaigns?: boolean | List$smsCampaignsArgs<ExtArgs>
    waCampaigns?: boolean | List$waCampaignsArgs<ExtArgs>
    _count?: boolean | ListCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ListIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "List"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$ListMemberPayload<ExtArgs>[]
      emailCampaigns: Prisma.$EmailCampaignPayload<ExtArgs>[]
      smsCampaigns: Prisma.$SMSCampaignPayload<ExtArgs>[]
      waCampaigns: Prisma.$WhatsAppCampaignPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      type: $Enums.ListType
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["list"]>
    composites: {}
  }

  type ListGetPayload<S extends boolean | null | undefined | ListDefaultArgs> = $Result.GetResult<Prisma.$ListPayload, S>

  type ListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ListFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ListCountAggregateInputType | true
    }

  export interface ListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['List'], meta: { name: 'List' } }
    /**
     * Find zero or one List that matches the filter.
     * @param {ListFindUniqueArgs} args - Arguments to find a List
     * @example
     * // Get one List
     * const list = await prisma.list.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ListFindUniqueArgs>(args: SelectSubset<T, ListFindUniqueArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one List that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ListFindUniqueOrThrowArgs} args - Arguments to find a List
     * @example
     * // Get one List
     * const list = await prisma.list.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ListFindUniqueOrThrowArgs>(args: SelectSubset<T, ListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first List that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListFindFirstArgs} args - Arguments to find a List
     * @example
     * // Get one List
     * const list = await prisma.list.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ListFindFirstArgs>(args?: SelectSubset<T, ListFindFirstArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first List that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListFindFirstOrThrowArgs} args - Arguments to find a List
     * @example
     * // Get one List
     * const list = await prisma.list.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ListFindFirstOrThrowArgs>(args?: SelectSubset<T, ListFindFirstOrThrowArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lists
     * const lists = await prisma.list.findMany()
     * 
     * // Get first 10 Lists
     * const lists = await prisma.list.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listWithIdOnly = await prisma.list.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ListFindManyArgs>(args?: SelectSubset<T, ListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a List.
     * @param {ListCreateArgs} args - Arguments to create a List.
     * @example
     * // Create one List
     * const List = await prisma.list.create({
     *   data: {
     *     // ... data to create a List
     *   }
     * })
     * 
     */
    create<T extends ListCreateArgs>(args: SelectSubset<T, ListCreateArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lists.
     * @param {ListCreateManyArgs} args - Arguments to create many Lists.
     * @example
     * // Create many Lists
     * const list = await prisma.list.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ListCreateManyArgs>(args?: SelectSubset<T, ListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lists and returns the data saved in the database.
     * @param {ListCreateManyAndReturnArgs} args - Arguments to create many Lists.
     * @example
     * // Create many Lists
     * const list = await prisma.list.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lists and only return the `id`
     * const listWithIdOnly = await prisma.list.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ListCreateManyAndReturnArgs>(args?: SelectSubset<T, ListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a List.
     * @param {ListDeleteArgs} args - Arguments to delete one List.
     * @example
     * // Delete one List
     * const List = await prisma.list.delete({
     *   where: {
     *     // ... filter to delete one List
     *   }
     * })
     * 
     */
    delete<T extends ListDeleteArgs>(args: SelectSubset<T, ListDeleteArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one List.
     * @param {ListUpdateArgs} args - Arguments to update one List.
     * @example
     * // Update one List
     * const list = await prisma.list.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ListUpdateArgs>(args: SelectSubset<T, ListUpdateArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lists.
     * @param {ListDeleteManyArgs} args - Arguments to filter Lists to delete.
     * @example
     * // Delete a few Lists
     * const { count } = await prisma.list.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ListDeleteManyArgs>(args?: SelectSubset<T, ListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lists
     * const list = await prisma.list.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ListUpdateManyArgs>(args: SelectSubset<T, ListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lists and returns the data updated in the database.
     * @param {ListUpdateManyAndReturnArgs} args - Arguments to update many Lists.
     * @example
     * // Update many Lists
     * const list = await prisma.list.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lists and only return the `id`
     * const listWithIdOnly = await prisma.list.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ListUpdateManyAndReturnArgs>(args: SelectSubset<T, ListUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one List.
     * @param {ListUpsertArgs} args - Arguments to update or create a List.
     * @example
     * // Update or create a List
     * const list = await prisma.list.upsert({
     *   create: {
     *     // ... data to create a List
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the List we want to update
     *   }
     * })
     */
    upsert<T extends ListUpsertArgs>(args: SelectSubset<T, ListUpsertArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListCountArgs} args - Arguments to filter Lists to count.
     * @example
     * // Count the number of Lists
     * const count = await prisma.list.count({
     *   where: {
     *     // ... the filter for the Lists we want to count
     *   }
     * })
    **/
    count<T extends ListCountArgs>(
      args?: Subset<T, ListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a List.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListAggregateArgs>(args: Subset<T, ListAggregateArgs>): Prisma.PrismaPromise<GetListAggregateType<T>>

    /**
     * Group by List.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListGroupByArgs['orderBy'] }
        : { orderBy?: ListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the List model
   */
  readonly fields: ListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for List.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends List$membersArgs<ExtArgs> = {}>(args?: Subset<T, List$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailCampaigns<T extends List$emailCampaignsArgs<ExtArgs> = {}>(args?: Subset<T, List$emailCampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    smsCampaigns<T extends List$smsCampaignsArgs<ExtArgs> = {}>(args?: Subset<T, List$smsCampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMSCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    waCampaigns<T extends List$waCampaignsArgs<ExtArgs> = {}>(args?: Subset<T, List$waCampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the List model
   */
  interface ListFieldRefs {
    readonly id: FieldRef<"List", 'String'>
    readonly name: FieldRef<"List", 'String'>
    readonly description: FieldRef<"List", 'String'>
    readonly type: FieldRef<"List", 'ListType'>
    readonly createdAt: FieldRef<"List", 'DateTime'>
    readonly updatedAt: FieldRef<"List", 'DateTime'>
    readonly createdById: FieldRef<"List", 'String'>
  }
    

  // Custom InputTypes
  /**
   * List findUnique
   */
  export type ListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * Filter, which List to fetch.
     */
    where: ListWhereUniqueInput
  }

  /**
   * List findUniqueOrThrow
   */
  export type ListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * Filter, which List to fetch.
     */
    where: ListWhereUniqueInput
  }

  /**
   * List findFirst
   */
  export type ListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * Filter, which List to fetch.
     */
    where?: ListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lists to fetch.
     */
    orderBy?: ListOrderByWithRelationInput | ListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lists.
     */
    cursor?: ListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lists.
     */
    distinct?: ListScalarFieldEnum | ListScalarFieldEnum[]
  }

  /**
   * List findFirstOrThrow
   */
  export type ListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * Filter, which List to fetch.
     */
    where?: ListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lists to fetch.
     */
    orderBy?: ListOrderByWithRelationInput | ListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lists.
     */
    cursor?: ListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lists.
     */
    distinct?: ListScalarFieldEnum | ListScalarFieldEnum[]
  }

  /**
   * List findMany
   */
  export type ListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * Filter, which Lists to fetch.
     */
    where?: ListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lists to fetch.
     */
    orderBy?: ListOrderByWithRelationInput | ListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lists.
     */
    cursor?: ListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lists.
     */
    skip?: number
    distinct?: ListScalarFieldEnum | ListScalarFieldEnum[]
  }

  /**
   * List create
   */
  export type ListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * The data needed to create a List.
     */
    data: XOR<ListCreateInput, ListUncheckedCreateInput>
  }

  /**
   * List createMany
   */
  export type ListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lists.
     */
    data: ListCreateManyInput | ListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * List createManyAndReturn
   */
  export type ListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * The data used to create many Lists.
     */
    data: ListCreateManyInput | ListCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * List update
   */
  export type ListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * The data needed to update a List.
     */
    data: XOR<ListUpdateInput, ListUncheckedUpdateInput>
    /**
     * Choose, which List to update.
     */
    where: ListWhereUniqueInput
  }

  /**
   * List updateMany
   */
  export type ListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lists.
     */
    data: XOR<ListUpdateManyMutationInput, ListUncheckedUpdateManyInput>
    /**
     * Filter which Lists to update
     */
    where?: ListWhereInput
    /**
     * Limit how many Lists to update.
     */
    limit?: number
  }

  /**
   * List updateManyAndReturn
   */
  export type ListUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * The data used to update Lists.
     */
    data: XOR<ListUpdateManyMutationInput, ListUncheckedUpdateManyInput>
    /**
     * Filter which Lists to update
     */
    where?: ListWhereInput
    /**
     * Limit how many Lists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * List upsert
   */
  export type ListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * The filter to search for the List to update in case it exists.
     */
    where: ListWhereUniqueInput
    /**
     * In case the List found by the `where` argument doesn't exist, create a new List with this data.
     */
    create: XOR<ListCreateInput, ListUncheckedCreateInput>
    /**
     * In case the List was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListUpdateInput, ListUncheckedUpdateInput>
  }

  /**
   * List delete
   */
  export type ListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * Filter which List to delete.
     */
    where: ListWhereUniqueInput
  }

  /**
   * List deleteMany
   */
  export type ListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lists to delete
     */
    where?: ListWhereInput
    /**
     * Limit how many Lists to delete.
     */
    limit?: number
  }

  /**
   * List.members
   */
  export type List$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListMember
     */
    select?: ListMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListMember
     */
    omit?: ListMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListMemberInclude<ExtArgs> | null
    where?: ListMemberWhereInput
    orderBy?: ListMemberOrderByWithRelationInput | ListMemberOrderByWithRelationInput[]
    cursor?: ListMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListMemberScalarFieldEnum | ListMemberScalarFieldEnum[]
  }

  /**
   * List.emailCampaigns
   */
  export type List$emailCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
    where?: EmailCampaignWhereInput
    orderBy?: EmailCampaignOrderByWithRelationInput | EmailCampaignOrderByWithRelationInput[]
    cursor?: EmailCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailCampaignScalarFieldEnum | EmailCampaignScalarFieldEnum[]
  }

  /**
   * List.smsCampaigns
   */
  export type List$smsCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSCampaign
     */
    select?: SMSCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSCampaign
     */
    omit?: SMSCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSCampaignInclude<ExtArgs> | null
    where?: SMSCampaignWhereInput
    orderBy?: SMSCampaignOrderByWithRelationInput | SMSCampaignOrderByWithRelationInput[]
    cursor?: SMSCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SMSCampaignScalarFieldEnum | SMSCampaignScalarFieldEnum[]
  }

  /**
   * List.waCampaigns
   */
  export type List$waCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
    where?: WhatsAppCampaignWhereInput
    orderBy?: WhatsAppCampaignOrderByWithRelationInput | WhatsAppCampaignOrderByWithRelationInput[]
    cursor?: WhatsAppCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppCampaignScalarFieldEnum | WhatsAppCampaignScalarFieldEnum[]
  }

  /**
   * List without action
   */
  export type ListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
  }


  /**
   * Model ListMember
   */

  export type AggregateListMember = {
    _count: ListMemberCountAggregateOutputType | null
    _min: ListMemberMinAggregateOutputType | null
    _max: ListMemberMaxAggregateOutputType | null
  }

  export type ListMemberMinAggregateOutputType = {
    id: string | null
    listId: string | null
    contactId: string | null
    addedAt: Date | null
  }

  export type ListMemberMaxAggregateOutputType = {
    id: string | null
    listId: string | null
    contactId: string | null
    addedAt: Date | null
  }

  export type ListMemberCountAggregateOutputType = {
    id: number
    listId: number
    contactId: number
    addedAt: number
    _all: number
  }


  export type ListMemberMinAggregateInputType = {
    id?: true
    listId?: true
    contactId?: true
    addedAt?: true
  }

  export type ListMemberMaxAggregateInputType = {
    id?: true
    listId?: true
    contactId?: true
    addedAt?: true
  }

  export type ListMemberCountAggregateInputType = {
    id?: true
    listId?: true
    contactId?: true
    addedAt?: true
    _all?: true
  }

  export type ListMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListMember to aggregate.
     */
    where?: ListMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListMembers to fetch.
     */
    orderBy?: ListMemberOrderByWithRelationInput | ListMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ListMembers
    **/
    _count?: true | ListMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListMemberMaxAggregateInputType
  }

  export type GetListMemberAggregateType<T extends ListMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateListMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateListMember[P]>
      : GetScalarType<T[P], AggregateListMember[P]>
  }




  export type ListMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListMemberWhereInput
    orderBy?: ListMemberOrderByWithAggregationInput | ListMemberOrderByWithAggregationInput[]
    by: ListMemberScalarFieldEnum[] | ListMemberScalarFieldEnum
    having?: ListMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListMemberCountAggregateInputType | true
    _min?: ListMemberMinAggregateInputType
    _max?: ListMemberMaxAggregateInputType
  }

  export type ListMemberGroupByOutputType = {
    id: string
    listId: string
    contactId: string
    addedAt: Date
    _count: ListMemberCountAggregateOutputType | null
    _min: ListMemberMinAggregateOutputType | null
    _max: ListMemberMaxAggregateOutputType | null
  }

  type GetListMemberGroupByPayload<T extends ListMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ListMemberGroupByOutputType[P]>
        }
      >
    >


  export type ListMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listId?: boolean
    contactId?: boolean
    addedAt?: boolean
    list?: boolean | ListDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listMember"]>

  export type ListMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listId?: boolean
    contactId?: boolean
    addedAt?: boolean
    list?: boolean | ListDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listMember"]>

  export type ListMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listId?: boolean
    contactId?: boolean
    addedAt?: boolean
    list?: boolean | ListDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listMember"]>

  export type ListMemberSelectScalar = {
    id?: boolean
    listId?: boolean
    contactId?: boolean
    addedAt?: boolean
  }

  export type ListMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "listId" | "contactId" | "addedAt", ExtArgs["result"]["listMember"]>
  export type ListMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    list?: boolean | ListDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }
  export type ListMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    list?: boolean | ListDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }
  export type ListMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    list?: boolean | ListDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }

  export type $ListMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ListMember"
    objects: {
      list: Prisma.$ListPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      listId: string
      contactId: string
      addedAt: Date
    }, ExtArgs["result"]["listMember"]>
    composites: {}
  }

  type ListMemberGetPayload<S extends boolean | null | undefined | ListMemberDefaultArgs> = $Result.GetResult<Prisma.$ListMemberPayload, S>

  type ListMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ListMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ListMemberCountAggregateInputType | true
    }

  export interface ListMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ListMember'], meta: { name: 'ListMember' } }
    /**
     * Find zero or one ListMember that matches the filter.
     * @param {ListMemberFindUniqueArgs} args - Arguments to find a ListMember
     * @example
     * // Get one ListMember
     * const listMember = await prisma.listMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ListMemberFindUniqueArgs>(args: SelectSubset<T, ListMemberFindUniqueArgs<ExtArgs>>): Prisma__ListMemberClient<$Result.GetResult<Prisma.$ListMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ListMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ListMemberFindUniqueOrThrowArgs} args - Arguments to find a ListMember
     * @example
     * // Get one ListMember
     * const listMember = await prisma.listMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ListMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ListMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ListMemberClient<$Result.GetResult<Prisma.$ListMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ListMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListMemberFindFirstArgs} args - Arguments to find a ListMember
     * @example
     * // Get one ListMember
     * const listMember = await prisma.listMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ListMemberFindFirstArgs>(args?: SelectSubset<T, ListMemberFindFirstArgs<ExtArgs>>): Prisma__ListMemberClient<$Result.GetResult<Prisma.$ListMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ListMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListMemberFindFirstOrThrowArgs} args - Arguments to find a ListMember
     * @example
     * // Get one ListMember
     * const listMember = await prisma.listMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ListMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ListMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ListMemberClient<$Result.GetResult<Prisma.$ListMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ListMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ListMembers
     * const listMembers = await prisma.listMember.findMany()
     * 
     * // Get first 10 ListMembers
     * const listMembers = await prisma.listMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listMemberWithIdOnly = await prisma.listMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ListMemberFindManyArgs>(args?: SelectSubset<T, ListMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ListMember.
     * @param {ListMemberCreateArgs} args - Arguments to create a ListMember.
     * @example
     * // Create one ListMember
     * const ListMember = await prisma.listMember.create({
     *   data: {
     *     // ... data to create a ListMember
     *   }
     * })
     * 
     */
    create<T extends ListMemberCreateArgs>(args: SelectSubset<T, ListMemberCreateArgs<ExtArgs>>): Prisma__ListMemberClient<$Result.GetResult<Prisma.$ListMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ListMembers.
     * @param {ListMemberCreateManyArgs} args - Arguments to create many ListMembers.
     * @example
     * // Create many ListMembers
     * const listMember = await prisma.listMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ListMemberCreateManyArgs>(args?: SelectSubset<T, ListMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ListMembers and returns the data saved in the database.
     * @param {ListMemberCreateManyAndReturnArgs} args - Arguments to create many ListMembers.
     * @example
     * // Create many ListMembers
     * const listMember = await prisma.listMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ListMembers and only return the `id`
     * const listMemberWithIdOnly = await prisma.listMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ListMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ListMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ListMember.
     * @param {ListMemberDeleteArgs} args - Arguments to delete one ListMember.
     * @example
     * // Delete one ListMember
     * const ListMember = await prisma.listMember.delete({
     *   where: {
     *     // ... filter to delete one ListMember
     *   }
     * })
     * 
     */
    delete<T extends ListMemberDeleteArgs>(args: SelectSubset<T, ListMemberDeleteArgs<ExtArgs>>): Prisma__ListMemberClient<$Result.GetResult<Prisma.$ListMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ListMember.
     * @param {ListMemberUpdateArgs} args - Arguments to update one ListMember.
     * @example
     * // Update one ListMember
     * const listMember = await prisma.listMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ListMemberUpdateArgs>(args: SelectSubset<T, ListMemberUpdateArgs<ExtArgs>>): Prisma__ListMemberClient<$Result.GetResult<Prisma.$ListMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ListMembers.
     * @param {ListMemberDeleteManyArgs} args - Arguments to filter ListMembers to delete.
     * @example
     * // Delete a few ListMembers
     * const { count } = await prisma.listMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ListMemberDeleteManyArgs>(args?: SelectSubset<T, ListMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ListMembers
     * const listMember = await prisma.listMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ListMemberUpdateManyArgs>(args: SelectSubset<T, ListMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListMembers and returns the data updated in the database.
     * @param {ListMemberUpdateManyAndReturnArgs} args - Arguments to update many ListMembers.
     * @example
     * // Update many ListMembers
     * const listMember = await prisma.listMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ListMembers and only return the `id`
     * const listMemberWithIdOnly = await prisma.listMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ListMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, ListMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ListMember.
     * @param {ListMemberUpsertArgs} args - Arguments to update or create a ListMember.
     * @example
     * // Update or create a ListMember
     * const listMember = await prisma.listMember.upsert({
     *   create: {
     *     // ... data to create a ListMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ListMember we want to update
     *   }
     * })
     */
    upsert<T extends ListMemberUpsertArgs>(args: SelectSubset<T, ListMemberUpsertArgs<ExtArgs>>): Prisma__ListMemberClient<$Result.GetResult<Prisma.$ListMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ListMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListMemberCountArgs} args - Arguments to filter ListMembers to count.
     * @example
     * // Count the number of ListMembers
     * const count = await prisma.listMember.count({
     *   where: {
     *     // ... the filter for the ListMembers we want to count
     *   }
     * })
    **/
    count<T extends ListMemberCountArgs>(
      args?: Subset<T, ListMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ListMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListMemberAggregateArgs>(args: Subset<T, ListMemberAggregateArgs>): Prisma.PrismaPromise<GetListMemberAggregateType<T>>

    /**
     * Group by ListMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListMemberGroupByArgs['orderBy'] }
        : { orderBy?: ListMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ListMember model
   */
  readonly fields: ListMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ListMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ListMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    list<T extends ListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ListDefaultArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ListMember model
   */
  interface ListMemberFieldRefs {
    readonly id: FieldRef<"ListMember", 'String'>
    readonly listId: FieldRef<"ListMember", 'String'>
    readonly contactId: FieldRef<"ListMember", 'String'>
    readonly addedAt: FieldRef<"ListMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ListMember findUnique
   */
  export type ListMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListMember
     */
    select?: ListMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListMember
     */
    omit?: ListMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListMemberInclude<ExtArgs> | null
    /**
     * Filter, which ListMember to fetch.
     */
    where: ListMemberWhereUniqueInput
  }

  /**
   * ListMember findUniqueOrThrow
   */
  export type ListMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListMember
     */
    select?: ListMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListMember
     */
    omit?: ListMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListMemberInclude<ExtArgs> | null
    /**
     * Filter, which ListMember to fetch.
     */
    where: ListMemberWhereUniqueInput
  }

  /**
   * ListMember findFirst
   */
  export type ListMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListMember
     */
    select?: ListMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListMember
     */
    omit?: ListMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListMemberInclude<ExtArgs> | null
    /**
     * Filter, which ListMember to fetch.
     */
    where?: ListMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListMembers to fetch.
     */
    orderBy?: ListMemberOrderByWithRelationInput | ListMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListMembers.
     */
    cursor?: ListMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListMembers.
     */
    distinct?: ListMemberScalarFieldEnum | ListMemberScalarFieldEnum[]
  }

  /**
   * ListMember findFirstOrThrow
   */
  export type ListMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListMember
     */
    select?: ListMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListMember
     */
    omit?: ListMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListMemberInclude<ExtArgs> | null
    /**
     * Filter, which ListMember to fetch.
     */
    where?: ListMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListMembers to fetch.
     */
    orderBy?: ListMemberOrderByWithRelationInput | ListMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListMembers.
     */
    cursor?: ListMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListMembers.
     */
    distinct?: ListMemberScalarFieldEnum | ListMemberScalarFieldEnum[]
  }

  /**
   * ListMember findMany
   */
  export type ListMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListMember
     */
    select?: ListMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListMember
     */
    omit?: ListMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListMemberInclude<ExtArgs> | null
    /**
     * Filter, which ListMembers to fetch.
     */
    where?: ListMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListMembers to fetch.
     */
    orderBy?: ListMemberOrderByWithRelationInput | ListMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ListMembers.
     */
    cursor?: ListMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListMembers.
     */
    skip?: number
    distinct?: ListMemberScalarFieldEnum | ListMemberScalarFieldEnum[]
  }

  /**
   * ListMember create
   */
  export type ListMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListMember
     */
    select?: ListMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListMember
     */
    omit?: ListMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ListMember.
     */
    data: XOR<ListMemberCreateInput, ListMemberUncheckedCreateInput>
  }

  /**
   * ListMember createMany
   */
  export type ListMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ListMembers.
     */
    data: ListMemberCreateManyInput | ListMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ListMember createManyAndReturn
   */
  export type ListMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListMember
     */
    select?: ListMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ListMember
     */
    omit?: ListMemberOmit<ExtArgs> | null
    /**
     * The data used to create many ListMembers.
     */
    data: ListMemberCreateManyInput | ListMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ListMember update
   */
  export type ListMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListMember
     */
    select?: ListMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListMember
     */
    omit?: ListMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ListMember.
     */
    data: XOR<ListMemberUpdateInput, ListMemberUncheckedUpdateInput>
    /**
     * Choose, which ListMember to update.
     */
    where: ListMemberWhereUniqueInput
  }

  /**
   * ListMember updateMany
   */
  export type ListMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ListMembers.
     */
    data: XOR<ListMemberUpdateManyMutationInput, ListMemberUncheckedUpdateManyInput>
    /**
     * Filter which ListMembers to update
     */
    where?: ListMemberWhereInput
    /**
     * Limit how many ListMembers to update.
     */
    limit?: number
  }

  /**
   * ListMember updateManyAndReturn
   */
  export type ListMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListMember
     */
    select?: ListMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ListMember
     */
    omit?: ListMemberOmit<ExtArgs> | null
    /**
     * The data used to update ListMembers.
     */
    data: XOR<ListMemberUpdateManyMutationInput, ListMemberUncheckedUpdateManyInput>
    /**
     * Filter which ListMembers to update
     */
    where?: ListMemberWhereInput
    /**
     * Limit how many ListMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ListMember upsert
   */
  export type ListMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListMember
     */
    select?: ListMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListMember
     */
    omit?: ListMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ListMember to update in case it exists.
     */
    where: ListMemberWhereUniqueInput
    /**
     * In case the ListMember found by the `where` argument doesn't exist, create a new ListMember with this data.
     */
    create: XOR<ListMemberCreateInput, ListMemberUncheckedCreateInput>
    /**
     * In case the ListMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListMemberUpdateInput, ListMemberUncheckedUpdateInput>
  }

  /**
   * ListMember delete
   */
  export type ListMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListMember
     */
    select?: ListMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListMember
     */
    omit?: ListMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListMemberInclude<ExtArgs> | null
    /**
     * Filter which ListMember to delete.
     */
    where: ListMemberWhereUniqueInput
  }

  /**
   * ListMember deleteMany
   */
  export type ListMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListMembers to delete
     */
    where?: ListMemberWhereInput
    /**
     * Limit how many ListMembers to delete.
     */
    limit?: number
  }

  /**
   * ListMember without action
   */
  export type ListMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListMember
     */
    select?: ListMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListMember
     */
    omit?: ListMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListMemberInclude<ExtArgs> | null
  }


  /**
   * Model Segment
   */

  export type AggregateSegment = {
    _count: SegmentCountAggregateOutputType | null
    _min: SegmentMinAggregateOutputType | null
    _max: SegmentMaxAggregateOutputType | null
  }

  export type SegmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    rules: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type SegmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    rules: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type SegmentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    rules: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type SegmentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    rules?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type SegmentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    rules?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type SegmentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    rules?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type SegmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Segment to aggregate.
     */
    where?: SegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Segments to fetch.
     */
    orderBy?: SegmentOrderByWithRelationInput | SegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Segments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Segments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Segments
    **/
    _count?: true | SegmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SegmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SegmentMaxAggregateInputType
  }

  export type GetSegmentAggregateType<T extends SegmentAggregateArgs> = {
        [P in keyof T & keyof AggregateSegment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSegment[P]>
      : GetScalarType<T[P], AggregateSegment[P]>
  }




  export type SegmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SegmentWhereInput
    orderBy?: SegmentOrderByWithAggregationInput | SegmentOrderByWithAggregationInput[]
    by: SegmentScalarFieldEnum[] | SegmentScalarFieldEnum
    having?: SegmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SegmentCountAggregateInputType | true
    _min?: SegmentMinAggregateInputType
    _max?: SegmentMaxAggregateInputType
  }

  export type SegmentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    rules: string
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: SegmentCountAggregateOutputType | null
    _min: SegmentMinAggregateOutputType | null
    _max: SegmentMaxAggregateOutputType | null
  }

  type GetSegmentGroupByPayload<T extends SegmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SegmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SegmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SegmentGroupByOutputType[P]>
            : GetScalarType<T[P], SegmentGroupByOutputType[P]>
        }
      >
    >


  export type SegmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    rules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    emailCampaigns?: boolean | Segment$emailCampaignsArgs<ExtArgs>
    smsCampaigns?: boolean | Segment$smsCampaignsArgs<ExtArgs>
    waCampaigns?: boolean | Segment$waCampaignsArgs<ExtArgs>
    _count?: boolean | SegmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["segment"]>

  export type SegmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    rules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["segment"]>

  export type SegmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    rules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["segment"]>

  export type SegmentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    rules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type SegmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "rules" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["segment"]>
  export type SegmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    emailCampaigns?: boolean | Segment$emailCampaignsArgs<ExtArgs>
    smsCampaigns?: boolean | Segment$smsCampaignsArgs<ExtArgs>
    waCampaigns?: boolean | Segment$waCampaignsArgs<ExtArgs>
    _count?: boolean | SegmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SegmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SegmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SegmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Segment"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      emailCampaigns: Prisma.$EmailCampaignPayload<ExtArgs>[]
      smsCampaigns: Prisma.$SMSCampaignPayload<ExtArgs>[]
      waCampaigns: Prisma.$WhatsAppCampaignPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      rules: string
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["segment"]>
    composites: {}
  }

  type SegmentGetPayload<S extends boolean | null | undefined | SegmentDefaultArgs> = $Result.GetResult<Prisma.$SegmentPayload, S>

  type SegmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SegmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SegmentCountAggregateInputType | true
    }

  export interface SegmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Segment'], meta: { name: 'Segment' } }
    /**
     * Find zero or one Segment that matches the filter.
     * @param {SegmentFindUniqueArgs} args - Arguments to find a Segment
     * @example
     * // Get one Segment
     * const segment = await prisma.segment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SegmentFindUniqueArgs>(args: SelectSubset<T, SegmentFindUniqueArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Segment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SegmentFindUniqueOrThrowArgs} args - Arguments to find a Segment
     * @example
     * // Get one Segment
     * const segment = await prisma.segment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SegmentFindUniqueOrThrowArgs>(args: SelectSubset<T, SegmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Segment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentFindFirstArgs} args - Arguments to find a Segment
     * @example
     * // Get one Segment
     * const segment = await prisma.segment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SegmentFindFirstArgs>(args?: SelectSubset<T, SegmentFindFirstArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Segment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentFindFirstOrThrowArgs} args - Arguments to find a Segment
     * @example
     * // Get one Segment
     * const segment = await prisma.segment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SegmentFindFirstOrThrowArgs>(args?: SelectSubset<T, SegmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Segments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Segments
     * const segments = await prisma.segment.findMany()
     * 
     * // Get first 10 Segments
     * const segments = await prisma.segment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const segmentWithIdOnly = await prisma.segment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SegmentFindManyArgs>(args?: SelectSubset<T, SegmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Segment.
     * @param {SegmentCreateArgs} args - Arguments to create a Segment.
     * @example
     * // Create one Segment
     * const Segment = await prisma.segment.create({
     *   data: {
     *     // ... data to create a Segment
     *   }
     * })
     * 
     */
    create<T extends SegmentCreateArgs>(args: SelectSubset<T, SegmentCreateArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Segments.
     * @param {SegmentCreateManyArgs} args - Arguments to create many Segments.
     * @example
     * // Create many Segments
     * const segment = await prisma.segment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SegmentCreateManyArgs>(args?: SelectSubset<T, SegmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Segments and returns the data saved in the database.
     * @param {SegmentCreateManyAndReturnArgs} args - Arguments to create many Segments.
     * @example
     * // Create many Segments
     * const segment = await prisma.segment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Segments and only return the `id`
     * const segmentWithIdOnly = await prisma.segment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SegmentCreateManyAndReturnArgs>(args?: SelectSubset<T, SegmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Segment.
     * @param {SegmentDeleteArgs} args - Arguments to delete one Segment.
     * @example
     * // Delete one Segment
     * const Segment = await prisma.segment.delete({
     *   where: {
     *     // ... filter to delete one Segment
     *   }
     * })
     * 
     */
    delete<T extends SegmentDeleteArgs>(args: SelectSubset<T, SegmentDeleteArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Segment.
     * @param {SegmentUpdateArgs} args - Arguments to update one Segment.
     * @example
     * // Update one Segment
     * const segment = await prisma.segment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SegmentUpdateArgs>(args: SelectSubset<T, SegmentUpdateArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Segments.
     * @param {SegmentDeleteManyArgs} args - Arguments to filter Segments to delete.
     * @example
     * // Delete a few Segments
     * const { count } = await prisma.segment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SegmentDeleteManyArgs>(args?: SelectSubset<T, SegmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Segments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Segments
     * const segment = await prisma.segment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SegmentUpdateManyArgs>(args: SelectSubset<T, SegmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Segments and returns the data updated in the database.
     * @param {SegmentUpdateManyAndReturnArgs} args - Arguments to update many Segments.
     * @example
     * // Update many Segments
     * const segment = await prisma.segment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Segments and only return the `id`
     * const segmentWithIdOnly = await prisma.segment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SegmentUpdateManyAndReturnArgs>(args: SelectSubset<T, SegmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Segment.
     * @param {SegmentUpsertArgs} args - Arguments to update or create a Segment.
     * @example
     * // Update or create a Segment
     * const segment = await prisma.segment.upsert({
     *   create: {
     *     // ... data to create a Segment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Segment we want to update
     *   }
     * })
     */
    upsert<T extends SegmentUpsertArgs>(args: SelectSubset<T, SegmentUpsertArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Segments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentCountArgs} args - Arguments to filter Segments to count.
     * @example
     * // Count the number of Segments
     * const count = await prisma.segment.count({
     *   where: {
     *     // ... the filter for the Segments we want to count
     *   }
     * })
    **/
    count<T extends SegmentCountArgs>(
      args?: Subset<T, SegmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SegmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Segment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SegmentAggregateArgs>(args: Subset<T, SegmentAggregateArgs>): Prisma.PrismaPromise<GetSegmentAggregateType<T>>

    /**
     * Group by Segment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SegmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SegmentGroupByArgs['orderBy'] }
        : { orderBy?: SegmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SegmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSegmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Segment model
   */
  readonly fields: SegmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Segment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SegmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    emailCampaigns<T extends Segment$emailCampaignsArgs<ExtArgs> = {}>(args?: Subset<T, Segment$emailCampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    smsCampaigns<T extends Segment$smsCampaignsArgs<ExtArgs> = {}>(args?: Subset<T, Segment$smsCampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMSCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    waCampaigns<T extends Segment$waCampaignsArgs<ExtArgs> = {}>(args?: Subset<T, Segment$waCampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Segment model
   */
  interface SegmentFieldRefs {
    readonly id: FieldRef<"Segment", 'String'>
    readonly name: FieldRef<"Segment", 'String'>
    readonly description: FieldRef<"Segment", 'String'>
    readonly rules: FieldRef<"Segment", 'String'>
    readonly createdAt: FieldRef<"Segment", 'DateTime'>
    readonly updatedAt: FieldRef<"Segment", 'DateTime'>
    readonly createdById: FieldRef<"Segment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Segment findUnique
   */
  export type SegmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * Filter, which Segment to fetch.
     */
    where: SegmentWhereUniqueInput
  }

  /**
   * Segment findUniqueOrThrow
   */
  export type SegmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * Filter, which Segment to fetch.
     */
    where: SegmentWhereUniqueInput
  }

  /**
   * Segment findFirst
   */
  export type SegmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * Filter, which Segment to fetch.
     */
    where?: SegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Segments to fetch.
     */
    orderBy?: SegmentOrderByWithRelationInput | SegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Segments.
     */
    cursor?: SegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Segments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Segments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Segments.
     */
    distinct?: SegmentScalarFieldEnum | SegmentScalarFieldEnum[]
  }

  /**
   * Segment findFirstOrThrow
   */
  export type SegmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * Filter, which Segment to fetch.
     */
    where?: SegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Segments to fetch.
     */
    orderBy?: SegmentOrderByWithRelationInput | SegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Segments.
     */
    cursor?: SegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Segments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Segments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Segments.
     */
    distinct?: SegmentScalarFieldEnum | SegmentScalarFieldEnum[]
  }

  /**
   * Segment findMany
   */
  export type SegmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * Filter, which Segments to fetch.
     */
    where?: SegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Segments to fetch.
     */
    orderBy?: SegmentOrderByWithRelationInput | SegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Segments.
     */
    cursor?: SegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Segments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Segments.
     */
    skip?: number
    distinct?: SegmentScalarFieldEnum | SegmentScalarFieldEnum[]
  }

  /**
   * Segment create
   */
  export type SegmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Segment.
     */
    data: XOR<SegmentCreateInput, SegmentUncheckedCreateInput>
  }

  /**
   * Segment createMany
   */
  export type SegmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Segments.
     */
    data: SegmentCreateManyInput | SegmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Segment createManyAndReturn
   */
  export type SegmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * The data used to create many Segments.
     */
    data: SegmentCreateManyInput | SegmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Segment update
   */
  export type SegmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Segment.
     */
    data: XOR<SegmentUpdateInput, SegmentUncheckedUpdateInput>
    /**
     * Choose, which Segment to update.
     */
    where: SegmentWhereUniqueInput
  }

  /**
   * Segment updateMany
   */
  export type SegmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Segments.
     */
    data: XOR<SegmentUpdateManyMutationInput, SegmentUncheckedUpdateManyInput>
    /**
     * Filter which Segments to update
     */
    where?: SegmentWhereInput
    /**
     * Limit how many Segments to update.
     */
    limit?: number
  }

  /**
   * Segment updateManyAndReturn
   */
  export type SegmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * The data used to update Segments.
     */
    data: XOR<SegmentUpdateManyMutationInput, SegmentUncheckedUpdateManyInput>
    /**
     * Filter which Segments to update
     */
    where?: SegmentWhereInput
    /**
     * Limit how many Segments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Segment upsert
   */
  export type SegmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Segment to update in case it exists.
     */
    where: SegmentWhereUniqueInput
    /**
     * In case the Segment found by the `where` argument doesn't exist, create a new Segment with this data.
     */
    create: XOR<SegmentCreateInput, SegmentUncheckedCreateInput>
    /**
     * In case the Segment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SegmentUpdateInput, SegmentUncheckedUpdateInput>
  }

  /**
   * Segment delete
   */
  export type SegmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * Filter which Segment to delete.
     */
    where: SegmentWhereUniqueInput
  }

  /**
   * Segment deleteMany
   */
  export type SegmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Segments to delete
     */
    where?: SegmentWhereInput
    /**
     * Limit how many Segments to delete.
     */
    limit?: number
  }

  /**
   * Segment.emailCampaigns
   */
  export type Segment$emailCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
    where?: EmailCampaignWhereInput
    orderBy?: EmailCampaignOrderByWithRelationInput | EmailCampaignOrderByWithRelationInput[]
    cursor?: EmailCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailCampaignScalarFieldEnum | EmailCampaignScalarFieldEnum[]
  }

  /**
   * Segment.smsCampaigns
   */
  export type Segment$smsCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSCampaign
     */
    select?: SMSCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSCampaign
     */
    omit?: SMSCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSCampaignInclude<ExtArgs> | null
    where?: SMSCampaignWhereInput
    orderBy?: SMSCampaignOrderByWithRelationInput | SMSCampaignOrderByWithRelationInput[]
    cursor?: SMSCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SMSCampaignScalarFieldEnum | SMSCampaignScalarFieldEnum[]
  }

  /**
   * Segment.waCampaigns
   */
  export type Segment$waCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
    where?: WhatsAppCampaignWhereInput
    orderBy?: WhatsAppCampaignOrderByWithRelationInput | WhatsAppCampaignOrderByWithRelationInput[]
    cursor?: WhatsAppCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppCampaignScalarFieldEnum | WhatsAppCampaignScalarFieldEnum[]
  }

  /**
   * Segment without action
   */
  export type SegmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
  }


  /**
   * Model EmailTemplate
   */

  export type AggregateEmailTemplate = {
    _count: EmailTemplateCountAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  export type EmailTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    subject: string | null
    content: string | null
    design: string | null
    previewText: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type EmailTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    subject: string | null
    content: string | null
    design: string | null
    previewText: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type EmailTemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    subject: number
    content: number
    design: number
    previewText: number
    category: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type EmailTemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    subject?: true
    content?: true
    design?: true
    previewText?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type EmailTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    subject?: true
    content?: true
    design?: true
    previewText?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type EmailTemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    subject?: true
    content?: true
    design?: true
    previewText?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type EmailTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplate to aggregate.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailTemplates
    **/
    _count?: true | EmailTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type GetEmailTemplateAggregateType<T extends EmailTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailTemplate[P]>
      : GetScalarType<T[P], AggregateEmailTemplate[P]>
  }




  export type EmailTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTemplateWhereInput
    orderBy?: EmailTemplateOrderByWithAggregationInput | EmailTemplateOrderByWithAggregationInput[]
    by: EmailTemplateScalarFieldEnum[] | EmailTemplateScalarFieldEnum
    having?: EmailTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailTemplateCountAggregateInputType | true
    _min?: EmailTemplateMinAggregateInputType
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type EmailTemplateGroupByOutputType = {
    id: string
    name: string
    description: string | null
    subject: string
    content: string
    design: string | null
    previewText: string | null
    category: string | null
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: EmailTemplateCountAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  type GetEmailTemplateGroupByPayload<T extends EmailTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
        }
      >
    >


  export type EmailTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    subject?: boolean
    content?: boolean
    design?: boolean
    previewText?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    campaigns?: boolean | EmailTemplate$campaignsArgs<ExtArgs>
    _count?: boolean | EmailTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    subject?: boolean
    content?: boolean
    design?: boolean
    previewText?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    subject?: boolean
    content?: boolean
    design?: boolean
    previewText?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    subject?: boolean
    content?: boolean
    design?: boolean
    previewText?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type EmailTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "subject" | "content" | "design" | "previewText" | "category" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["emailTemplate"]>
  export type EmailTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    campaigns?: boolean | EmailTemplate$campaignsArgs<ExtArgs>
    _count?: boolean | EmailTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmailTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmailTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailTemplate"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      campaigns: Prisma.$EmailCampaignPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      subject: string
      content: string
      design: string | null
      previewText: string | null
      category: string | null
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["emailTemplate"]>
    composites: {}
  }

  type EmailTemplateGetPayload<S extends boolean | null | undefined | EmailTemplateDefaultArgs> = $Result.GetResult<Prisma.$EmailTemplatePayload, S>

  type EmailTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailTemplateCountAggregateInputType | true
    }

  export interface EmailTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailTemplate'], meta: { name: 'EmailTemplate' } }
    /**
     * Find zero or one EmailTemplate that matches the filter.
     * @param {EmailTemplateFindUniqueArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailTemplateFindUniqueArgs>(args: SelectSubset<T, EmailTemplateFindUniqueArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailTemplateFindUniqueOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailTemplateFindFirstArgs>(args?: SelectSubset<T, EmailTemplateFindFirstArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany()
     * 
     * // Get first 10 EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailTemplateFindManyArgs>(args?: SelectSubset<T, EmailTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailTemplate.
     * @param {EmailTemplateCreateArgs} args - Arguments to create a EmailTemplate.
     * @example
     * // Create one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.create({
     *   data: {
     *     // ... data to create a EmailTemplate
     *   }
     * })
     * 
     */
    create<T extends EmailTemplateCreateArgs>(args: SelectSubset<T, EmailTemplateCreateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailTemplates.
     * @param {EmailTemplateCreateManyArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailTemplateCreateManyArgs>(args?: SelectSubset<T, EmailTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailTemplates and returns the data saved in the database.
     * @param {EmailTemplateCreateManyAndReturnArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailTemplates and only return the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailTemplate.
     * @param {EmailTemplateDeleteArgs} args - Arguments to delete one EmailTemplate.
     * @example
     * // Delete one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.delete({
     *   where: {
     *     // ... filter to delete one EmailTemplate
     *   }
     * })
     * 
     */
    delete<T extends EmailTemplateDeleteArgs>(args: SelectSubset<T, EmailTemplateDeleteArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailTemplate.
     * @param {EmailTemplateUpdateArgs} args - Arguments to update one EmailTemplate.
     * @example
     * // Update one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailTemplateUpdateArgs>(args: SelectSubset<T, EmailTemplateUpdateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailTemplates.
     * @param {EmailTemplateDeleteManyArgs} args - Arguments to filter EmailTemplates to delete.
     * @example
     * // Delete a few EmailTemplates
     * const { count } = await prisma.emailTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailTemplateDeleteManyArgs>(args?: SelectSubset<T, EmailTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailTemplateUpdateManyArgs>(args: SelectSubset<T, EmailTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTemplates and returns the data updated in the database.
     * @param {EmailTemplateUpdateManyAndReturnArgs} args - Arguments to update many EmailTemplates.
     * @example
     * // Update many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailTemplates and only return the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailTemplate.
     * @param {EmailTemplateUpsertArgs} args - Arguments to update or create a EmailTemplate.
     * @example
     * // Update or create a EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.upsert({
     *   create: {
     *     // ... data to create a EmailTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailTemplate we want to update
     *   }
     * })
     */
    upsert<T extends EmailTemplateUpsertArgs>(args: SelectSubset<T, EmailTemplateUpsertArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateCountArgs} args - Arguments to filter EmailTemplates to count.
     * @example
     * // Count the number of EmailTemplates
     * const count = await prisma.emailTemplate.count({
     *   where: {
     *     // ... the filter for the EmailTemplates we want to count
     *   }
     * })
    **/
    count<T extends EmailTemplateCountArgs>(
      args?: Subset<T, EmailTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailTemplateAggregateArgs>(args: Subset<T, EmailTemplateAggregateArgs>): Prisma.PrismaPromise<GetEmailTemplateAggregateType<T>>

    /**
     * Group by EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailTemplateGroupByArgs['orderBy'] }
        : { orderBy?: EmailTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailTemplate model
   */
  readonly fields: EmailTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campaigns<T extends EmailTemplate$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, EmailTemplate$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailTemplate model
   */
  interface EmailTemplateFieldRefs {
    readonly id: FieldRef<"EmailTemplate", 'String'>
    readonly name: FieldRef<"EmailTemplate", 'String'>
    readonly description: FieldRef<"EmailTemplate", 'String'>
    readonly subject: FieldRef<"EmailTemplate", 'String'>
    readonly content: FieldRef<"EmailTemplate", 'String'>
    readonly design: FieldRef<"EmailTemplate", 'String'>
    readonly previewText: FieldRef<"EmailTemplate", 'String'>
    readonly category: FieldRef<"EmailTemplate", 'String'>
    readonly createdAt: FieldRef<"EmailTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailTemplate", 'DateTime'>
    readonly createdById: FieldRef<"EmailTemplate", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmailTemplate findUnique
   */
  export type EmailTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findUniqueOrThrow
   */
  export type EmailTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findFirst
   */
  export type EmailTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findFirstOrThrow
   */
  export type EmailTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findMany
   */
  export type EmailTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplates to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate create
   */
  export type EmailTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailTemplate.
     */
    data: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
  }

  /**
   * EmailTemplate createMany
   */
  export type EmailTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailTemplate createManyAndReturn
   */
  export type EmailTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailTemplate update
   */
  export type EmailTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailTemplate.
     */
    data: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
    /**
     * Choose, which EmailTemplate to update.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate updateMany
   */
  export type EmailTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailTemplates.
     */
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EmailTemplates to update
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to update.
     */
    limit?: number
  }

  /**
   * EmailTemplate updateManyAndReturn
   */
  export type EmailTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The data used to update EmailTemplates.
     */
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EmailTemplates to update
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailTemplate upsert
   */
  export type EmailTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailTemplate to update in case it exists.
     */
    where: EmailTemplateWhereUniqueInput
    /**
     * In case the EmailTemplate found by the `where` argument doesn't exist, create a new EmailTemplate with this data.
     */
    create: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
    /**
     * In case the EmailTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
  }

  /**
   * EmailTemplate delete
   */
  export type EmailTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter which EmailTemplate to delete.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate deleteMany
   */
  export type EmailTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplates to delete
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to delete.
     */
    limit?: number
  }

  /**
   * EmailTemplate.campaigns
   */
  export type EmailTemplate$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
    where?: EmailCampaignWhereInput
    orderBy?: EmailCampaignOrderByWithRelationInput | EmailCampaignOrderByWithRelationInput[]
    cursor?: EmailCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailCampaignScalarFieldEnum | EmailCampaignScalarFieldEnum[]
  }

  /**
   * EmailTemplate without action
   */
  export type EmailTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
  }


  /**
   * Model EmailCampaign
   */

  export type AggregateEmailCampaign = {
    _count: EmailCampaignCountAggregateOutputType | null
    _min: EmailCampaignMinAggregateOutputType | null
    _max: EmailCampaignMaxAggregateOutputType | null
  }

  export type EmailCampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    subject: string | null
    from: string | null
    replyTo: string | null
    templateId: string | null
    content: string | null
    design: string | null
    status: $Enums.CampaignStatus | null
    scheduledFor: Date | null
    sentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type EmailCampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    subject: string | null
    from: string | null
    replyTo: string | null
    templateId: string | null
    content: string | null
    design: string | null
    status: $Enums.CampaignStatus | null
    scheduledFor: Date | null
    sentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type EmailCampaignCountAggregateOutputType = {
    id: number
    name: number
    description: number
    subject: number
    from: number
    replyTo: number
    templateId: number
    content: number
    design: number
    status: number
    scheduledFor: number
    sentAt: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type EmailCampaignMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    subject?: true
    from?: true
    replyTo?: true
    templateId?: true
    content?: true
    design?: true
    status?: true
    scheduledFor?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type EmailCampaignMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    subject?: true
    from?: true
    replyTo?: true
    templateId?: true
    content?: true
    design?: true
    status?: true
    scheduledFor?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type EmailCampaignCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    subject?: true
    from?: true
    replyTo?: true
    templateId?: true
    content?: true
    design?: true
    status?: true
    scheduledFor?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type EmailCampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailCampaign to aggregate.
     */
    where?: EmailCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailCampaigns to fetch.
     */
    orderBy?: EmailCampaignOrderByWithRelationInput | EmailCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailCampaigns
    **/
    _count?: true | EmailCampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailCampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailCampaignMaxAggregateInputType
  }

  export type GetEmailCampaignAggregateType<T extends EmailCampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailCampaign[P]>
      : GetScalarType<T[P], AggregateEmailCampaign[P]>
  }




  export type EmailCampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailCampaignWhereInput
    orderBy?: EmailCampaignOrderByWithAggregationInput | EmailCampaignOrderByWithAggregationInput[]
    by: EmailCampaignScalarFieldEnum[] | EmailCampaignScalarFieldEnum
    having?: EmailCampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailCampaignCountAggregateInputType | true
    _min?: EmailCampaignMinAggregateInputType
    _max?: EmailCampaignMaxAggregateInputType
  }

  export type EmailCampaignGroupByOutputType = {
    id: string
    name: string
    description: string | null
    subject: string
    from: string
    replyTo: string | null
    templateId: string | null
    content: string | null
    design: string | null
    status: $Enums.CampaignStatus
    scheduledFor: Date | null
    sentAt: Date | null
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: EmailCampaignCountAggregateOutputType | null
    _min: EmailCampaignMinAggregateOutputType | null
    _max: EmailCampaignMaxAggregateOutputType | null
  }

  type GetEmailCampaignGroupByPayload<T extends EmailCampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailCampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailCampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailCampaignGroupByOutputType[P]>
            : GetScalarType<T[P], EmailCampaignGroupByOutputType[P]>
        }
      >
    >


  export type EmailCampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    subject?: boolean
    from?: boolean
    replyTo?: boolean
    templateId?: boolean
    content?: boolean
    design?: boolean
    status?: boolean
    scheduledFor?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | EmailCampaign$templateArgs<ExtArgs>
    lists?: boolean | EmailCampaign$listsArgs<ExtArgs>
    segments?: boolean | EmailCampaign$segmentsArgs<ExtArgs>
    activities?: boolean | EmailCampaign$activitiesArgs<ExtArgs>
    _count?: boolean | EmailCampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailCampaign"]>

  export type EmailCampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    subject?: boolean
    from?: boolean
    replyTo?: boolean
    templateId?: boolean
    content?: boolean
    design?: boolean
    status?: boolean
    scheduledFor?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | EmailCampaign$templateArgs<ExtArgs>
  }, ExtArgs["result"]["emailCampaign"]>

  export type EmailCampaignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    subject?: boolean
    from?: boolean
    replyTo?: boolean
    templateId?: boolean
    content?: boolean
    design?: boolean
    status?: boolean
    scheduledFor?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | EmailCampaign$templateArgs<ExtArgs>
  }, ExtArgs["result"]["emailCampaign"]>

  export type EmailCampaignSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    subject?: boolean
    from?: boolean
    replyTo?: boolean
    templateId?: boolean
    content?: boolean
    design?: boolean
    status?: boolean
    scheduledFor?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type EmailCampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "subject" | "from" | "replyTo" | "templateId" | "content" | "design" | "status" | "scheduledFor" | "sentAt" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["emailCampaign"]>
  export type EmailCampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | EmailCampaign$templateArgs<ExtArgs>
    lists?: boolean | EmailCampaign$listsArgs<ExtArgs>
    segments?: boolean | EmailCampaign$segmentsArgs<ExtArgs>
    activities?: boolean | EmailCampaign$activitiesArgs<ExtArgs>
    _count?: boolean | EmailCampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmailCampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | EmailCampaign$templateArgs<ExtArgs>
  }
  export type EmailCampaignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | EmailCampaign$templateArgs<ExtArgs>
  }

  export type $EmailCampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailCampaign"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      template: Prisma.$EmailTemplatePayload<ExtArgs> | null
      lists: Prisma.$ListPayload<ExtArgs>[]
      segments: Prisma.$SegmentPayload<ExtArgs>[]
      activities: Prisma.$EmailActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      subject: string
      from: string
      replyTo: string | null
      templateId: string | null
      content: string | null
      design: string | null
      status: $Enums.CampaignStatus
      scheduledFor: Date | null
      sentAt: Date | null
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["emailCampaign"]>
    composites: {}
  }

  type EmailCampaignGetPayload<S extends boolean | null | undefined | EmailCampaignDefaultArgs> = $Result.GetResult<Prisma.$EmailCampaignPayload, S>

  type EmailCampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailCampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailCampaignCountAggregateInputType | true
    }

  export interface EmailCampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailCampaign'], meta: { name: 'EmailCampaign' } }
    /**
     * Find zero or one EmailCampaign that matches the filter.
     * @param {EmailCampaignFindUniqueArgs} args - Arguments to find a EmailCampaign
     * @example
     * // Get one EmailCampaign
     * const emailCampaign = await prisma.emailCampaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailCampaignFindUniqueArgs>(args: SelectSubset<T, EmailCampaignFindUniqueArgs<ExtArgs>>): Prisma__EmailCampaignClient<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailCampaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailCampaignFindUniqueOrThrowArgs} args - Arguments to find a EmailCampaign
     * @example
     * // Get one EmailCampaign
     * const emailCampaign = await prisma.emailCampaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailCampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailCampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailCampaignClient<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailCampaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignFindFirstArgs} args - Arguments to find a EmailCampaign
     * @example
     * // Get one EmailCampaign
     * const emailCampaign = await prisma.emailCampaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailCampaignFindFirstArgs>(args?: SelectSubset<T, EmailCampaignFindFirstArgs<ExtArgs>>): Prisma__EmailCampaignClient<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailCampaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignFindFirstOrThrowArgs} args - Arguments to find a EmailCampaign
     * @example
     * // Get one EmailCampaign
     * const emailCampaign = await prisma.emailCampaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailCampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailCampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailCampaignClient<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailCampaigns
     * const emailCampaigns = await prisma.emailCampaign.findMany()
     * 
     * // Get first 10 EmailCampaigns
     * const emailCampaigns = await prisma.emailCampaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailCampaignWithIdOnly = await prisma.emailCampaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailCampaignFindManyArgs>(args?: SelectSubset<T, EmailCampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailCampaign.
     * @param {EmailCampaignCreateArgs} args - Arguments to create a EmailCampaign.
     * @example
     * // Create one EmailCampaign
     * const EmailCampaign = await prisma.emailCampaign.create({
     *   data: {
     *     // ... data to create a EmailCampaign
     *   }
     * })
     * 
     */
    create<T extends EmailCampaignCreateArgs>(args: SelectSubset<T, EmailCampaignCreateArgs<ExtArgs>>): Prisma__EmailCampaignClient<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailCampaigns.
     * @param {EmailCampaignCreateManyArgs} args - Arguments to create many EmailCampaigns.
     * @example
     * // Create many EmailCampaigns
     * const emailCampaign = await prisma.emailCampaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailCampaignCreateManyArgs>(args?: SelectSubset<T, EmailCampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailCampaigns and returns the data saved in the database.
     * @param {EmailCampaignCreateManyAndReturnArgs} args - Arguments to create many EmailCampaigns.
     * @example
     * // Create many EmailCampaigns
     * const emailCampaign = await prisma.emailCampaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailCampaigns and only return the `id`
     * const emailCampaignWithIdOnly = await prisma.emailCampaign.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailCampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailCampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailCampaign.
     * @param {EmailCampaignDeleteArgs} args - Arguments to delete one EmailCampaign.
     * @example
     * // Delete one EmailCampaign
     * const EmailCampaign = await prisma.emailCampaign.delete({
     *   where: {
     *     // ... filter to delete one EmailCampaign
     *   }
     * })
     * 
     */
    delete<T extends EmailCampaignDeleteArgs>(args: SelectSubset<T, EmailCampaignDeleteArgs<ExtArgs>>): Prisma__EmailCampaignClient<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailCampaign.
     * @param {EmailCampaignUpdateArgs} args - Arguments to update one EmailCampaign.
     * @example
     * // Update one EmailCampaign
     * const emailCampaign = await prisma.emailCampaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailCampaignUpdateArgs>(args: SelectSubset<T, EmailCampaignUpdateArgs<ExtArgs>>): Prisma__EmailCampaignClient<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailCampaigns.
     * @param {EmailCampaignDeleteManyArgs} args - Arguments to filter EmailCampaigns to delete.
     * @example
     * // Delete a few EmailCampaigns
     * const { count } = await prisma.emailCampaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailCampaignDeleteManyArgs>(args?: SelectSubset<T, EmailCampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailCampaigns
     * const emailCampaign = await prisma.emailCampaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailCampaignUpdateManyArgs>(args: SelectSubset<T, EmailCampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailCampaigns and returns the data updated in the database.
     * @param {EmailCampaignUpdateManyAndReturnArgs} args - Arguments to update many EmailCampaigns.
     * @example
     * // Update many EmailCampaigns
     * const emailCampaign = await prisma.emailCampaign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailCampaigns and only return the `id`
     * const emailCampaignWithIdOnly = await prisma.emailCampaign.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailCampaignUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailCampaignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailCampaign.
     * @param {EmailCampaignUpsertArgs} args - Arguments to update or create a EmailCampaign.
     * @example
     * // Update or create a EmailCampaign
     * const emailCampaign = await prisma.emailCampaign.upsert({
     *   create: {
     *     // ... data to create a EmailCampaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailCampaign we want to update
     *   }
     * })
     */
    upsert<T extends EmailCampaignUpsertArgs>(args: SelectSubset<T, EmailCampaignUpsertArgs<ExtArgs>>): Prisma__EmailCampaignClient<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignCountArgs} args - Arguments to filter EmailCampaigns to count.
     * @example
     * // Count the number of EmailCampaigns
     * const count = await prisma.emailCampaign.count({
     *   where: {
     *     // ... the filter for the EmailCampaigns we want to count
     *   }
     * })
    **/
    count<T extends EmailCampaignCountArgs>(
      args?: Subset<T, EmailCampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailCampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailCampaignAggregateArgs>(args: Subset<T, EmailCampaignAggregateArgs>): Prisma.PrismaPromise<GetEmailCampaignAggregateType<T>>

    /**
     * Group by EmailCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailCampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailCampaignGroupByArgs['orderBy'] }
        : { orderBy?: EmailCampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailCampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailCampaign model
   */
  readonly fields: EmailCampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailCampaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailCampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    template<T extends EmailCampaign$templateArgs<ExtArgs> = {}>(args?: Subset<T, EmailCampaign$templateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lists<T extends EmailCampaign$listsArgs<ExtArgs> = {}>(args?: Subset<T, EmailCampaign$listsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    segments<T extends EmailCampaign$segmentsArgs<ExtArgs> = {}>(args?: Subset<T, EmailCampaign$segmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends EmailCampaign$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, EmailCampaign$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailCampaign model
   */
  interface EmailCampaignFieldRefs {
    readonly id: FieldRef<"EmailCampaign", 'String'>
    readonly name: FieldRef<"EmailCampaign", 'String'>
    readonly description: FieldRef<"EmailCampaign", 'String'>
    readonly subject: FieldRef<"EmailCampaign", 'String'>
    readonly from: FieldRef<"EmailCampaign", 'String'>
    readonly replyTo: FieldRef<"EmailCampaign", 'String'>
    readonly templateId: FieldRef<"EmailCampaign", 'String'>
    readonly content: FieldRef<"EmailCampaign", 'String'>
    readonly design: FieldRef<"EmailCampaign", 'String'>
    readonly status: FieldRef<"EmailCampaign", 'CampaignStatus'>
    readonly scheduledFor: FieldRef<"EmailCampaign", 'DateTime'>
    readonly sentAt: FieldRef<"EmailCampaign", 'DateTime'>
    readonly createdAt: FieldRef<"EmailCampaign", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailCampaign", 'DateTime'>
    readonly createdById: FieldRef<"EmailCampaign", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmailCampaign findUnique
   */
  export type EmailCampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
    /**
     * Filter, which EmailCampaign to fetch.
     */
    where: EmailCampaignWhereUniqueInput
  }

  /**
   * EmailCampaign findUniqueOrThrow
   */
  export type EmailCampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
    /**
     * Filter, which EmailCampaign to fetch.
     */
    where: EmailCampaignWhereUniqueInput
  }

  /**
   * EmailCampaign findFirst
   */
  export type EmailCampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
    /**
     * Filter, which EmailCampaign to fetch.
     */
    where?: EmailCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailCampaigns to fetch.
     */
    orderBy?: EmailCampaignOrderByWithRelationInput | EmailCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailCampaigns.
     */
    cursor?: EmailCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailCampaigns.
     */
    distinct?: EmailCampaignScalarFieldEnum | EmailCampaignScalarFieldEnum[]
  }

  /**
   * EmailCampaign findFirstOrThrow
   */
  export type EmailCampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
    /**
     * Filter, which EmailCampaign to fetch.
     */
    where?: EmailCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailCampaigns to fetch.
     */
    orderBy?: EmailCampaignOrderByWithRelationInput | EmailCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailCampaigns.
     */
    cursor?: EmailCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailCampaigns.
     */
    distinct?: EmailCampaignScalarFieldEnum | EmailCampaignScalarFieldEnum[]
  }

  /**
   * EmailCampaign findMany
   */
  export type EmailCampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
    /**
     * Filter, which EmailCampaigns to fetch.
     */
    where?: EmailCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailCampaigns to fetch.
     */
    orderBy?: EmailCampaignOrderByWithRelationInput | EmailCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailCampaigns.
     */
    cursor?: EmailCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailCampaigns.
     */
    skip?: number
    distinct?: EmailCampaignScalarFieldEnum | EmailCampaignScalarFieldEnum[]
  }

  /**
   * EmailCampaign create
   */
  export type EmailCampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailCampaign.
     */
    data: XOR<EmailCampaignCreateInput, EmailCampaignUncheckedCreateInput>
  }

  /**
   * EmailCampaign createMany
   */
  export type EmailCampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailCampaigns.
     */
    data: EmailCampaignCreateManyInput | EmailCampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailCampaign createManyAndReturn
   */
  export type EmailCampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * The data used to create many EmailCampaigns.
     */
    data: EmailCampaignCreateManyInput | EmailCampaignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailCampaign update
   */
  export type EmailCampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailCampaign.
     */
    data: XOR<EmailCampaignUpdateInput, EmailCampaignUncheckedUpdateInput>
    /**
     * Choose, which EmailCampaign to update.
     */
    where: EmailCampaignWhereUniqueInput
  }

  /**
   * EmailCampaign updateMany
   */
  export type EmailCampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailCampaigns.
     */
    data: XOR<EmailCampaignUpdateManyMutationInput, EmailCampaignUncheckedUpdateManyInput>
    /**
     * Filter which EmailCampaigns to update
     */
    where?: EmailCampaignWhereInput
    /**
     * Limit how many EmailCampaigns to update.
     */
    limit?: number
  }

  /**
   * EmailCampaign updateManyAndReturn
   */
  export type EmailCampaignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * The data used to update EmailCampaigns.
     */
    data: XOR<EmailCampaignUpdateManyMutationInput, EmailCampaignUncheckedUpdateManyInput>
    /**
     * Filter which EmailCampaigns to update
     */
    where?: EmailCampaignWhereInput
    /**
     * Limit how many EmailCampaigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailCampaign upsert
   */
  export type EmailCampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailCampaign to update in case it exists.
     */
    where: EmailCampaignWhereUniqueInput
    /**
     * In case the EmailCampaign found by the `where` argument doesn't exist, create a new EmailCampaign with this data.
     */
    create: XOR<EmailCampaignCreateInput, EmailCampaignUncheckedCreateInput>
    /**
     * In case the EmailCampaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailCampaignUpdateInput, EmailCampaignUncheckedUpdateInput>
  }

  /**
   * EmailCampaign delete
   */
  export type EmailCampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
    /**
     * Filter which EmailCampaign to delete.
     */
    where: EmailCampaignWhereUniqueInput
  }

  /**
   * EmailCampaign deleteMany
   */
  export type EmailCampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailCampaigns to delete
     */
    where?: EmailCampaignWhereInput
    /**
     * Limit how many EmailCampaigns to delete.
     */
    limit?: number
  }

  /**
   * EmailCampaign.template
   */
  export type EmailCampaign$templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    where?: EmailTemplateWhereInput
  }

  /**
   * EmailCampaign.lists
   */
  export type EmailCampaign$listsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    where?: ListWhereInput
    orderBy?: ListOrderByWithRelationInput | ListOrderByWithRelationInput[]
    cursor?: ListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListScalarFieldEnum | ListScalarFieldEnum[]
  }

  /**
   * EmailCampaign.segments
   */
  export type EmailCampaign$segmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    where?: SegmentWhereInput
    orderBy?: SegmentOrderByWithRelationInput | SegmentOrderByWithRelationInput[]
    cursor?: SegmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SegmentScalarFieldEnum | SegmentScalarFieldEnum[]
  }

  /**
   * EmailCampaign.activities
   */
  export type EmailCampaign$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActivity
     */
    select?: EmailActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActivity
     */
    omit?: EmailActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActivityInclude<ExtArgs> | null
    where?: EmailActivityWhereInput
    orderBy?: EmailActivityOrderByWithRelationInput | EmailActivityOrderByWithRelationInput[]
    cursor?: EmailActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailActivityScalarFieldEnum | EmailActivityScalarFieldEnum[]
  }

  /**
   * EmailCampaign without action
   */
  export type EmailCampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
  }


  /**
   * Model EmailActivity
   */

  export type AggregateEmailActivity = {
    _count: EmailActivityCountAggregateOutputType | null
    _min: EmailActivityMinAggregateOutputType | null
    _max: EmailActivityMaxAggregateOutputType | null
  }

  export type EmailActivityMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    contactId: string | null
    type: $Enums.ActivityType | null
    timestamp: Date | null
    metadata: string | null
  }

  export type EmailActivityMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    contactId: string | null
    type: $Enums.ActivityType | null
    timestamp: Date | null
    metadata: string | null
  }

  export type EmailActivityCountAggregateOutputType = {
    id: number
    campaignId: number
    contactId: number
    type: number
    timestamp: number
    metadata: number
    _all: number
  }


  export type EmailActivityMinAggregateInputType = {
    id?: true
    campaignId?: true
    contactId?: true
    type?: true
    timestamp?: true
    metadata?: true
  }

  export type EmailActivityMaxAggregateInputType = {
    id?: true
    campaignId?: true
    contactId?: true
    type?: true
    timestamp?: true
    metadata?: true
  }

  export type EmailActivityCountAggregateInputType = {
    id?: true
    campaignId?: true
    contactId?: true
    type?: true
    timestamp?: true
    metadata?: true
    _all?: true
  }

  export type EmailActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailActivity to aggregate.
     */
    where?: EmailActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailActivities to fetch.
     */
    orderBy?: EmailActivityOrderByWithRelationInput | EmailActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailActivities
    **/
    _count?: true | EmailActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailActivityMaxAggregateInputType
  }

  export type GetEmailActivityAggregateType<T extends EmailActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailActivity[P]>
      : GetScalarType<T[P], AggregateEmailActivity[P]>
  }




  export type EmailActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailActivityWhereInput
    orderBy?: EmailActivityOrderByWithAggregationInput | EmailActivityOrderByWithAggregationInput[]
    by: EmailActivityScalarFieldEnum[] | EmailActivityScalarFieldEnum
    having?: EmailActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailActivityCountAggregateInputType | true
    _min?: EmailActivityMinAggregateInputType
    _max?: EmailActivityMaxAggregateInputType
  }

  export type EmailActivityGroupByOutputType = {
    id: string
    campaignId: string
    contactId: string
    type: $Enums.ActivityType
    timestamp: Date
    metadata: string | null
    _count: EmailActivityCountAggregateOutputType | null
    _min: EmailActivityMinAggregateOutputType | null
    _max: EmailActivityMaxAggregateOutputType | null
  }

  type GetEmailActivityGroupByPayload<T extends EmailActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailActivityGroupByOutputType[P]>
            : GetScalarType<T[P], EmailActivityGroupByOutputType[P]>
        }
      >
    >


  export type EmailActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    contactId?: boolean
    type?: boolean
    timestamp?: boolean
    metadata?: boolean
    campaign?: boolean | EmailCampaignDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailActivity"]>

  export type EmailActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    contactId?: boolean
    type?: boolean
    timestamp?: boolean
    metadata?: boolean
    campaign?: boolean | EmailCampaignDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailActivity"]>

  export type EmailActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    contactId?: boolean
    type?: boolean
    timestamp?: boolean
    metadata?: boolean
    campaign?: boolean | EmailCampaignDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailActivity"]>

  export type EmailActivitySelectScalar = {
    id?: boolean
    campaignId?: boolean
    contactId?: boolean
    type?: boolean
    timestamp?: boolean
    metadata?: boolean
  }

  export type EmailActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaignId" | "contactId" | "type" | "timestamp" | "metadata", ExtArgs["result"]["emailActivity"]>
  export type EmailActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | EmailCampaignDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }
  export type EmailActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | EmailCampaignDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }
  export type EmailActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | EmailCampaignDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }

  export type $EmailActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailActivity"
    objects: {
      campaign: Prisma.$EmailCampaignPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      contactId: string
      type: $Enums.ActivityType
      timestamp: Date
      metadata: string | null
    }, ExtArgs["result"]["emailActivity"]>
    composites: {}
  }

  type EmailActivityGetPayload<S extends boolean | null | undefined | EmailActivityDefaultArgs> = $Result.GetResult<Prisma.$EmailActivityPayload, S>

  type EmailActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailActivityCountAggregateInputType | true
    }

  export interface EmailActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailActivity'], meta: { name: 'EmailActivity' } }
    /**
     * Find zero or one EmailActivity that matches the filter.
     * @param {EmailActivityFindUniqueArgs} args - Arguments to find a EmailActivity
     * @example
     * // Get one EmailActivity
     * const emailActivity = await prisma.emailActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailActivityFindUniqueArgs>(args: SelectSubset<T, EmailActivityFindUniqueArgs<ExtArgs>>): Prisma__EmailActivityClient<$Result.GetResult<Prisma.$EmailActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailActivityFindUniqueOrThrowArgs} args - Arguments to find a EmailActivity
     * @example
     * // Get one EmailActivity
     * const emailActivity = await prisma.emailActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailActivityClient<$Result.GetResult<Prisma.$EmailActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailActivityFindFirstArgs} args - Arguments to find a EmailActivity
     * @example
     * // Get one EmailActivity
     * const emailActivity = await prisma.emailActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailActivityFindFirstArgs>(args?: SelectSubset<T, EmailActivityFindFirstArgs<ExtArgs>>): Prisma__EmailActivityClient<$Result.GetResult<Prisma.$EmailActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailActivityFindFirstOrThrowArgs} args - Arguments to find a EmailActivity
     * @example
     * // Get one EmailActivity
     * const emailActivity = await prisma.emailActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailActivityClient<$Result.GetResult<Prisma.$EmailActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailActivities
     * const emailActivities = await prisma.emailActivity.findMany()
     * 
     * // Get first 10 EmailActivities
     * const emailActivities = await prisma.emailActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailActivityWithIdOnly = await prisma.emailActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailActivityFindManyArgs>(args?: SelectSubset<T, EmailActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailActivity.
     * @param {EmailActivityCreateArgs} args - Arguments to create a EmailActivity.
     * @example
     * // Create one EmailActivity
     * const EmailActivity = await prisma.emailActivity.create({
     *   data: {
     *     // ... data to create a EmailActivity
     *   }
     * })
     * 
     */
    create<T extends EmailActivityCreateArgs>(args: SelectSubset<T, EmailActivityCreateArgs<ExtArgs>>): Prisma__EmailActivityClient<$Result.GetResult<Prisma.$EmailActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailActivities.
     * @param {EmailActivityCreateManyArgs} args - Arguments to create many EmailActivities.
     * @example
     * // Create many EmailActivities
     * const emailActivity = await prisma.emailActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailActivityCreateManyArgs>(args?: SelectSubset<T, EmailActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailActivities and returns the data saved in the database.
     * @param {EmailActivityCreateManyAndReturnArgs} args - Arguments to create many EmailActivities.
     * @example
     * // Create many EmailActivities
     * const emailActivity = await prisma.emailActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailActivities and only return the `id`
     * const emailActivityWithIdOnly = await prisma.emailActivity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailActivity.
     * @param {EmailActivityDeleteArgs} args - Arguments to delete one EmailActivity.
     * @example
     * // Delete one EmailActivity
     * const EmailActivity = await prisma.emailActivity.delete({
     *   where: {
     *     // ... filter to delete one EmailActivity
     *   }
     * })
     * 
     */
    delete<T extends EmailActivityDeleteArgs>(args: SelectSubset<T, EmailActivityDeleteArgs<ExtArgs>>): Prisma__EmailActivityClient<$Result.GetResult<Prisma.$EmailActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailActivity.
     * @param {EmailActivityUpdateArgs} args - Arguments to update one EmailActivity.
     * @example
     * // Update one EmailActivity
     * const emailActivity = await prisma.emailActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailActivityUpdateArgs>(args: SelectSubset<T, EmailActivityUpdateArgs<ExtArgs>>): Prisma__EmailActivityClient<$Result.GetResult<Prisma.$EmailActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailActivities.
     * @param {EmailActivityDeleteManyArgs} args - Arguments to filter EmailActivities to delete.
     * @example
     * // Delete a few EmailActivities
     * const { count } = await prisma.emailActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailActivityDeleteManyArgs>(args?: SelectSubset<T, EmailActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailActivities
     * const emailActivity = await prisma.emailActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailActivityUpdateManyArgs>(args: SelectSubset<T, EmailActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailActivities and returns the data updated in the database.
     * @param {EmailActivityUpdateManyAndReturnArgs} args - Arguments to update many EmailActivities.
     * @example
     * // Update many EmailActivities
     * const emailActivity = await prisma.emailActivity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailActivities and only return the `id`
     * const emailActivityWithIdOnly = await prisma.emailActivity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailActivity.
     * @param {EmailActivityUpsertArgs} args - Arguments to update or create a EmailActivity.
     * @example
     * // Update or create a EmailActivity
     * const emailActivity = await prisma.emailActivity.upsert({
     *   create: {
     *     // ... data to create a EmailActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailActivity we want to update
     *   }
     * })
     */
    upsert<T extends EmailActivityUpsertArgs>(args: SelectSubset<T, EmailActivityUpsertArgs<ExtArgs>>): Prisma__EmailActivityClient<$Result.GetResult<Prisma.$EmailActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailActivityCountArgs} args - Arguments to filter EmailActivities to count.
     * @example
     * // Count the number of EmailActivities
     * const count = await prisma.emailActivity.count({
     *   where: {
     *     // ... the filter for the EmailActivities we want to count
     *   }
     * })
    **/
    count<T extends EmailActivityCountArgs>(
      args?: Subset<T, EmailActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailActivityAggregateArgs>(args: Subset<T, EmailActivityAggregateArgs>): Prisma.PrismaPromise<GetEmailActivityAggregateType<T>>

    /**
     * Group by EmailActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailActivityGroupByArgs['orderBy'] }
        : { orderBy?: EmailActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailActivity model
   */
  readonly fields: EmailActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends EmailCampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailCampaignDefaultArgs<ExtArgs>>): Prisma__EmailCampaignClient<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailActivity model
   */
  interface EmailActivityFieldRefs {
    readonly id: FieldRef<"EmailActivity", 'String'>
    readonly campaignId: FieldRef<"EmailActivity", 'String'>
    readonly contactId: FieldRef<"EmailActivity", 'String'>
    readonly type: FieldRef<"EmailActivity", 'ActivityType'>
    readonly timestamp: FieldRef<"EmailActivity", 'DateTime'>
    readonly metadata: FieldRef<"EmailActivity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmailActivity findUnique
   */
  export type EmailActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActivity
     */
    select?: EmailActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActivity
     */
    omit?: EmailActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActivityInclude<ExtArgs> | null
    /**
     * Filter, which EmailActivity to fetch.
     */
    where: EmailActivityWhereUniqueInput
  }

  /**
   * EmailActivity findUniqueOrThrow
   */
  export type EmailActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActivity
     */
    select?: EmailActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActivity
     */
    omit?: EmailActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActivityInclude<ExtArgs> | null
    /**
     * Filter, which EmailActivity to fetch.
     */
    where: EmailActivityWhereUniqueInput
  }

  /**
   * EmailActivity findFirst
   */
  export type EmailActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActivity
     */
    select?: EmailActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActivity
     */
    omit?: EmailActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActivityInclude<ExtArgs> | null
    /**
     * Filter, which EmailActivity to fetch.
     */
    where?: EmailActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailActivities to fetch.
     */
    orderBy?: EmailActivityOrderByWithRelationInput | EmailActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailActivities.
     */
    cursor?: EmailActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailActivities.
     */
    distinct?: EmailActivityScalarFieldEnum | EmailActivityScalarFieldEnum[]
  }

  /**
   * EmailActivity findFirstOrThrow
   */
  export type EmailActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActivity
     */
    select?: EmailActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActivity
     */
    omit?: EmailActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActivityInclude<ExtArgs> | null
    /**
     * Filter, which EmailActivity to fetch.
     */
    where?: EmailActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailActivities to fetch.
     */
    orderBy?: EmailActivityOrderByWithRelationInput | EmailActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailActivities.
     */
    cursor?: EmailActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailActivities.
     */
    distinct?: EmailActivityScalarFieldEnum | EmailActivityScalarFieldEnum[]
  }

  /**
   * EmailActivity findMany
   */
  export type EmailActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActivity
     */
    select?: EmailActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActivity
     */
    omit?: EmailActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActivityInclude<ExtArgs> | null
    /**
     * Filter, which EmailActivities to fetch.
     */
    where?: EmailActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailActivities to fetch.
     */
    orderBy?: EmailActivityOrderByWithRelationInput | EmailActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailActivities.
     */
    cursor?: EmailActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailActivities.
     */
    skip?: number
    distinct?: EmailActivityScalarFieldEnum | EmailActivityScalarFieldEnum[]
  }

  /**
   * EmailActivity create
   */
  export type EmailActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActivity
     */
    select?: EmailActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActivity
     */
    omit?: EmailActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailActivity.
     */
    data: XOR<EmailActivityCreateInput, EmailActivityUncheckedCreateInput>
  }

  /**
   * EmailActivity createMany
   */
  export type EmailActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailActivities.
     */
    data: EmailActivityCreateManyInput | EmailActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailActivity createManyAndReturn
   */
  export type EmailActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActivity
     */
    select?: EmailActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActivity
     */
    omit?: EmailActivityOmit<ExtArgs> | null
    /**
     * The data used to create many EmailActivities.
     */
    data: EmailActivityCreateManyInput | EmailActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailActivity update
   */
  export type EmailActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActivity
     */
    select?: EmailActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActivity
     */
    omit?: EmailActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailActivity.
     */
    data: XOR<EmailActivityUpdateInput, EmailActivityUncheckedUpdateInput>
    /**
     * Choose, which EmailActivity to update.
     */
    where: EmailActivityWhereUniqueInput
  }

  /**
   * EmailActivity updateMany
   */
  export type EmailActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailActivities.
     */
    data: XOR<EmailActivityUpdateManyMutationInput, EmailActivityUncheckedUpdateManyInput>
    /**
     * Filter which EmailActivities to update
     */
    where?: EmailActivityWhereInput
    /**
     * Limit how many EmailActivities to update.
     */
    limit?: number
  }

  /**
   * EmailActivity updateManyAndReturn
   */
  export type EmailActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActivity
     */
    select?: EmailActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActivity
     */
    omit?: EmailActivityOmit<ExtArgs> | null
    /**
     * The data used to update EmailActivities.
     */
    data: XOR<EmailActivityUpdateManyMutationInput, EmailActivityUncheckedUpdateManyInput>
    /**
     * Filter which EmailActivities to update
     */
    where?: EmailActivityWhereInput
    /**
     * Limit how many EmailActivities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailActivity upsert
   */
  export type EmailActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActivity
     */
    select?: EmailActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActivity
     */
    omit?: EmailActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailActivity to update in case it exists.
     */
    where: EmailActivityWhereUniqueInput
    /**
     * In case the EmailActivity found by the `where` argument doesn't exist, create a new EmailActivity with this data.
     */
    create: XOR<EmailActivityCreateInput, EmailActivityUncheckedCreateInput>
    /**
     * In case the EmailActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailActivityUpdateInput, EmailActivityUncheckedUpdateInput>
  }

  /**
   * EmailActivity delete
   */
  export type EmailActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActivity
     */
    select?: EmailActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActivity
     */
    omit?: EmailActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActivityInclude<ExtArgs> | null
    /**
     * Filter which EmailActivity to delete.
     */
    where: EmailActivityWhereUniqueInput
  }

  /**
   * EmailActivity deleteMany
   */
  export type EmailActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailActivities to delete
     */
    where?: EmailActivityWhereInput
    /**
     * Limit how many EmailActivities to delete.
     */
    limit?: number
  }

  /**
   * EmailActivity without action
   */
  export type EmailActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActivity
     */
    select?: EmailActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActivity
     */
    omit?: EmailActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActivityInclude<ExtArgs> | null
  }


  /**
   * Model SMSTemplate
   */

  export type AggregateSMSTemplate = {
    _count: SMSTemplateCountAggregateOutputType | null
    _min: SMSTemplateMinAggregateOutputType | null
    _max: SMSTemplateMaxAggregateOutputType | null
  }

  export type SMSTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    content: string | null
    variables: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type SMSTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    content: string | null
    variables: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type SMSTemplateCountAggregateOutputType = {
    id: number
    name: number
    content: number
    variables: number
    category: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type SMSTemplateMinAggregateInputType = {
    id?: true
    name?: true
    content?: true
    variables?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type SMSTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    content?: true
    variables?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type SMSTemplateCountAggregateInputType = {
    id?: true
    name?: true
    content?: true
    variables?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type SMSTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SMSTemplate to aggregate.
     */
    where?: SMSTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMSTemplates to fetch.
     */
    orderBy?: SMSTemplateOrderByWithRelationInput | SMSTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SMSTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMSTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMSTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SMSTemplates
    **/
    _count?: true | SMSTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SMSTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SMSTemplateMaxAggregateInputType
  }

  export type GetSMSTemplateAggregateType<T extends SMSTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateSMSTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSMSTemplate[P]>
      : GetScalarType<T[P], AggregateSMSTemplate[P]>
  }




  export type SMSTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SMSTemplateWhereInput
    orderBy?: SMSTemplateOrderByWithAggregationInput | SMSTemplateOrderByWithAggregationInput[]
    by: SMSTemplateScalarFieldEnum[] | SMSTemplateScalarFieldEnum
    having?: SMSTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SMSTemplateCountAggregateInputType | true
    _min?: SMSTemplateMinAggregateInputType
    _max?: SMSTemplateMaxAggregateInputType
  }

  export type SMSTemplateGroupByOutputType = {
    id: string
    name: string
    content: string
    variables: string
    category: string | null
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: SMSTemplateCountAggregateOutputType | null
    _min: SMSTemplateMinAggregateOutputType | null
    _max: SMSTemplateMaxAggregateOutputType | null
  }

  type GetSMSTemplateGroupByPayload<T extends SMSTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SMSTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SMSTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SMSTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], SMSTemplateGroupByOutputType[P]>
        }
      >
    >


  export type SMSTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    content?: boolean
    variables?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    campaigns?: boolean | SMSTemplate$campaignsArgs<ExtArgs>
    _count?: boolean | SMSTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sMSTemplate"]>

  export type SMSTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    content?: boolean
    variables?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sMSTemplate"]>

  export type SMSTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    content?: boolean
    variables?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sMSTemplate"]>

  export type SMSTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    content?: boolean
    variables?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type SMSTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "content" | "variables" | "category" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["sMSTemplate"]>
  export type SMSTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    campaigns?: boolean | SMSTemplate$campaignsArgs<ExtArgs>
    _count?: boolean | SMSTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SMSTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SMSTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SMSTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SMSTemplate"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      campaigns: Prisma.$SMSCampaignPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      content: string
      variables: string
      category: string | null
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["sMSTemplate"]>
    composites: {}
  }

  type SMSTemplateGetPayload<S extends boolean | null | undefined | SMSTemplateDefaultArgs> = $Result.GetResult<Prisma.$SMSTemplatePayload, S>

  type SMSTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SMSTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SMSTemplateCountAggregateInputType | true
    }

  export interface SMSTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SMSTemplate'], meta: { name: 'SMSTemplate' } }
    /**
     * Find zero or one SMSTemplate that matches the filter.
     * @param {SMSTemplateFindUniqueArgs} args - Arguments to find a SMSTemplate
     * @example
     * // Get one SMSTemplate
     * const sMSTemplate = await prisma.sMSTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SMSTemplateFindUniqueArgs>(args: SelectSubset<T, SMSTemplateFindUniqueArgs<ExtArgs>>): Prisma__SMSTemplateClient<$Result.GetResult<Prisma.$SMSTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SMSTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SMSTemplateFindUniqueOrThrowArgs} args - Arguments to find a SMSTemplate
     * @example
     * // Get one SMSTemplate
     * const sMSTemplate = await prisma.sMSTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SMSTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, SMSTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SMSTemplateClient<$Result.GetResult<Prisma.$SMSTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SMSTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMSTemplateFindFirstArgs} args - Arguments to find a SMSTemplate
     * @example
     * // Get one SMSTemplate
     * const sMSTemplate = await prisma.sMSTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SMSTemplateFindFirstArgs>(args?: SelectSubset<T, SMSTemplateFindFirstArgs<ExtArgs>>): Prisma__SMSTemplateClient<$Result.GetResult<Prisma.$SMSTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SMSTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMSTemplateFindFirstOrThrowArgs} args - Arguments to find a SMSTemplate
     * @example
     * // Get one SMSTemplate
     * const sMSTemplate = await prisma.sMSTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SMSTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, SMSTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__SMSTemplateClient<$Result.GetResult<Prisma.$SMSTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SMSTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMSTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SMSTemplates
     * const sMSTemplates = await prisma.sMSTemplate.findMany()
     * 
     * // Get first 10 SMSTemplates
     * const sMSTemplates = await prisma.sMSTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sMSTemplateWithIdOnly = await prisma.sMSTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SMSTemplateFindManyArgs>(args?: SelectSubset<T, SMSTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMSTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SMSTemplate.
     * @param {SMSTemplateCreateArgs} args - Arguments to create a SMSTemplate.
     * @example
     * // Create one SMSTemplate
     * const SMSTemplate = await prisma.sMSTemplate.create({
     *   data: {
     *     // ... data to create a SMSTemplate
     *   }
     * })
     * 
     */
    create<T extends SMSTemplateCreateArgs>(args: SelectSubset<T, SMSTemplateCreateArgs<ExtArgs>>): Prisma__SMSTemplateClient<$Result.GetResult<Prisma.$SMSTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SMSTemplates.
     * @param {SMSTemplateCreateManyArgs} args - Arguments to create many SMSTemplates.
     * @example
     * // Create many SMSTemplates
     * const sMSTemplate = await prisma.sMSTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SMSTemplateCreateManyArgs>(args?: SelectSubset<T, SMSTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SMSTemplates and returns the data saved in the database.
     * @param {SMSTemplateCreateManyAndReturnArgs} args - Arguments to create many SMSTemplates.
     * @example
     * // Create many SMSTemplates
     * const sMSTemplate = await prisma.sMSTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SMSTemplates and only return the `id`
     * const sMSTemplateWithIdOnly = await prisma.sMSTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SMSTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, SMSTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMSTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SMSTemplate.
     * @param {SMSTemplateDeleteArgs} args - Arguments to delete one SMSTemplate.
     * @example
     * // Delete one SMSTemplate
     * const SMSTemplate = await prisma.sMSTemplate.delete({
     *   where: {
     *     // ... filter to delete one SMSTemplate
     *   }
     * })
     * 
     */
    delete<T extends SMSTemplateDeleteArgs>(args: SelectSubset<T, SMSTemplateDeleteArgs<ExtArgs>>): Prisma__SMSTemplateClient<$Result.GetResult<Prisma.$SMSTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SMSTemplate.
     * @param {SMSTemplateUpdateArgs} args - Arguments to update one SMSTemplate.
     * @example
     * // Update one SMSTemplate
     * const sMSTemplate = await prisma.sMSTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SMSTemplateUpdateArgs>(args: SelectSubset<T, SMSTemplateUpdateArgs<ExtArgs>>): Prisma__SMSTemplateClient<$Result.GetResult<Prisma.$SMSTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SMSTemplates.
     * @param {SMSTemplateDeleteManyArgs} args - Arguments to filter SMSTemplates to delete.
     * @example
     * // Delete a few SMSTemplates
     * const { count } = await prisma.sMSTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SMSTemplateDeleteManyArgs>(args?: SelectSubset<T, SMSTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SMSTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMSTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SMSTemplates
     * const sMSTemplate = await prisma.sMSTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SMSTemplateUpdateManyArgs>(args: SelectSubset<T, SMSTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SMSTemplates and returns the data updated in the database.
     * @param {SMSTemplateUpdateManyAndReturnArgs} args - Arguments to update many SMSTemplates.
     * @example
     * // Update many SMSTemplates
     * const sMSTemplate = await prisma.sMSTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SMSTemplates and only return the `id`
     * const sMSTemplateWithIdOnly = await prisma.sMSTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SMSTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, SMSTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMSTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SMSTemplate.
     * @param {SMSTemplateUpsertArgs} args - Arguments to update or create a SMSTemplate.
     * @example
     * // Update or create a SMSTemplate
     * const sMSTemplate = await prisma.sMSTemplate.upsert({
     *   create: {
     *     // ... data to create a SMSTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SMSTemplate we want to update
     *   }
     * })
     */
    upsert<T extends SMSTemplateUpsertArgs>(args: SelectSubset<T, SMSTemplateUpsertArgs<ExtArgs>>): Prisma__SMSTemplateClient<$Result.GetResult<Prisma.$SMSTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SMSTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMSTemplateCountArgs} args - Arguments to filter SMSTemplates to count.
     * @example
     * // Count the number of SMSTemplates
     * const count = await prisma.sMSTemplate.count({
     *   where: {
     *     // ... the filter for the SMSTemplates we want to count
     *   }
     * })
    **/
    count<T extends SMSTemplateCountArgs>(
      args?: Subset<T, SMSTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SMSTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SMSTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMSTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SMSTemplateAggregateArgs>(args: Subset<T, SMSTemplateAggregateArgs>): Prisma.PrismaPromise<GetSMSTemplateAggregateType<T>>

    /**
     * Group by SMSTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMSTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SMSTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SMSTemplateGroupByArgs['orderBy'] }
        : { orderBy?: SMSTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SMSTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSMSTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SMSTemplate model
   */
  readonly fields: SMSTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SMSTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SMSTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campaigns<T extends SMSTemplate$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, SMSTemplate$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMSCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SMSTemplate model
   */
  interface SMSTemplateFieldRefs {
    readonly id: FieldRef<"SMSTemplate", 'String'>
    readonly name: FieldRef<"SMSTemplate", 'String'>
    readonly content: FieldRef<"SMSTemplate", 'String'>
    readonly variables: FieldRef<"SMSTemplate", 'String'>
    readonly category: FieldRef<"SMSTemplate", 'String'>
    readonly createdAt: FieldRef<"SMSTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"SMSTemplate", 'DateTime'>
    readonly createdById: FieldRef<"SMSTemplate", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SMSTemplate findUnique
   */
  export type SMSTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSTemplate
     */
    select?: SMSTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSTemplate
     */
    omit?: SMSTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSTemplateInclude<ExtArgs> | null
    /**
     * Filter, which SMSTemplate to fetch.
     */
    where: SMSTemplateWhereUniqueInput
  }

  /**
   * SMSTemplate findUniqueOrThrow
   */
  export type SMSTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSTemplate
     */
    select?: SMSTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSTemplate
     */
    omit?: SMSTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSTemplateInclude<ExtArgs> | null
    /**
     * Filter, which SMSTemplate to fetch.
     */
    where: SMSTemplateWhereUniqueInput
  }

  /**
   * SMSTemplate findFirst
   */
  export type SMSTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSTemplate
     */
    select?: SMSTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSTemplate
     */
    omit?: SMSTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSTemplateInclude<ExtArgs> | null
    /**
     * Filter, which SMSTemplate to fetch.
     */
    where?: SMSTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMSTemplates to fetch.
     */
    orderBy?: SMSTemplateOrderByWithRelationInput | SMSTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SMSTemplates.
     */
    cursor?: SMSTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMSTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMSTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SMSTemplates.
     */
    distinct?: SMSTemplateScalarFieldEnum | SMSTemplateScalarFieldEnum[]
  }

  /**
   * SMSTemplate findFirstOrThrow
   */
  export type SMSTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSTemplate
     */
    select?: SMSTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSTemplate
     */
    omit?: SMSTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSTemplateInclude<ExtArgs> | null
    /**
     * Filter, which SMSTemplate to fetch.
     */
    where?: SMSTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMSTemplates to fetch.
     */
    orderBy?: SMSTemplateOrderByWithRelationInput | SMSTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SMSTemplates.
     */
    cursor?: SMSTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMSTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMSTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SMSTemplates.
     */
    distinct?: SMSTemplateScalarFieldEnum | SMSTemplateScalarFieldEnum[]
  }

  /**
   * SMSTemplate findMany
   */
  export type SMSTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSTemplate
     */
    select?: SMSTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSTemplate
     */
    omit?: SMSTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSTemplateInclude<ExtArgs> | null
    /**
     * Filter, which SMSTemplates to fetch.
     */
    where?: SMSTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMSTemplates to fetch.
     */
    orderBy?: SMSTemplateOrderByWithRelationInput | SMSTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SMSTemplates.
     */
    cursor?: SMSTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMSTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMSTemplates.
     */
    skip?: number
    distinct?: SMSTemplateScalarFieldEnum | SMSTemplateScalarFieldEnum[]
  }

  /**
   * SMSTemplate create
   */
  export type SMSTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSTemplate
     */
    select?: SMSTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSTemplate
     */
    omit?: SMSTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a SMSTemplate.
     */
    data: XOR<SMSTemplateCreateInput, SMSTemplateUncheckedCreateInput>
  }

  /**
   * SMSTemplate createMany
   */
  export type SMSTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SMSTemplates.
     */
    data: SMSTemplateCreateManyInput | SMSTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SMSTemplate createManyAndReturn
   */
  export type SMSTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSTemplate
     */
    select?: SMSTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SMSTemplate
     */
    omit?: SMSTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many SMSTemplates.
     */
    data: SMSTemplateCreateManyInput | SMSTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SMSTemplate update
   */
  export type SMSTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSTemplate
     */
    select?: SMSTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSTemplate
     */
    omit?: SMSTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a SMSTemplate.
     */
    data: XOR<SMSTemplateUpdateInput, SMSTemplateUncheckedUpdateInput>
    /**
     * Choose, which SMSTemplate to update.
     */
    where: SMSTemplateWhereUniqueInput
  }

  /**
   * SMSTemplate updateMany
   */
  export type SMSTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SMSTemplates.
     */
    data: XOR<SMSTemplateUpdateManyMutationInput, SMSTemplateUncheckedUpdateManyInput>
    /**
     * Filter which SMSTemplates to update
     */
    where?: SMSTemplateWhereInput
    /**
     * Limit how many SMSTemplates to update.
     */
    limit?: number
  }

  /**
   * SMSTemplate updateManyAndReturn
   */
  export type SMSTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSTemplate
     */
    select?: SMSTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SMSTemplate
     */
    omit?: SMSTemplateOmit<ExtArgs> | null
    /**
     * The data used to update SMSTemplates.
     */
    data: XOR<SMSTemplateUpdateManyMutationInput, SMSTemplateUncheckedUpdateManyInput>
    /**
     * Filter which SMSTemplates to update
     */
    where?: SMSTemplateWhereInput
    /**
     * Limit how many SMSTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SMSTemplate upsert
   */
  export type SMSTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSTemplate
     */
    select?: SMSTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSTemplate
     */
    omit?: SMSTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the SMSTemplate to update in case it exists.
     */
    where: SMSTemplateWhereUniqueInput
    /**
     * In case the SMSTemplate found by the `where` argument doesn't exist, create a new SMSTemplate with this data.
     */
    create: XOR<SMSTemplateCreateInput, SMSTemplateUncheckedCreateInput>
    /**
     * In case the SMSTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SMSTemplateUpdateInput, SMSTemplateUncheckedUpdateInput>
  }

  /**
   * SMSTemplate delete
   */
  export type SMSTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSTemplate
     */
    select?: SMSTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSTemplate
     */
    omit?: SMSTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSTemplateInclude<ExtArgs> | null
    /**
     * Filter which SMSTemplate to delete.
     */
    where: SMSTemplateWhereUniqueInput
  }

  /**
   * SMSTemplate deleteMany
   */
  export type SMSTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SMSTemplates to delete
     */
    where?: SMSTemplateWhereInput
    /**
     * Limit how many SMSTemplates to delete.
     */
    limit?: number
  }

  /**
   * SMSTemplate.campaigns
   */
  export type SMSTemplate$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSCampaign
     */
    select?: SMSCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSCampaign
     */
    omit?: SMSCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSCampaignInclude<ExtArgs> | null
    where?: SMSCampaignWhereInput
    orderBy?: SMSCampaignOrderByWithRelationInput | SMSCampaignOrderByWithRelationInput[]
    cursor?: SMSCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SMSCampaignScalarFieldEnum | SMSCampaignScalarFieldEnum[]
  }

  /**
   * SMSTemplate without action
   */
  export type SMSTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSTemplate
     */
    select?: SMSTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSTemplate
     */
    omit?: SMSTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSTemplateInclude<ExtArgs> | null
  }


  /**
   * Model SMSCampaign
   */

  export type AggregateSMSCampaign = {
    _count: SMSCampaignCountAggregateOutputType | null
    _min: SMSCampaignMinAggregateOutputType | null
    _max: SMSCampaignMaxAggregateOutputType | null
  }

  export type SMSCampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    from: string | null
    templateId: string | null
    content: string | null
    status: $Enums.CampaignStatus | null
    scheduledFor: Date | null
    sentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type SMSCampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    from: string | null
    templateId: string | null
    content: string | null
    status: $Enums.CampaignStatus | null
    scheduledFor: Date | null
    sentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type SMSCampaignCountAggregateOutputType = {
    id: number
    name: number
    description: number
    from: number
    templateId: number
    content: number
    status: number
    scheduledFor: number
    sentAt: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type SMSCampaignMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    from?: true
    templateId?: true
    content?: true
    status?: true
    scheduledFor?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type SMSCampaignMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    from?: true
    templateId?: true
    content?: true
    status?: true
    scheduledFor?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type SMSCampaignCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    from?: true
    templateId?: true
    content?: true
    status?: true
    scheduledFor?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type SMSCampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SMSCampaign to aggregate.
     */
    where?: SMSCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMSCampaigns to fetch.
     */
    orderBy?: SMSCampaignOrderByWithRelationInput | SMSCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SMSCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMSCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMSCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SMSCampaigns
    **/
    _count?: true | SMSCampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SMSCampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SMSCampaignMaxAggregateInputType
  }

  export type GetSMSCampaignAggregateType<T extends SMSCampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateSMSCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSMSCampaign[P]>
      : GetScalarType<T[P], AggregateSMSCampaign[P]>
  }




  export type SMSCampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SMSCampaignWhereInput
    orderBy?: SMSCampaignOrderByWithAggregationInput | SMSCampaignOrderByWithAggregationInput[]
    by: SMSCampaignScalarFieldEnum[] | SMSCampaignScalarFieldEnum
    having?: SMSCampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SMSCampaignCountAggregateInputType | true
    _min?: SMSCampaignMinAggregateInputType
    _max?: SMSCampaignMaxAggregateInputType
  }

  export type SMSCampaignGroupByOutputType = {
    id: string
    name: string
    description: string | null
    from: string
    templateId: string | null
    content: string | null
    status: $Enums.CampaignStatus
    scheduledFor: Date | null
    sentAt: Date | null
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: SMSCampaignCountAggregateOutputType | null
    _min: SMSCampaignMinAggregateOutputType | null
    _max: SMSCampaignMaxAggregateOutputType | null
  }

  type GetSMSCampaignGroupByPayload<T extends SMSCampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SMSCampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SMSCampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SMSCampaignGroupByOutputType[P]>
            : GetScalarType<T[P], SMSCampaignGroupByOutputType[P]>
        }
      >
    >


  export type SMSCampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    from?: boolean
    templateId?: boolean
    content?: boolean
    status?: boolean
    scheduledFor?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | SMSCampaign$templateArgs<ExtArgs>
    lists?: boolean | SMSCampaign$listsArgs<ExtArgs>
    segments?: boolean | SMSCampaign$segmentsArgs<ExtArgs>
    activities?: boolean | SMSCampaign$activitiesArgs<ExtArgs>
    _count?: boolean | SMSCampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sMSCampaign"]>

  export type SMSCampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    from?: boolean
    templateId?: boolean
    content?: boolean
    status?: boolean
    scheduledFor?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | SMSCampaign$templateArgs<ExtArgs>
  }, ExtArgs["result"]["sMSCampaign"]>

  export type SMSCampaignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    from?: boolean
    templateId?: boolean
    content?: boolean
    status?: boolean
    scheduledFor?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | SMSCampaign$templateArgs<ExtArgs>
  }, ExtArgs["result"]["sMSCampaign"]>

  export type SMSCampaignSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    from?: boolean
    templateId?: boolean
    content?: boolean
    status?: boolean
    scheduledFor?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type SMSCampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "from" | "templateId" | "content" | "status" | "scheduledFor" | "sentAt" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["sMSCampaign"]>
  export type SMSCampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | SMSCampaign$templateArgs<ExtArgs>
    lists?: boolean | SMSCampaign$listsArgs<ExtArgs>
    segments?: boolean | SMSCampaign$segmentsArgs<ExtArgs>
    activities?: boolean | SMSCampaign$activitiesArgs<ExtArgs>
    _count?: boolean | SMSCampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SMSCampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | SMSCampaign$templateArgs<ExtArgs>
  }
  export type SMSCampaignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | SMSCampaign$templateArgs<ExtArgs>
  }

  export type $SMSCampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SMSCampaign"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      template: Prisma.$SMSTemplatePayload<ExtArgs> | null
      lists: Prisma.$ListPayload<ExtArgs>[]
      segments: Prisma.$SegmentPayload<ExtArgs>[]
      activities: Prisma.$SMSActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      from: string
      templateId: string | null
      content: string | null
      status: $Enums.CampaignStatus
      scheduledFor: Date | null
      sentAt: Date | null
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["sMSCampaign"]>
    composites: {}
  }

  type SMSCampaignGetPayload<S extends boolean | null | undefined | SMSCampaignDefaultArgs> = $Result.GetResult<Prisma.$SMSCampaignPayload, S>

  type SMSCampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SMSCampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SMSCampaignCountAggregateInputType | true
    }

  export interface SMSCampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SMSCampaign'], meta: { name: 'SMSCampaign' } }
    /**
     * Find zero or one SMSCampaign that matches the filter.
     * @param {SMSCampaignFindUniqueArgs} args - Arguments to find a SMSCampaign
     * @example
     * // Get one SMSCampaign
     * const sMSCampaign = await prisma.sMSCampaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SMSCampaignFindUniqueArgs>(args: SelectSubset<T, SMSCampaignFindUniqueArgs<ExtArgs>>): Prisma__SMSCampaignClient<$Result.GetResult<Prisma.$SMSCampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SMSCampaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SMSCampaignFindUniqueOrThrowArgs} args - Arguments to find a SMSCampaign
     * @example
     * // Get one SMSCampaign
     * const sMSCampaign = await prisma.sMSCampaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SMSCampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, SMSCampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SMSCampaignClient<$Result.GetResult<Prisma.$SMSCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SMSCampaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMSCampaignFindFirstArgs} args - Arguments to find a SMSCampaign
     * @example
     * // Get one SMSCampaign
     * const sMSCampaign = await prisma.sMSCampaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SMSCampaignFindFirstArgs>(args?: SelectSubset<T, SMSCampaignFindFirstArgs<ExtArgs>>): Prisma__SMSCampaignClient<$Result.GetResult<Prisma.$SMSCampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SMSCampaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMSCampaignFindFirstOrThrowArgs} args - Arguments to find a SMSCampaign
     * @example
     * // Get one SMSCampaign
     * const sMSCampaign = await prisma.sMSCampaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SMSCampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, SMSCampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__SMSCampaignClient<$Result.GetResult<Prisma.$SMSCampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SMSCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMSCampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SMSCampaigns
     * const sMSCampaigns = await prisma.sMSCampaign.findMany()
     * 
     * // Get first 10 SMSCampaigns
     * const sMSCampaigns = await prisma.sMSCampaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sMSCampaignWithIdOnly = await prisma.sMSCampaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SMSCampaignFindManyArgs>(args?: SelectSubset<T, SMSCampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMSCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SMSCampaign.
     * @param {SMSCampaignCreateArgs} args - Arguments to create a SMSCampaign.
     * @example
     * // Create one SMSCampaign
     * const SMSCampaign = await prisma.sMSCampaign.create({
     *   data: {
     *     // ... data to create a SMSCampaign
     *   }
     * })
     * 
     */
    create<T extends SMSCampaignCreateArgs>(args: SelectSubset<T, SMSCampaignCreateArgs<ExtArgs>>): Prisma__SMSCampaignClient<$Result.GetResult<Prisma.$SMSCampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SMSCampaigns.
     * @param {SMSCampaignCreateManyArgs} args - Arguments to create many SMSCampaigns.
     * @example
     * // Create many SMSCampaigns
     * const sMSCampaign = await prisma.sMSCampaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SMSCampaignCreateManyArgs>(args?: SelectSubset<T, SMSCampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SMSCampaigns and returns the data saved in the database.
     * @param {SMSCampaignCreateManyAndReturnArgs} args - Arguments to create many SMSCampaigns.
     * @example
     * // Create many SMSCampaigns
     * const sMSCampaign = await prisma.sMSCampaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SMSCampaigns and only return the `id`
     * const sMSCampaignWithIdOnly = await prisma.sMSCampaign.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SMSCampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, SMSCampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMSCampaignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SMSCampaign.
     * @param {SMSCampaignDeleteArgs} args - Arguments to delete one SMSCampaign.
     * @example
     * // Delete one SMSCampaign
     * const SMSCampaign = await prisma.sMSCampaign.delete({
     *   where: {
     *     // ... filter to delete one SMSCampaign
     *   }
     * })
     * 
     */
    delete<T extends SMSCampaignDeleteArgs>(args: SelectSubset<T, SMSCampaignDeleteArgs<ExtArgs>>): Prisma__SMSCampaignClient<$Result.GetResult<Prisma.$SMSCampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SMSCampaign.
     * @param {SMSCampaignUpdateArgs} args - Arguments to update one SMSCampaign.
     * @example
     * // Update one SMSCampaign
     * const sMSCampaign = await prisma.sMSCampaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SMSCampaignUpdateArgs>(args: SelectSubset<T, SMSCampaignUpdateArgs<ExtArgs>>): Prisma__SMSCampaignClient<$Result.GetResult<Prisma.$SMSCampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SMSCampaigns.
     * @param {SMSCampaignDeleteManyArgs} args - Arguments to filter SMSCampaigns to delete.
     * @example
     * // Delete a few SMSCampaigns
     * const { count } = await prisma.sMSCampaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SMSCampaignDeleteManyArgs>(args?: SelectSubset<T, SMSCampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SMSCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMSCampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SMSCampaigns
     * const sMSCampaign = await prisma.sMSCampaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SMSCampaignUpdateManyArgs>(args: SelectSubset<T, SMSCampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SMSCampaigns and returns the data updated in the database.
     * @param {SMSCampaignUpdateManyAndReturnArgs} args - Arguments to update many SMSCampaigns.
     * @example
     * // Update many SMSCampaigns
     * const sMSCampaign = await prisma.sMSCampaign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SMSCampaigns and only return the `id`
     * const sMSCampaignWithIdOnly = await prisma.sMSCampaign.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SMSCampaignUpdateManyAndReturnArgs>(args: SelectSubset<T, SMSCampaignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMSCampaignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SMSCampaign.
     * @param {SMSCampaignUpsertArgs} args - Arguments to update or create a SMSCampaign.
     * @example
     * // Update or create a SMSCampaign
     * const sMSCampaign = await prisma.sMSCampaign.upsert({
     *   create: {
     *     // ... data to create a SMSCampaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SMSCampaign we want to update
     *   }
     * })
     */
    upsert<T extends SMSCampaignUpsertArgs>(args: SelectSubset<T, SMSCampaignUpsertArgs<ExtArgs>>): Prisma__SMSCampaignClient<$Result.GetResult<Prisma.$SMSCampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SMSCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMSCampaignCountArgs} args - Arguments to filter SMSCampaigns to count.
     * @example
     * // Count the number of SMSCampaigns
     * const count = await prisma.sMSCampaign.count({
     *   where: {
     *     // ... the filter for the SMSCampaigns we want to count
     *   }
     * })
    **/
    count<T extends SMSCampaignCountArgs>(
      args?: Subset<T, SMSCampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SMSCampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SMSCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMSCampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SMSCampaignAggregateArgs>(args: Subset<T, SMSCampaignAggregateArgs>): Prisma.PrismaPromise<GetSMSCampaignAggregateType<T>>

    /**
     * Group by SMSCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMSCampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SMSCampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SMSCampaignGroupByArgs['orderBy'] }
        : { orderBy?: SMSCampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SMSCampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSMSCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SMSCampaign model
   */
  readonly fields: SMSCampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SMSCampaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SMSCampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    template<T extends SMSCampaign$templateArgs<ExtArgs> = {}>(args?: Subset<T, SMSCampaign$templateArgs<ExtArgs>>): Prisma__SMSTemplateClient<$Result.GetResult<Prisma.$SMSTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lists<T extends SMSCampaign$listsArgs<ExtArgs> = {}>(args?: Subset<T, SMSCampaign$listsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    segments<T extends SMSCampaign$segmentsArgs<ExtArgs> = {}>(args?: Subset<T, SMSCampaign$segmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends SMSCampaign$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, SMSCampaign$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMSActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SMSCampaign model
   */
  interface SMSCampaignFieldRefs {
    readonly id: FieldRef<"SMSCampaign", 'String'>
    readonly name: FieldRef<"SMSCampaign", 'String'>
    readonly description: FieldRef<"SMSCampaign", 'String'>
    readonly from: FieldRef<"SMSCampaign", 'String'>
    readonly templateId: FieldRef<"SMSCampaign", 'String'>
    readonly content: FieldRef<"SMSCampaign", 'String'>
    readonly status: FieldRef<"SMSCampaign", 'CampaignStatus'>
    readonly scheduledFor: FieldRef<"SMSCampaign", 'DateTime'>
    readonly sentAt: FieldRef<"SMSCampaign", 'DateTime'>
    readonly createdAt: FieldRef<"SMSCampaign", 'DateTime'>
    readonly updatedAt: FieldRef<"SMSCampaign", 'DateTime'>
    readonly createdById: FieldRef<"SMSCampaign", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SMSCampaign findUnique
   */
  export type SMSCampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSCampaign
     */
    select?: SMSCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSCampaign
     */
    omit?: SMSCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSCampaignInclude<ExtArgs> | null
    /**
     * Filter, which SMSCampaign to fetch.
     */
    where: SMSCampaignWhereUniqueInput
  }

  /**
   * SMSCampaign findUniqueOrThrow
   */
  export type SMSCampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSCampaign
     */
    select?: SMSCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSCampaign
     */
    omit?: SMSCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSCampaignInclude<ExtArgs> | null
    /**
     * Filter, which SMSCampaign to fetch.
     */
    where: SMSCampaignWhereUniqueInput
  }

  /**
   * SMSCampaign findFirst
   */
  export type SMSCampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSCampaign
     */
    select?: SMSCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSCampaign
     */
    omit?: SMSCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSCampaignInclude<ExtArgs> | null
    /**
     * Filter, which SMSCampaign to fetch.
     */
    where?: SMSCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMSCampaigns to fetch.
     */
    orderBy?: SMSCampaignOrderByWithRelationInput | SMSCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SMSCampaigns.
     */
    cursor?: SMSCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMSCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMSCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SMSCampaigns.
     */
    distinct?: SMSCampaignScalarFieldEnum | SMSCampaignScalarFieldEnum[]
  }

  /**
   * SMSCampaign findFirstOrThrow
   */
  export type SMSCampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSCampaign
     */
    select?: SMSCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSCampaign
     */
    omit?: SMSCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSCampaignInclude<ExtArgs> | null
    /**
     * Filter, which SMSCampaign to fetch.
     */
    where?: SMSCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMSCampaigns to fetch.
     */
    orderBy?: SMSCampaignOrderByWithRelationInput | SMSCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SMSCampaigns.
     */
    cursor?: SMSCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMSCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMSCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SMSCampaigns.
     */
    distinct?: SMSCampaignScalarFieldEnum | SMSCampaignScalarFieldEnum[]
  }

  /**
   * SMSCampaign findMany
   */
  export type SMSCampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSCampaign
     */
    select?: SMSCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSCampaign
     */
    omit?: SMSCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSCampaignInclude<ExtArgs> | null
    /**
     * Filter, which SMSCampaigns to fetch.
     */
    where?: SMSCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMSCampaigns to fetch.
     */
    orderBy?: SMSCampaignOrderByWithRelationInput | SMSCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SMSCampaigns.
     */
    cursor?: SMSCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMSCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMSCampaigns.
     */
    skip?: number
    distinct?: SMSCampaignScalarFieldEnum | SMSCampaignScalarFieldEnum[]
  }

  /**
   * SMSCampaign create
   */
  export type SMSCampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSCampaign
     */
    select?: SMSCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSCampaign
     */
    omit?: SMSCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSCampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a SMSCampaign.
     */
    data: XOR<SMSCampaignCreateInput, SMSCampaignUncheckedCreateInput>
  }

  /**
   * SMSCampaign createMany
   */
  export type SMSCampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SMSCampaigns.
     */
    data: SMSCampaignCreateManyInput | SMSCampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SMSCampaign createManyAndReturn
   */
  export type SMSCampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSCampaign
     */
    select?: SMSCampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SMSCampaign
     */
    omit?: SMSCampaignOmit<ExtArgs> | null
    /**
     * The data used to create many SMSCampaigns.
     */
    data: SMSCampaignCreateManyInput | SMSCampaignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSCampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SMSCampaign update
   */
  export type SMSCampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSCampaign
     */
    select?: SMSCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSCampaign
     */
    omit?: SMSCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSCampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a SMSCampaign.
     */
    data: XOR<SMSCampaignUpdateInput, SMSCampaignUncheckedUpdateInput>
    /**
     * Choose, which SMSCampaign to update.
     */
    where: SMSCampaignWhereUniqueInput
  }

  /**
   * SMSCampaign updateMany
   */
  export type SMSCampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SMSCampaigns.
     */
    data: XOR<SMSCampaignUpdateManyMutationInput, SMSCampaignUncheckedUpdateManyInput>
    /**
     * Filter which SMSCampaigns to update
     */
    where?: SMSCampaignWhereInput
    /**
     * Limit how many SMSCampaigns to update.
     */
    limit?: number
  }

  /**
   * SMSCampaign updateManyAndReturn
   */
  export type SMSCampaignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSCampaign
     */
    select?: SMSCampaignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SMSCampaign
     */
    omit?: SMSCampaignOmit<ExtArgs> | null
    /**
     * The data used to update SMSCampaigns.
     */
    data: XOR<SMSCampaignUpdateManyMutationInput, SMSCampaignUncheckedUpdateManyInput>
    /**
     * Filter which SMSCampaigns to update
     */
    where?: SMSCampaignWhereInput
    /**
     * Limit how many SMSCampaigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSCampaignIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SMSCampaign upsert
   */
  export type SMSCampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSCampaign
     */
    select?: SMSCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSCampaign
     */
    omit?: SMSCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSCampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the SMSCampaign to update in case it exists.
     */
    where: SMSCampaignWhereUniqueInput
    /**
     * In case the SMSCampaign found by the `where` argument doesn't exist, create a new SMSCampaign with this data.
     */
    create: XOR<SMSCampaignCreateInput, SMSCampaignUncheckedCreateInput>
    /**
     * In case the SMSCampaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SMSCampaignUpdateInput, SMSCampaignUncheckedUpdateInput>
  }

  /**
   * SMSCampaign delete
   */
  export type SMSCampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSCampaign
     */
    select?: SMSCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSCampaign
     */
    omit?: SMSCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSCampaignInclude<ExtArgs> | null
    /**
     * Filter which SMSCampaign to delete.
     */
    where: SMSCampaignWhereUniqueInput
  }

  /**
   * SMSCampaign deleteMany
   */
  export type SMSCampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SMSCampaigns to delete
     */
    where?: SMSCampaignWhereInput
    /**
     * Limit how many SMSCampaigns to delete.
     */
    limit?: number
  }

  /**
   * SMSCampaign.template
   */
  export type SMSCampaign$templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSTemplate
     */
    select?: SMSTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSTemplate
     */
    omit?: SMSTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSTemplateInclude<ExtArgs> | null
    where?: SMSTemplateWhereInput
  }

  /**
   * SMSCampaign.lists
   */
  export type SMSCampaign$listsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    where?: ListWhereInput
    orderBy?: ListOrderByWithRelationInput | ListOrderByWithRelationInput[]
    cursor?: ListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListScalarFieldEnum | ListScalarFieldEnum[]
  }

  /**
   * SMSCampaign.segments
   */
  export type SMSCampaign$segmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    where?: SegmentWhereInput
    orderBy?: SegmentOrderByWithRelationInput | SegmentOrderByWithRelationInput[]
    cursor?: SegmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SegmentScalarFieldEnum | SegmentScalarFieldEnum[]
  }

  /**
   * SMSCampaign.activities
   */
  export type SMSCampaign$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSActivity
     */
    select?: SMSActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSActivity
     */
    omit?: SMSActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSActivityInclude<ExtArgs> | null
    where?: SMSActivityWhereInput
    orderBy?: SMSActivityOrderByWithRelationInput | SMSActivityOrderByWithRelationInput[]
    cursor?: SMSActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SMSActivityScalarFieldEnum | SMSActivityScalarFieldEnum[]
  }

  /**
   * SMSCampaign without action
   */
  export type SMSCampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSCampaign
     */
    select?: SMSCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSCampaign
     */
    omit?: SMSCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSCampaignInclude<ExtArgs> | null
  }


  /**
   * Model SMSActivity
   */

  export type AggregateSMSActivity = {
    _count: SMSActivityCountAggregateOutputType | null
    _min: SMSActivityMinAggregateOutputType | null
    _max: SMSActivityMaxAggregateOutputType | null
  }

  export type SMSActivityMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    contactId: string | null
    type: $Enums.ActivityType | null
    timestamp: Date | null
    metadata: string | null
  }

  export type SMSActivityMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    contactId: string | null
    type: $Enums.ActivityType | null
    timestamp: Date | null
    metadata: string | null
  }

  export type SMSActivityCountAggregateOutputType = {
    id: number
    campaignId: number
    contactId: number
    type: number
    timestamp: number
    metadata: number
    _all: number
  }


  export type SMSActivityMinAggregateInputType = {
    id?: true
    campaignId?: true
    contactId?: true
    type?: true
    timestamp?: true
    metadata?: true
  }

  export type SMSActivityMaxAggregateInputType = {
    id?: true
    campaignId?: true
    contactId?: true
    type?: true
    timestamp?: true
    metadata?: true
  }

  export type SMSActivityCountAggregateInputType = {
    id?: true
    campaignId?: true
    contactId?: true
    type?: true
    timestamp?: true
    metadata?: true
    _all?: true
  }

  export type SMSActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SMSActivity to aggregate.
     */
    where?: SMSActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMSActivities to fetch.
     */
    orderBy?: SMSActivityOrderByWithRelationInput | SMSActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SMSActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMSActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMSActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SMSActivities
    **/
    _count?: true | SMSActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SMSActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SMSActivityMaxAggregateInputType
  }

  export type GetSMSActivityAggregateType<T extends SMSActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateSMSActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSMSActivity[P]>
      : GetScalarType<T[P], AggregateSMSActivity[P]>
  }




  export type SMSActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SMSActivityWhereInput
    orderBy?: SMSActivityOrderByWithAggregationInput | SMSActivityOrderByWithAggregationInput[]
    by: SMSActivityScalarFieldEnum[] | SMSActivityScalarFieldEnum
    having?: SMSActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SMSActivityCountAggregateInputType | true
    _min?: SMSActivityMinAggregateInputType
    _max?: SMSActivityMaxAggregateInputType
  }

  export type SMSActivityGroupByOutputType = {
    id: string
    campaignId: string
    contactId: string
    type: $Enums.ActivityType
    timestamp: Date
    metadata: string | null
    _count: SMSActivityCountAggregateOutputType | null
    _min: SMSActivityMinAggregateOutputType | null
    _max: SMSActivityMaxAggregateOutputType | null
  }

  type GetSMSActivityGroupByPayload<T extends SMSActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SMSActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SMSActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SMSActivityGroupByOutputType[P]>
            : GetScalarType<T[P], SMSActivityGroupByOutputType[P]>
        }
      >
    >


  export type SMSActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    contactId?: boolean
    type?: boolean
    timestamp?: boolean
    metadata?: boolean
    campaign?: boolean | SMSCampaignDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sMSActivity"]>

  export type SMSActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    contactId?: boolean
    type?: boolean
    timestamp?: boolean
    metadata?: boolean
    campaign?: boolean | SMSCampaignDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sMSActivity"]>

  export type SMSActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    contactId?: boolean
    type?: boolean
    timestamp?: boolean
    metadata?: boolean
    campaign?: boolean | SMSCampaignDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sMSActivity"]>

  export type SMSActivitySelectScalar = {
    id?: boolean
    campaignId?: boolean
    contactId?: boolean
    type?: boolean
    timestamp?: boolean
    metadata?: boolean
  }

  export type SMSActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaignId" | "contactId" | "type" | "timestamp" | "metadata", ExtArgs["result"]["sMSActivity"]>
  export type SMSActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | SMSCampaignDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }
  export type SMSActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | SMSCampaignDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }
  export type SMSActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | SMSCampaignDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }

  export type $SMSActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SMSActivity"
    objects: {
      campaign: Prisma.$SMSCampaignPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      contactId: string
      type: $Enums.ActivityType
      timestamp: Date
      metadata: string | null
    }, ExtArgs["result"]["sMSActivity"]>
    composites: {}
  }

  type SMSActivityGetPayload<S extends boolean | null | undefined | SMSActivityDefaultArgs> = $Result.GetResult<Prisma.$SMSActivityPayload, S>

  type SMSActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SMSActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SMSActivityCountAggregateInputType | true
    }

  export interface SMSActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SMSActivity'], meta: { name: 'SMSActivity' } }
    /**
     * Find zero or one SMSActivity that matches the filter.
     * @param {SMSActivityFindUniqueArgs} args - Arguments to find a SMSActivity
     * @example
     * // Get one SMSActivity
     * const sMSActivity = await prisma.sMSActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SMSActivityFindUniqueArgs>(args: SelectSubset<T, SMSActivityFindUniqueArgs<ExtArgs>>): Prisma__SMSActivityClient<$Result.GetResult<Prisma.$SMSActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SMSActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SMSActivityFindUniqueOrThrowArgs} args - Arguments to find a SMSActivity
     * @example
     * // Get one SMSActivity
     * const sMSActivity = await prisma.sMSActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SMSActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, SMSActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SMSActivityClient<$Result.GetResult<Prisma.$SMSActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SMSActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMSActivityFindFirstArgs} args - Arguments to find a SMSActivity
     * @example
     * // Get one SMSActivity
     * const sMSActivity = await prisma.sMSActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SMSActivityFindFirstArgs>(args?: SelectSubset<T, SMSActivityFindFirstArgs<ExtArgs>>): Prisma__SMSActivityClient<$Result.GetResult<Prisma.$SMSActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SMSActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMSActivityFindFirstOrThrowArgs} args - Arguments to find a SMSActivity
     * @example
     * // Get one SMSActivity
     * const sMSActivity = await prisma.sMSActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SMSActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, SMSActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__SMSActivityClient<$Result.GetResult<Prisma.$SMSActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SMSActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMSActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SMSActivities
     * const sMSActivities = await prisma.sMSActivity.findMany()
     * 
     * // Get first 10 SMSActivities
     * const sMSActivities = await prisma.sMSActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sMSActivityWithIdOnly = await prisma.sMSActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SMSActivityFindManyArgs>(args?: SelectSubset<T, SMSActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMSActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SMSActivity.
     * @param {SMSActivityCreateArgs} args - Arguments to create a SMSActivity.
     * @example
     * // Create one SMSActivity
     * const SMSActivity = await prisma.sMSActivity.create({
     *   data: {
     *     // ... data to create a SMSActivity
     *   }
     * })
     * 
     */
    create<T extends SMSActivityCreateArgs>(args: SelectSubset<T, SMSActivityCreateArgs<ExtArgs>>): Prisma__SMSActivityClient<$Result.GetResult<Prisma.$SMSActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SMSActivities.
     * @param {SMSActivityCreateManyArgs} args - Arguments to create many SMSActivities.
     * @example
     * // Create many SMSActivities
     * const sMSActivity = await prisma.sMSActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SMSActivityCreateManyArgs>(args?: SelectSubset<T, SMSActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SMSActivities and returns the data saved in the database.
     * @param {SMSActivityCreateManyAndReturnArgs} args - Arguments to create many SMSActivities.
     * @example
     * // Create many SMSActivities
     * const sMSActivity = await prisma.sMSActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SMSActivities and only return the `id`
     * const sMSActivityWithIdOnly = await prisma.sMSActivity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SMSActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, SMSActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMSActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SMSActivity.
     * @param {SMSActivityDeleteArgs} args - Arguments to delete one SMSActivity.
     * @example
     * // Delete one SMSActivity
     * const SMSActivity = await prisma.sMSActivity.delete({
     *   where: {
     *     // ... filter to delete one SMSActivity
     *   }
     * })
     * 
     */
    delete<T extends SMSActivityDeleteArgs>(args: SelectSubset<T, SMSActivityDeleteArgs<ExtArgs>>): Prisma__SMSActivityClient<$Result.GetResult<Prisma.$SMSActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SMSActivity.
     * @param {SMSActivityUpdateArgs} args - Arguments to update one SMSActivity.
     * @example
     * // Update one SMSActivity
     * const sMSActivity = await prisma.sMSActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SMSActivityUpdateArgs>(args: SelectSubset<T, SMSActivityUpdateArgs<ExtArgs>>): Prisma__SMSActivityClient<$Result.GetResult<Prisma.$SMSActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SMSActivities.
     * @param {SMSActivityDeleteManyArgs} args - Arguments to filter SMSActivities to delete.
     * @example
     * // Delete a few SMSActivities
     * const { count } = await prisma.sMSActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SMSActivityDeleteManyArgs>(args?: SelectSubset<T, SMSActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SMSActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMSActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SMSActivities
     * const sMSActivity = await prisma.sMSActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SMSActivityUpdateManyArgs>(args: SelectSubset<T, SMSActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SMSActivities and returns the data updated in the database.
     * @param {SMSActivityUpdateManyAndReturnArgs} args - Arguments to update many SMSActivities.
     * @example
     * // Update many SMSActivities
     * const sMSActivity = await prisma.sMSActivity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SMSActivities and only return the `id`
     * const sMSActivityWithIdOnly = await prisma.sMSActivity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SMSActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, SMSActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMSActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SMSActivity.
     * @param {SMSActivityUpsertArgs} args - Arguments to update or create a SMSActivity.
     * @example
     * // Update or create a SMSActivity
     * const sMSActivity = await prisma.sMSActivity.upsert({
     *   create: {
     *     // ... data to create a SMSActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SMSActivity we want to update
     *   }
     * })
     */
    upsert<T extends SMSActivityUpsertArgs>(args: SelectSubset<T, SMSActivityUpsertArgs<ExtArgs>>): Prisma__SMSActivityClient<$Result.GetResult<Prisma.$SMSActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SMSActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMSActivityCountArgs} args - Arguments to filter SMSActivities to count.
     * @example
     * // Count the number of SMSActivities
     * const count = await prisma.sMSActivity.count({
     *   where: {
     *     // ... the filter for the SMSActivities we want to count
     *   }
     * })
    **/
    count<T extends SMSActivityCountArgs>(
      args?: Subset<T, SMSActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SMSActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SMSActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMSActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SMSActivityAggregateArgs>(args: Subset<T, SMSActivityAggregateArgs>): Prisma.PrismaPromise<GetSMSActivityAggregateType<T>>

    /**
     * Group by SMSActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMSActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SMSActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SMSActivityGroupByArgs['orderBy'] }
        : { orderBy?: SMSActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SMSActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSMSActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SMSActivity model
   */
  readonly fields: SMSActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SMSActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SMSActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends SMSCampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SMSCampaignDefaultArgs<ExtArgs>>): Prisma__SMSCampaignClient<$Result.GetResult<Prisma.$SMSCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SMSActivity model
   */
  interface SMSActivityFieldRefs {
    readonly id: FieldRef<"SMSActivity", 'String'>
    readonly campaignId: FieldRef<"SMSActivity", 'String'>
    readonly contactId: FieldRef<"SMSActivity", 'String'>
    readonly type: FieldRef<"SMSActivity", 'ActivityType'>
    readonly timestamp: FieldRef<"SMSActivity", 'DateTime'>
    readonly metadata: FieldRef<"SMSActivity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SMSActivity findUnique
   */
  export type SMSActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSActivity
     */
    select?: SMSActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSActivity
     */
    omit?: SMSActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSActivityInclude<ExtArgs> | null
    /**
     * Filter, which SMSActivity to fetch.
     */
    where: SMSActivityWhereUniqueInput
  }

  /**
   * SMSActivity findUniqueOrThrow
   */
  export type SMSActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSActivity
     */
    select?: SMSActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSActivity
     */
    omit?: SMSActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSActivityInclude<ExtArgs> | null
    /**
     * Filter, which SMSActivity to fetch.
     */
    where: SMSActivityWhereUniqueInput
  }

  /**
   * SMSActivity findFirst
   */
  export type SMSActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSActivity
     */
    select?: SMSActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSActivity
     */
    omit?: SMSActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSActivityInclude<ExtArgs> | null
    /**
     * Filter, which SMSActivity to fetch.
     */
    where?: SMSActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMSActivities to fetch.
     */
    orderBy?: SMSActivityOrderByWithRelationInput | SMSActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SMSActivities.
     */
    cursor?: SMSActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMSActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMSActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SMSActivities.
     */
    distinct?: SMSActivityScalarFieldEnum | SMSActivityScalarFieldEnum[]
  }

  /**
   * SMSActivity findFirstOrThrow
   */
  export type SMSActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSActivity
     */
    select?: SMSActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSActivity
     */
    omit?: SMSActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSActivityInclude<ExtArgs> | null
    /**
     * Filter, which SMSActivity to fetch.
     */
    where?: SMSActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMSActivities to fetch.
     */
    orderBy?: SMSActivityOrderByWithRelationInput | SMSActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SMSActivities.
     */
    cursor?: SMSActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMSActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMSActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SMSActivities.
     */
    distinct?: SMSActivityScalarFieldEnum | SMSActivityScalarFieldEnum[]
  }

  /**
   * SMSActivity findMany
   */
  export type SMSActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSActivity
     */
    select?: SMSActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSActivity
     */
    omit?: SMSActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSActivityInclude<ExtArgs> | null
    /**
     * Filter, which SMSActivities to fetch.
     */
    where?: SMSActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMSActivities to fetch.
     */
    orderBy?: SMSActivityOrderByWithRelationInput | SMSActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SMSActivities.
     */
    cursor?: SMSActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMSActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMSActivities.
     */
    skip?: number
    distinct?: SMSActivityScalarFieldEnum | SMSActivityScalarFieldEnum[]
  }

  /**
   * SMSActivity create
   */
  export type SMSActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSActivity
     */
    select?: SMSActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSActivity
     */
    omit?: SMSActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a SMSActivity.
     */
    data: XOR<SMSActivityCreateInput, SMSActivityUncheckedCreateInput>
  }

  /**
   * SMSActivity createMany
   */
  export type SMSActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SMSActivities.
     */
    data: SMSActivityCreateManyInput | SMSActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SMSActivity createManyAndReturn
   */
  export type SMSActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSActivity
     */
    select?: SMSActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SMSActivity
     */
    omit?: SMSActivityOmit<ExtArgs> | null
    /**
     * The data used to create many SMSActivities.
     */
    data: SMSActivityCreateManyInput | SMSActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SMSActivity update
   */
  export type SMSActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSActivity
     */
    select?: SMSActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSActivity
     */
    omit?: SMSActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a SMSActivity.
     */
    data: XOR<SMSActivityUpdateInput, SMSActivityUncheckedUpdateInput>
    /**
     * Choose, which SMSActivity to update.
     */
    where: SMSActivityWhereUniqueInput
  }

  /**
   * SMSActivity updateMany
   */
  export type SMSActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SMSActivities.
     */
    data: XOR<SMSActivityUpdateManyMutationInput, SMSActivityUncheckedUpdateManyInput>
    /**
     * Filter which SMSActivities to update
     */
    where?: SMSActivityWhereInput
    /**
     * Limit how many SMSActivities to update.
     */
    limit?: number
  }

  /**
   * SMSActivity updateManyAndReturn
   */
  export type SMSActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSActivity
     */
    select?: SMSActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SMSActivity
     */
    omit?: SMSActivityOmit<ExtArgs> | null
    /**
     * The data used to update SMSActivities.
     */
    data: XOR<SMSActivityUpdateManyMutationInput, SMSActivityUncheckedUpdateManyInput>
    /**
     * Filter which SMSActivities to update
     */
    where?: SMSActivityWhereInput
    /**
     * Limit how many SMSActivities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SMSActivity upsert
   */
  export type SMSActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSActivity
     */
    select?: SMSActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSActivity
     */
    omit?: SMSActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the SMSActivity to update in case it exists.
     */
    where: SMSActivityWhereUniqueInput
    /**
     * In case the SMSActivity found by the `where` argument doesn't exist, create a new SMSActivity with this data.
     */
    create: XOR<SMSActivityCreateInput, SMSActivityUncheckedCreateInput>
    /**
     * In case the SMSActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SMSActivityUpdateInput, SMSActivityUncheckedUpdateInput>
  }

  /**
   * SMSActivity delete
   */
  export type SMSActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSActivity
     */
    select?: SMSActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSActivity
     */
    omit?: SMSActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSActivityInclude<ExtArgs> | null
    /**
     * Filter which SMSActivity to delete.
     */
    where: SMSActivityWhereUniqueInput
  }

  /**
   * SMSActivity deleteMany
   */
  export type SMSActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SMSActivities to delete
     */
    where?: SMSActivityWhereInput
    /**
     * Limit how many SMSActivities to delete.
     */
    limit?: number
  }

  /**
   * SMSActivity without action
   */
  export type SMSActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMSActivity
     */
    select?: SMSActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMSActivity
     */
    omit?: SMSActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMSActivityInclude<ExtArgs> | null
  }


  /**
   * Model WhatsAppTemplate
   */

  export type AggregateWhatsAppTemplate = {
    _count: WhatsAppTemplateCountAggregateOutputType | null
    _min: WhatsAppTemplateMinAggregateOutputType | null
    _max: WhatsAppTemplateMaxAggregateOutputType | null
  }

  export type WhatsAppTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    content: string | null
    variables: string | null
    category: string | null
    status: $Enums.WATemplateStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type WhatsAppTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    content: string | null
    variables: string | null
    category: string | null
    status: $Enums.WATemplateStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type WhatsAppTemplateCountAggregateOutputType = {
    id: number
    name: number
    content: number
    variables: number
    category: number
    status: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type WhatsAppTemplateMinAggregateInputType = {
    id?: true
    name?: true
    content?: true
    variables?: true
    category?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type WhatsAppTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    content?: true
    variables?: true
    category?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type WhatsAppTemplateCountAggregateInputType = {
    id?: true
    name?: true
    content?: true
    variables?: true
    category?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type WhatsAppTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppTemplate to aggregate.
     */
    where?: WhatsAppTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppTemplates to fetch.
     */
    orderBy?: WhatsAppTemplateOrderByWithRelationInput | WhatsAppTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsAppTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsAppTemplates
    **/
    _count?: true | WhatsAppTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsAppTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsAppTemplateMaxAggregateInputType
  }

  export type GetWhatsAppTemplateAggregateType<T extends WhatsAppTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsAppTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsAppTemplate[P]>
      : GetScalarType<T[P], AggregateWhatsAppTemplate[P]>
  }




  export type WhatsAppTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppTemplateWhereInput
    orderBy?: WhatsAppTemplateOrderByWithAggregationInput | WhatsAppTemplateOrderByWithAggregationInput[]
    by: WhatsAppTemplateScalarFieldEnum[] | WhatsAppTemplateScalarFieldEnum
    having?: WhatsAppTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsAppTemplateCountAggregateInputType | true
    _min?: WhatsAppTemplateMinAggregateInputType
    _max?: WhatsAppTemplateMaxAggregateInputType
  }

  export type WhatsAppTemplateGroupByOutputType = {
    id: string
    name: string
    content: string
    variables: string
    category: string | null
    status: $Enums.WATemplateStatus
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: WhatsAppTemplateCountAggregateOutputType | null
    _min: WhatsAppTemplateMinAggregateOutputType | null
    _max: WhatsAppTemplateMaxAggregateOutputType | null
  }

  type GetWhatsAppTemplateGroupByPayload<T extends WhatsAppTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsAppTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsAppTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsAppTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsAppTemplateGroupByOutputType[P]>
        }
      >
    >


  export type WhatsAppTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    content?: boolean
    variables?: boolean
    category?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    campaigns?: boolean | WhatsAppTemplate$campaignsArgs<ExtArgs>
    _count?: boolean | WhatsAppTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppTemplate"]>

  export type WhatsAppTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    content?: boolean
    variables?: boolean
    category?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppTemplate"]>

  export type WhatsAppTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    content?: boolean
    variables?: boolean
    category?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppTemplate"]>

  export type WhatsAppTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    content?: boolean
    variables?: boolean
    category?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type WhatsAppTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "content" | "variables" | "category" | "status" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["whatsAppTemplate"]>
  export type WhatsAppTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    campaigns?: boolean | WhatsAppTemplate$campaignsArgs<ExtArgs>
    _count?: boolean | WhatsAppTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WhatsAppTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WhatsAppTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WhatsAppTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsAppTemplate"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      campaigns: Prisma.$WhatsAppCampaignPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      content: string
      variables: string
      category: string | null
      status: $Enums.WATemplateStatus
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["whatsAppTemplate"]>
    composites: {}
  }

  type WhatsAppTemplateGetPayload<S extends boolean | null | undefined | WhatsAppTemplateDefaultArgs> = $Result.GetResult<Prisma.$WhatsAppTemplatePayload, S>

  type WhatsAppTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhatsAppTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhatsAppTemplateCountAggregateInputType | true
    }

  export interface WhatsAppTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsAppTemplate'], meta: { name: 'WhatsAppTemplate' } }
    /**
     * Find zero or one WhatsAppTemplate that matches the filter.
     * @param {WhatsAppTemplateFindUniqueArgs} args - Arguments to find a WhatsAppTemplate
     * @example
     * // Get one WhatsAppTemplate
     * const whatsAppTemplate = await prisma.whatsAppTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsAppTemplateFindUniqueArgs>(args: SelectSubset<T, WhatsAppTemplateFindUniqueArgs<ExtArgs>>): Prisma__WhatsAppTemplateClient<$Result.GetResult<Prisma.$WhatsAppTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhatsAppTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhatsAppTemplateFindUniqueOrThrowArgs} args - Arguments to find a WhatsAppTemplate
     * @example
     * // Get one WhatsAppTemplate
     * const whatsAppTemplate = await prisma.whatsAppTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsAppTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsAppTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsAppTemplateClient<$Result.GetResult<Prisma.$WhatsAppTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppTemplateFindFirstArgs} args - Arguments to find a WhatsAppTemplate
     * @example
     * // Get one WhatsAppTemplate
     * const whatsAppTemplate = await prisma.whatsAppTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsAppTemplateFindFirstArgs>(args?: SelectSubset<T, WhatsAppTemplateFindFirstArgs<ExtArgs>>): Prisma__WhatsAppTemplateClient<$Result.GetResult<Prisma.$WhatsAppTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppTemplateFindFirstOrThrowArgs} args - Arguments to find a WhatsAppTemplate
     * @example
     * // Get one WhatsAppTemplate
     * const whatsAppTemplate = await prisma.whatsAppTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsAppTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsAppTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsAppTemplateClient<$Result.GetResult<Prisma.$WhatsAppTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhatsAppTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsAppTemplates
     * const whatsAppTemplates = await prisma.whatsAppTemplate.findMany()
     * 
     * // Get first 10 WhatsAppTemplates
     * const whatsAppTemplates = await prisma.whatsAppTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsAppTemplateWithIdOnly = await prisma.whatsAppTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsAppTemplateFindManyArgs>(args?: SelectSubset<T, WhatsAppTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhatsAppTemplate.
     * @param {WhatsAppTemplateCreateArgs} args - Arguments to create a WhatsAppTemplate.
     * @example
     * // Create one WhatsAppTemplate
     * const WhatsAppTemplate = await prisma.whatsAppTemplate.create({
     *   data: {
     *     // ... data to create a WhatsAppTemplate
     *   }
     * })
     * 
     */
    create<T extends WhatsAppTemplateCreateArgs>(args: SelectSubset<T, WhatsAppTemplateCreateArgs<ExtArgs>>): Prisma__WhatsAppTemplateClient<$Result.GetResult<Prisma.$WhatsAppTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhatsAppTemplates.
     * @param {WhatsAppTemplateCreateManyArgs} args - Arguments to create many WhatsAppTemplates.
     * @example
     * // Create many WhatsAppTemplates
     * const whatsAppTemplate = await prisma.whatsAppTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsAppTemplateCreateManyArgs>(args?: SelectSubset<T, WhatsAppTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsAppTemplates and returns the data saved in the database.
     * @param {WhatsAppTemplateCreateManyAndReturnArgs} args - Arguments to create many WhatsAppTemplates.
     * @example
     * // Create many WhatsAppTemplates
     * const whatsAppTemplate = await prisma.whatsAppTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsAppTemplates and only return the `id`
     * const whatsAppTemplateWithIdOnly = await prisma.whatsAppTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsAppTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsAppTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhatsAppTemplate.
     * @param {WhatsAppTemplateDeleteArgs} args - Arguments to delete one WhatsAppTemplate.
     * @example
     * // Delete one WhatsAppTemplate
     * const WhatsAppTemplate = await prisma.whatsAppTemplate.delete({
     *   where: {
     *     // ... filter to delete one WhatsAppTemplate
     *   }
     * })
     * 
     */
    delete<T extends WhatsAppTemplateDeleteArgs>(args: SelectSubset<T, WhatsAppTemplateDeleteArgs<ExtArgs>>): Prisma__WhatsAppTemplateClient<$Result.GetResult<Prisma.$WhatsAppTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhatsAppTemplate.
     * @param {WhatsAppTemplateUpdateArgs} args - Arguments to update one WhatsAppTemplate.
     * @example
     * // Update one WhatsAppTemplate
     * const whatsAppTemplate = await prisma.whatsAppTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsAppTemplateUpdateArgs>(args: SelectSubset<T, WhatsAppTemplateUpdateArgs<ExtArgs>>): Prisma__WhatsAppTemplateClient<$Result.GetResult<Prisma.$WhatsAppTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhatsAppTemplates.
     * @param {WhatsAppTemplateDeleteManyArgs} args - Arguments to filter WhatsAppTemplates to delete.
     * @example
     * // Delete a few WhatsAppTemplates
     * const { count } = await prisma.whatsAppTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsAppTemplateDeleteManyArgs>(args?: SelectSubset<T, WhatsAppTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsAppTemplates
     * const whatsAppTemplate = await prisma.whatsAppTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsAppTemplateUpdateManyArgs>(args: SelectSubset<T, WhatsAppTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppTemplates and returns the data updated in the database.
     * @param {WhatsAppTemplateUpdateManyAndReturnArgs} args - Arguments to update many WhatsAppTemplates.
     * @example
     * // Update many WhatsAppTemplates
     * const whatsAppTemplate = await prisma.whatsAppTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhatsAppTemplates and only return the `id`
     * const whatsAppTemplateWithIdOnly = await prisma.whatsAppTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhatsAppTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, WhatsAppTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhatsAppTemplate.
     * @param {WhatsAppTemplateUpsertArgs} args - Arguments to update or create a WhatsAppTemplate.
     * @example
     * // Update or create a WhatsAppTemplate
     * const whatsAppTemplate = await prisma.whatsAppTemplate.upsert({
     *   create: {
     *     // ... data to create a WhatsAppTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsAppTemplate we want to update
     *   }
     * })
     */
    upsert<T extends WhatsAppTemplateUpsertArgs>(args: SelectSubset<T, WhatsAppTemplateUpsertArgs<ExtArgs>>): Prisma__WhatsAppTemplateClient<$Result.GetResult<Prisma.$WhatsAppTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhatsAppTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppTemplateCountArgs} args - Arguments to filter WhatsAppTemplates to count.
     * @example
     * // Count the number of WhatsAppTemplates
     * const count = await prisma.whatsAppTemplate.count({
     *   where: {
     *     // ... the filter for the WhatsAppTemplates we want to count
     *   }
     * })
    **/
    count<T extends WhatsAppTemplateCountArgs>(
      args?: Subset<T, WhatsAppTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsAppTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsAppTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsAppTemplateAggregateArgs>(args: Subset<T, WhatsAppTemplateAggregateArgs>): Prisma.PrismaPromise<GetWhatsAppTemplateAggregateType<T>>

    /**
     * Group by WhatsAppTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsAppTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsAppTemplateGroupByArgs['orderBy'] }
        : { orderBy?: WhatsAppTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsAppTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsAppTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsAppTemplate model
   */
  readonly fields: WhatsAppTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsAppTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsAppTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campaigns<T extends WhatsAppTemplate$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppTemplate$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsAppTemplate model
   */
  interface WhatsAppTemplateFieldRefs {
    readonly id: FieldRef<"WhatsAppTemplate", 'String'>
    readonly name: FieldRef<"WhatsAppTemplate", 'String'>
    readonly content: FieldRef<"WhatsAppTemplate", 'String'>
    readonly variables: FieldRef<"WhatsAppTemplate", 'String'>
    readonly category: FieldRef<"WhatsAppTemplate", 'String'>
    readonly status: FieldRef<"WhatsAppTemplate", 'WATemplateStatus'>
    readonly createdAt: FieldRef<"WhatsAppTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"WhatsAppTemplate", 'DateTime'>
    readonly createdById: FieldRef<"WhatsAppTemplate", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WhatsAppTemplate findUnique
   */
  export type WhatsAppTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppTemplate
     */
    select?: WhatsAppTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppTemplate
     */
    omit?: WhatsAppTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppTemplateInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppTemplate to fetch.
     */
    where: WhatsAppTemplateWhereUniqueInput
  }

  /**
   * WhatsAppTemplate findUniqueOrThrow
   */
  export type WhatsAppTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppTemplate
     */
    select?: WhatsAppTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppTemplate
     */
    omit?: WhatsAppTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppTemplateInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppTemplate to fetch.
     */
    where: WhatsAppTemplateWhereUniqueInput
  }

  /**
   * WhatsAppTemplate findFirst
   */
  export type WhatsAppTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppTemplate
     */
    select?: WhatsAppTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppTemplate
     */
    omit?: WhatsAppTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppTemplateInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppTemplate to fetch.
     */
    where?: WhatsAppTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppTemplates to fetch.
     */
    orderBy?: WhatsAppTemplateOrderByWithRelationInput | WhatsAppTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppTemplates.
     */
    cursor?: WhatsAppTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppTemplates.
     */
    distinct?: WhatsAppTemplateScalarFieldEnum | WhatsAppTemplateScalarFieldEnum[]
  }

  /**
   * WhatsAppTemplate findFirstOrThrow
   */
  export type WhatsAppTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppTemplate
     */
    select?: WhatsAppTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppTemplate
     */
    omit?: WhatsAppTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppTemplateInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppTemplate to fetch.
     */
    where?: WhatsAppTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppTemplates to fetch.
     */
    orderBy?: WhatsAppTemplateOrderByWithRelationInput | WhatsAppTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppTemplates.
     */
    cursor?: WhatsAppTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppTemplates.
     */
    distinct?: WhatsAppTemplateScalarFieldEnum | WhatsAppTemplateScalarFieldEnum[]
  }

  /**
   * WhatsAppTemplate findMany
   */
  export type WhatsAppTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppTemplate
     */
    select?: WhatsAppTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppTemplate
     */
    omit?: WhatsAppTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppTemplateInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppTemplates to fetch.
     */
    where?: WhatsAppTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppTemplates to fetch.
     */
    orderBy?: WhatsAppTemplateOrderByWithRelationInput | WhatsAppTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsAppTemplates.
     */
    cursor?: WhatsAppTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppTemplates.
     */
    skip?: number
    distinct?: WhatsAppTemplateScalarFieldEnum | WhatsAppTemplateScalarFieldEnum[]
  }

  /**
   * WhatsAppTemplate create
   */
  export type WhatsAppTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppTemplate
     */
    select?: WhatsAppTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppTemplate
     */
    omit?: WhatsAppTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsAppTemplate.
     */
    data: XOR<WhatsAppTemplateCreateInput, WhatsAppTemplateUncheckedCreateInput>
  }

  /**
   * WhatsAppTemplate createMany
   */
  export type WhatsAppTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsAppTemplates.
     */
    data: WhatsAppTemplateCreateManyInput | WhatsAppTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsAppTemplate createManyAndReturn
   */
  export type WhatsAppTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppTemplate
     */
    select?: WhatsAppTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppTemplate
     */
    omit?: WhatsAppTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many WhatsAppTemplates.
     */
    data: WhatsAppTemplateCreateManyInput | WhatsAppTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppTemplate update
   */
  export type WhatsAppTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppTemplate
     */
    select?: WhatsAppTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppTemplate
     */
    omit?: WhatsAppTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsAppTemplate.
     */
    data: XOR<WhatsAppTemplateUpdateInput, WhatsAppTemplateUncheckedUpdateInput>
    /**
     * Choose, which WhatsAppTemplate to update.
     */
    where: WhatsAppTemplateWhereUniqueInput
  }

  /**
   * WhatsAppTemplate updateMany
   */
  export type WhatsAppTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsAppTemplates.
     */
    data: XOR<WhatsAppTemplateUpdateManyMutationInput, WhatsAppTemplateUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppTemplates to update
     */
    where?: WhatsAppTemplateWhereInput
    /**
     * Limit how many WhatsAppTemplates to update.
     */
    limit?: number
  }

  /**
   * WhatsAppTemplate updateManyAndReturn
   */
  export type WhatsAppTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppTemplate
     */
    select?: WhatsAppTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppTemplate
     */
    omit?: WhatsAppTemplateOmit<ExtArgs> | null
    /**
     * The data used to update WhatsAppTemplates.
     */
    data: XOR<WhatsAppTemplateUpdateManyMutationInput, WhatsAppTemplateUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppTemplates to update
     */
    where?: WhatsAppTemplateWhereInput
    /**
     * Limit how many WhatsAppTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppTemplate upsert
   */
  export type WhatsAppTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppTemplate
     */
    select?: WhatsAppTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppTemplate
     */
    omit?: WhatsAppTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsAppTemplate to update in case it exists.
     */
    where: WhatsAppTemplateWhereUniqueInput
    /**
     * In case the WhatsAppTemplate found by the `where` argument doesn't exist, create a new WhatsAppTemplate with this data.
     */
    create: XOR<WhatsAppTemplateCreateInput, WhatsAppTemplateUncheckedCreateInput>
    /**
     * In case the WhatsAppTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsAppTemplateUpdateInput, WhatsAppTemplateUncheckedUpdateInput>
  }

  /**
   * WhatsAppTemplate delete
   */
  export type WhatsAppTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppTemplate
     */
    select?: WhatsAppTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppTemplate
     */
    omit?: WhatsAppTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppTemplateInclude<ExtArgs> | null
    /**
     * Filter which WhatsAppTemplate to delete.
     */
    where: WhatsAppTemplateWhereUniqueInput
  }

  /**
   * WhatsAppTemplate deleteMany
   */
  export type WhatsAppTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppTemplates to delete
     */
    where?: WhatsAppTemplateWhereInput
    /**
     * Limit how many WhatsAppTemplates to delete.
     */
    limit?: number
  }

  /**
   * WhatsAppTemplate.campaigns
   */
  export type WhatsAppTemplate$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
    where?: WhatsAppCampaignWhereInput
    orderBy?: WhatsAppCampaignOrderByWithRelationInput | WhatsAppCampaignOrderByWithRelationInput[]
    cursor?: WhatsAppCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppCampaignScalarFieldEnum | WhatsAppCampaignScalarFieldEnum[]
  }

  /**
   * WhatsAppTemplate without action
   */
  export type WhatsAppTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppTemplate
     */
    select?: WhatsAppTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppTemplate
     */
    omit?: WhatsAppTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppTemplateInclude<ExtArgs> | null
  }


  /**
   * Model WhatsAppCampaign
   */

  export type AggregateWhatsAppCampaign = {
    _count: WhatsAppCampaignCountAggregateOutputType | null
    _min: WhatsAppCampaignMinAggregateOutputType | null
    _max: WhatsAppCampaignMaxAggregateOutputType | null
  }

  export type WhatsAppCampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    from: string | null
    templateId: string | null
    content: string | null
    status: $Enums.CampaignStatus | null
    scheduledFor: Date | null
    sentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type WhatsAppCampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    from: string | null
    templateId: string | null
    content: string | null
    status: $Enums.CampaignStatus | null
    scheduledFor: Date | null
    sentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type WhatsAppCampaignCountAggregateOutputType = {
    id: number
    name: number
    description: number
    from: number
    templateId: number
    content: number
    status: number
    scheduledFor: number
    sentAt: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type WhatsAppCampaignMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    from?: true
    templateId?: true
    content?: true
    status?: true
    scheduledFor?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type WhatsAppCampaignMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    from?: true
    templateId?: true
    content?: true
    status?: true
    scheduledFor?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type WhatsAppCampaignCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    from?: true
    templateId?: true
    content?: true
    status?: true
    scheduledFor?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type WhatsAppCampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppCampaign to aggregate.
     */
    where?: WhatsAppCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppCampaigns to fetch.
     */
    orderBy?: WhatsAppCampaignOrderByWithRelationInput | WhatsAppCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsAppCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsAppCampaigns
    **/
    _count?: true | WhatsAppCampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsAppCampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsAppCampaignMaxAggregateInputType
  }

  export type GetWhatsAppCampaignAggregateType<T extends WhatsAppCampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsAppCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsAppCampaign[P]>
      : GetScalarType<T[P], AggregateWhatsAppCampaign[P]>
  }




  export type WhatsAppCampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppCampaignWhereInput
    orderBy?: WhatsAppCampaignOrderByWithAggregationInput | WhatsAppCampaignOrderByWithAggregationInput[]
    by: WhatsAppCampaignScalarFieldEnum[] | WhatsAppCampaignScalarFieldEnum
    having?: WhatsAppCampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsAppCampaignCountAggregateInputType | true
    _min?: WhatsAppCampaignMinAggregateInputType
    _max?: WhatsAppCampaignMaxAggregateInputType
  }

  export type WhatsAppCampaignGroupByOutputType = {
    id: string
    name: string
    description: string | null
    from: string
    templateId: string | null
    content: string | null
    status: $Enums.CampaignStatus
    scheduledFor: Date | null
    sentAt: Date | null
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: WhatsAppCampaignCountAggregateOutputType | null
    _min: WhatsAppCampaignMinAggregateOutputType | null
    _max: WhatsAppCampaignMaxAggregateOutputType | null
  }

  type GetWhatsAppCampaignGroupByPayload<T extends WhatsAppCampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsAppCampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsAppCampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsAppCampaignGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsAppCampaignGroupByOutputType[P]>
        }
      >
    >


  export type WhatsAppCampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    from?: boolean
    templateId?: boolean
    content?: boolean
    status?: boolean
    scheduledFor?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | WhatsAppCampaign$templateArgs<ExtArgs>
    lists?: boolean | WhatsAppCampaign$listsArgs<ExtArgs>
    segments?: boolean | WhatsAppCampaign$segmentsArgs<ExtArgs>
    activities?: boolean | WhatsAppCampaign$activitiesArgs<ExtArgs>
    _count?: boolean | WhatsAppCampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppCampaign"]>

  export type WhatsAppCampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    from?: boolean
    templateId?: boolean
    content?: boolean
    status?: boolean
    scheduledFor?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | WhatsAppCampaign$templateArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppCampaign"]>

  export type WhatsAppCampaignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    from?: boolean
    templateId?: boolean
    content?: boolean
    status?: boolean
    scheduledFor?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | WhatsAppCampaign$templateArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppCampaign"]>

  export type WhatsAppCampaignSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    from?: boolean
    templateId?: boolean
    content?: boolean
    status?: boolean
    scheduledFor?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type WhatsAppCampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "from" | "templateId" | "content" | "status" | "scheduledFor" | "sentAt" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["whatsAppCampaign"]>
  export type WhatsAppCampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | WhatsAppCampaign$templateArgs<ExtArgs>
    lists?: boolean | WhatsAppCampaign$listsArgs<ExtArgs>
    segments?: boolean | WhatsAppCampaign$segmentsArgs<ExtArgs>
    activities?: boolean | WhatsAppCampaign$activitiesArgs<ExtArgs>
    _count?: boolean | WhatsAppCampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WhatsAppCampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | WhatsAppCampaign$templateArgs<ExtArgs>
  }
  export type WhatsAppCampaignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | WhatsAppCampaign$templateArgs<ExtArgs>
  }

  export type $WhatsAppCampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsAppCampaign"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      template: Prisma.$WhatsAppTemplatePayload<ExtArgs> | null
      lists: Prisma.$ListPayload<ExtArgs>[]
      segments: Prisma.$SegmentPayload<ExtArgs>[]
      activities: Prisma.$WhatsAppActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      from: string
      templateId: string | null
      content: string | null
      status: $Enums.CampaignStatus
      scheduledFor: Date | null
      sentAt: Date | null
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["whatsAppCampaign"]>
    composites: {}
  }

  type WhatsAppCampaignGetPayload<S extends boolean | null | undefined | WhatsAppCampaignDefaultArgs> = $Result.GetResult<Prisma.$WhatsAppCampaignPayload, S>

  type WhatsAppCampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhatsAppCampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhatsAppCampaignCountAggregateInputType | true
    }

  export interface WhatsAppCampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsAppCampaign'], meta: { name: 'WhatsAppCampaign' } }
    /**
     * Find zero or one WhatsAppCampaign that matches the filter.
     * @param {WhatsAppCampaignFindUniqueArgs} args - Arguments to find a WhatsAppCampaign
     * @example
     * // Get one WhatsAppCampaign
     * const whatsAppCampaign = await prisma.whatsAppCampaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsAppCampaignFindUniqueArgs>(args: SelectSubset<T, WhatsAppCampaignFindUniqueArgs<ExtArgs>>): Prisma__WhatsAppCampaignClient<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhatsAppCampaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhatsAppCampaignFindUniqueOrThrowArgs} args - Arguments to find a WhatsAppCampaign
     * @example
     * // Get one WhatsAppCampaign
     * const whatsAppCampaign = await prisma.whatsAppCampaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsAppCampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsAppCampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsAppCampaignClient<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppCampaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppCampaignFindFirstArgs} args - Arguments to find a WhatsAppCampaign
     * @example
     * // Get one WhatsAppCampaign
     * const whatsAppCampaign = await prisma.whatsAppCampaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsAppCampaignFindFirstArgs>(args?: SelectSubset<T, WhatsAppCampaignFindFirstArgs<ExtArgs>>): Prisma__WhatsAppCampaignClient<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppCampaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppCampaignFindFirstOrThrowArgs} args - Arguments to find a WhatsAppCampaign
     * @example
     * // Get one WhatsAppCampaign
     * const whatsAppCampaign = await prisma.whatsAppCampaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsAppCampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsAppCampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsAppCampaignClient<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhatsAppCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppCampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsAppCampaigns
     * const whatsAppCampaigns = await prisma.whatsAppCampaign.findMany()
     * 
     * // Get first 10 WhatsAppCampaigns
     * const whatsAppCampaigns = await prisma.whatsAppCampaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsAppCampaignWithIdOnly = await prisma.whatsAppCampaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsAppCampaignFindManyArgs>(args?: SelectSubset<T, WhatsAppCampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhatsAppCampaign.
     * @param {WhatsAppCampaignCreateArgs} args - Arguments to create a WhatsAppCampaign.
     * @example
     * // Create one WhatsAppCampaign
     * const WhatsAppCampaign = await prisma.whatsAppCampaign.create({
     *   data: {
     *     // ... data to create a WhatsAppCampaign
     *   }
     * })
     * 
     */
    create<T extends WhatsAppCampaignCreateArgs>(args: SelectSubset<T, WhatsAppCampaignCreateArgs<ExtArgs>>): Prisma__WhatsAppCampaignClient<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhatsAppCampaigns.
     * @param {WhatsAppCampaignCreateManyArgs} args - Arguments to create many WhatsAppCampaigns.
     * @example
     * // Create many WhatsAppCampaigns
     * const whatsAppCampaign = await prisma.whatsAppCampaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsAppCampaignCreateManyArgs>(args?: SelectSubset<T, WhatsAppCampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsAppCampaigns and returns the data saved in the database.
     * @param {WhatsAppCampaignCreateManyAndReturnArgs} args - Arguments to create many WhatsAppCampaigns.
     * @example
     * // Create many WhatsAppCampaigns
     * const whatsAppCampaign = await prisma.whatsAppCampaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsAppCampaigns and only return the `id`
     * const whatsAppCampaignWithIdOnly = await prisma.whatsAppCampaign.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsAppCampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsAppCampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhatsAppCampaign.
     * @param {WhatsAppCampaignDeleteArgs} args - Arguments to delete one WhatsAppCampaign.
     * @example
     * // Delete one WhatsAppCampaign
     * const WhatsAppCampaign = await prisma.whatsAppCampaign.delete({
     *   where: {
     *     // ... filter to delete one WhatsAppCampaign
     *   }
     * })
     * 
     */
    delete<T extends WhatsAppCampaignDeleteArgs>(args: SelectSubset<T, WhatsAppCampaignDeleteArgs<ExtArgs>>): Prisma__WhatsAppCampaignClient<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhatsAppCampaign.
     * @param {WhatsAppCampaignUpdateArgs} args - Arguments to update one WhatsAppCampaign.
     * @example
     * // Update one WhatsAppCampaign
     * const whatsAppCampaign = await prisma.whatsAppCampaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsAppCampaignUpdateArgs>(args: SelectSubset<T, WhatsAppCampaignUpdateArgs<ExtArgs>>): Prisma__WhatsAppCampaignClient<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhatsAppCampaigns.
     * @param {WhatsAppCampaignDeleteManyArgs} args - Arguments to filter WhatsAppCampaigns to delete.
     * @example
     * // Delete a few WhatsAppCampaigns
     * const { count } = await prisma.whatsAppCampaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsAppCampaignDeleteManyArgs>(args?: SelectSubset<T, WhatsAppCampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppCampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsAppCampaigns
     * const whatsAppCampaign = await prisma.whatsAppCampaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsAppCampaignUpdateManyArgs>(args: SelectSubset<T, WhatsAppCampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppCampaigns and returns the data updated in the database.
     * @param {WhatsAppCampaignUpdateManyAndReturnArgs} args - Arguments to update many WhatsAppCampaigns.
     * @example
     * // Update many WhatsAppCampaigns
     * const whatsAppCampaign = await prisma.whatsAppCampaign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhatsAppCampaigns and only return the `id`
     * const whatsAppCampaignWithIdOnly = await prisma.whatsAppCampaign.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhatsAppCampaignUpdateManyAndReturnArgs>(args: SelectSubset<T, WhatsAppCampaignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhatsAppCampaign.
     * @param {WhatsAppCampaignUpsertArgs} args - Arguments to update or create a WhatsAppCampaign.
     * @example
     * // Update or create a WhatsAppCampaign
     * const whatsAppCampaign = await prisma.whatsAppCampaign.upsert({
     *   create: {
     *     // ... data to create a WhatsAppCampaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsAppCampaign we want to update
     *   }
     * })
     */
    upsert<T extends WhatsAppCampaignUpsertArgs>(args: SelectSubset<T, WhatsAppCampaignUpsertArgs<ExtArgs>>): Prisma__WhatsAppCampaignClient<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhatsAppCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppCampaignCountArgs} args - Arguments to filter WhatsAppCampaigns to count.
     * @example
     * // Count the number of WhatsAppCampaigns
     * const count = await prisma.whatsAppCampaign.count({
     *   where: {
     *     // ... the filter for the WhatsAppCampaigns we want to count
     *   }
     * })
    **/
    count<T extends WhatsAppCampaignCountArgs>(
      args?: Subset<T, WhatsAppCampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsAppCampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsAppCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppCampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsAppCampaignAggregateArgs>(args: Subset<T, WhatsAppCampaignAggregateArgs>): Prisma.PrismaPromise<GetWhatsAppCampaignAggregateType<T>>

    /**
     * Group by WhatsAppCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppCampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsAppCampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsAppCampaignGroupByArgs['orderBy'] }
        : { orderBy?: WhatsAppCampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsAppCampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsAppCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsAppCampaign model
   */
  readonly fields: WhatsAppCampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsAppCampaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsAppCampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    template<T extends WhatsAppCampaign$templateArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppCampaign$templateArgs<ExtArgs>>): Prisma__WhatsAppTemplateClient<$Result.GetResult<Prisma.$WhatsAppTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lists<T extends WhatsAppCampaign$listsArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppCampaign$listsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    segments<T extends WhatsAppCampaign$segmentsArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppCampaign$segmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends WhatsAppCampaign$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppCampaign$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsAppCampaign model
   */
  interface WhatsAppCampaignFieldRefs {
    readonly id: FieldRef<"WhatsAppCampaign", 'String'>
    readonly name: FieldRef<"WhatsAppCampaign", 'String'>
    readonly description: FieldRef<"WhatsAppCampaign", 'String'>
    readonly from: FieldRef<"WhatsAppCampaign", 'String'>
    readonly templateId: FieldRef<"WhatsAppCampaign", 'String'>
    readonly content: FieldRef<"WhatsAppCampaign", 'String'>
    readonly status: FieldRef<"WhatsAppCampaign", 'CampaignStatus'>
    readonly scheduledFor: FieldRef<"WhatsAppCampaign", 'DateTime'>
    readonly sentAt: FieldRef<"WhatsAppCampaign", 'DateTime'>
    readonly createdAt: FieldRef<"WhatsAppCampaign", 'DateTime'>
    readonly updatedAt: FieldRef<"WhatsAppCampaign", 'DateTime'>
    readonly createdById: FieldRef<"WhatsAppCampaign", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WhatsAppCampaign findUnique
   */
  export type WhatsAppCampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppCampaign to fetch.
     */
    where: WhatsAppCampaignWhereUniqueInput
  }

  /**
   * WhatsAppCampaign findUniqueOrThrow
   */
  export type WhatsAppCampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppCampaign to fetch.
     */
    where: WhatsAppCampaignWhereUniqueInput
  }

  /**
   * WhatsAppCampaign findFirst
   */
  export type WhatsAppCampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppCampaign to fetch.
     */
    where?: WhatsAppCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppCampaigns to fetch.
     */
    orderBy?: WhatsAppCampaignOrderByWithRelationInput | WhatsAppCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppCampaigns.
     */
    cursor?: WhatsAppCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppCampaigns.
     */
    distinct?: WhatsAppCampaignScalarFieldEnum | WhatsAppCampaignScalarFieldEnum[]
  }

  /**
   * WhatsAppCampaign findFirstOrThrow
   */
  export type WhatsAppCampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppCampaign to fetch.
     */
    where?: WhatsAppCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppCampaigns to fetch.
     */
    orderBy?: WhatsAppCampaignOrderByWithRelationInput | WhatsAppCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppCampaigns.
     */
    cursor?: WhatsAppCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppCampaigns.
     */
    distinct?: WhatsAppCampaignScalarFieldEnum | WhatsAppCampaignScalarFieldEnum[]
  }

  /**
   * WhatsAppCampaign findMany
   */
  export type WhatsAppCampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppCampaigns to fetch.
     */
    where?: WhatsAppCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppCampaigns to fetch.
     */
    orderBy?: WhatsAppCampaignOrderByWithRelationInput | WhatsAppCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsAppCampaigns.
     */
    cursor?: WhatsAppCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppCampaigns.
     */
    skip?: number
    distinct?: WhatsAppCampaignScalarFieldEnum | WhatsAppCampaignScalarFieldEnum[]
  }

  /**
   * WhatsAppCampaign create
   */
  export type WhatsAppCampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsAppCampaign.
     */
    data: XOR<WhatsAppCampaignCreateInput, WhatsAppCampaignUncheckedCreateInput>
  }

  /**
   * WhatsAppCampaign createMany
   */
  export type WhatsAppCampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsAppCampaigns.
     */
    data: WhatsAppCampaignCreateManyInput | WhatsAppCampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsAppCampaign createManyAndReturn
   */
  export type WhatsAppCampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * The data used to create many WhatsAppCampaigns.
     */
    data: WhatsAppCampaignCreateManyInput | WhatsAppCampaignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppCampaign update
   */
  export type WhatsAppCampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsAppCampaign.
     */
    data: XOR<WhatsAppCampaignUpdateInput, WhatsAppCampaignUncheckedUpdateInput>
    /**
     * Choose, which WhatsAppCampaign to update.
     */
    where: WhatsAppCampaignWhereUniqueInput
  }

  /**
   * WhatsAppCampaign updateMany
   */
  export type WhatsAppCampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsAppCampaigns.
     */
    data: XOR<WhatsAppCampaignUpdateManyMutationInput, WhatsAppCampaignUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppCampaigns to update
     */
    where?: WhatsAppCampaignWhereInput
    /**
     * Limit how many WhatsAppCampaigns to update.
     */
    limit?: number
  }

  /**
   * WhatsAppCampaign updateManyAndReturn
   */
  export type WhatsAppCampaignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * The data used to update WhatsAppCampaigns.
     */
    data: XOR<WhatsAppCampaignUpdateManyMutationInput, WhatsAppCampaignUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppCampaigns to update
     */
    where?: WhatsAppCampaignWhereInput
    /**
     * Limit how many WhatsAppCampaigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppCampaign upsert
   */
  export type WhatsAppCampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsAppCampaign to update in case it exists.
     */
    where: WhatsAppCampaignWhereUniqueInput
    /**
     * In case the WhatsAppCampaign found by the `where` argument doesn't exist, create a new WhatsAppCampaign with this data.
     */
    create: XOR<WhatsAppCampaignCreateInput, WhatsAppCampaignUncheckedCreateInput>
    /**
     * In case the WhatsAppCampaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsAppCampaignUpdateInput, WhatsAppCampaignUncheckedUpdateInput>
  }

  /**
   * WhatsAppCampaign delete
   */
  export type WhatsAppCampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
    /**
     * Filter which WhatsAppCampaign to delete.
     */
    where: WhatsAppCampaignWhereUniqueInput
  }

  /**
   * WhatsAppCampaign deleteMany
   */
  export type WhatsAppCampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppCampaigns to delete
     */
    where?: WhatsAppCampaignWhereInput
    /**
     * Limit how many WhatsAppCampaigns to delete.
     */
    limit?: number
  }

  /**
   * WhatsAppCampaign.template
   */
  export type WhatsAppCampaign$templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppTemplate
     */
    select?: WhatsAppTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppTemplate
     */
    omit?: WhatsAppTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppTemplateInclude<ExtArgs> | null
    where?: WhatsAppTemplateWhereInput
  }

  /**
   * WhatsAppCampaign.lists
   */
  export type WhatsAppCampaign$listsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    where?: ListWhereInput
    orderBy?: ListOrderByWithRelationInput | ListOrderByWithRelationInput[]
    cursor?: ListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListScalarFieldEnum | ListScalarFieldEnum[]
  }

  /**
   * WhatsAppCampaign.segments
   */
  export type WhatsAppCampaign$segmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    where?: SegmentWhereInput
    orderBy?: SegmentOrderByWithRelationInput | SegmentOrderByWithRelationInput[]
    cursor?: SegmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SegmentScalarFieldEnum | SegmentScalarFieldEnum[]
  }

  /**
   * WhatsAppCampaign.activities
   */
  export type WhatsAppCampaign$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppActivity
     */
    select?: WhatsAppActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppActivity
     */
    omit?: WhatsAppActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppActivityInclude<ExtArgs> | null
    where?: WhatsAppActivityWhereInput
    orderBy?: WhatsAppActivityOrderByWithRelationInput | WhatsAppActivityOrderByWithRelationInput[]
    cursor?: WhatsAppActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppActivityScalarFieldEnum | WhatsAppActivityScalarFieldEnum[]
  }

  /**
   * WhatsAppCampaign without action
   */
  export type WhatsAppCampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
  }


  /**
   * Model WhatsAppActivity
   */

  export type AggregateWhatsAppActivity = {
    _count: WhatsAppActivityCountAggregateOutputType | null
    _min: WhatsAppActivityMinAggregateOutputType | null
    _max: WhatsAppActivityMaxAggregateOutputType | null
  }

  export type WhatsAppActivityMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    contactId: string | null
    type: $Enums.ActivityType | null
    timestamp: Date | null
    metadata: string | null
  }

  export type WhatsAppActivityMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    contactId: string | null
    type: $Enums.ActivityType | null
    timestamp: Date | null
    metadata: string | null
  }

  export type WhatsAppActivityCountAggregateOutputType = {
    id: number
    campaignId: number
    contactId: number
    type: number
    timestamp: number
    metadata: number
    _all: number
  }


  export type WhatsAppActivityMinAggregateInputType = {
    id?: true
    campaignId?: true
    contactId?: true
    type?: true
    timestamp?: true
    metadata?: true
  }

  export type WhatsAppActivityMaxAggregateInputType = {
    id?: true
    campaignId?: true
    contactId?: true
    type?: true
    timestamp?: true
    metadata?: true
  }

  export type WhatsAppActivityCountAggregateInputType = {
    id?: true
    campaignId?: true
    contactId?: true
    type?: true
    timestamp?: true
    metadata?: true
    _all?: true
  }

  export type WhatsAppActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppActivity to aggregate.
     */
    where?: WhatsAppActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppActivities to fetch.
     */
    orderBy?: WhatsAppActivityOrderByWithRelationInput | WhatsAppActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsAppActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsAppActivities
    **/
    _count?: true | WhatsAppActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsAppActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsAppActivityMaxAggregateInputType
  }

  export type GetWhatsAppActivityAggregateType<T extends WhatsAppActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsAppActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsAppActivity[P]>
      : GetScalarType<T[P], AggregateWhatsAppActivity[P]>
  }




  export type WhatsAppActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppActivityWhereInput
    orderBy?: WhatsAppActivityOrderByWithAggregationInput | WhatsAppActivityOrderByWithAggregationInput[]
    by: WhatsAppActivityScalarFieldEnum[] | WhatsAppActivityScalarFieldEnum
    having?: WhatsAppActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsAppActivityCountAggregateInputType | true
    _min?: WhatsAppActivityMinAggregateInputType
    _max?: WhatsAppActivityMaxAggregateInputType
  }

  export type WhatsAppActivityGroupByOutputType = {
    id: string
    campaignId: string
    contactId: string
    type: $Enums.ActivityType
    timestamp: Date
    metadata: string | null
    _count: WhatsAppActivityCountAggregateOutputType | null
    _min: WhatsAppActivityMinAggregateOutputType | null
    _max: WhatsAppActivityMaxAggregateOutputType | null
  }

  type GetWhatsAppActivityGroupByPayload<T extends WhatsAppActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsAppActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsAppActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsAppActivityGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsAppActivityGroupByOutputType[P]>
        }
      >
    >


  export type WhatsAppActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    contactId?: boolean
    type?: boolean
    timestamp?: boolean
    metadata?: boolean
    campaign?: boolean | WhatsAppCampaignDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppActivity"]>

  export type WhatsAppActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    contactId?: boolean
    type?: boolean
    timestamp?: boolean
    metadata?: boolean
    campaign?: boolean | WhatsAppCampaignDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppActivity"]>

  export type WhatsAppActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    contactId?: boolean
    type?: boolean
    timestamp?: boolean
    metadata?: boolean
    campaign?: boolean | WhatsAppCampaignDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppActivity"]>

  export type WhatsAppActivitySelectScalar = {
    id?: boolean
    campaignId?: boolean
    contactId?: boolean
    type?: boolean
    timestamp?: boolean
    metadata?: boolean
  }

  export type WhatsAppActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaignId" | "contactId" | "type" | "timestamp" | "metadata", ExtArgs["result"]["whatsAppActivity"]>
  export type WhatsAppActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | WhatsAppCampaignDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }
  export type WhatsAppActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | WhatsAppCampaignDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }
  export type WhatsAppActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | WhatsAppCampaignDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }

  export type $WhatsAppActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsAppActivity"
    objects: {
      campaign: Prisma.$WhatsAppCampaignPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      contactId: string
      type: $Enums.ActivityType
      timestamp: Date
      metadata: string | null
    }, ExtArgs["result"]["whatsAppActivity"]>
    composites: {}
  }

  type WhatsAppActivityGetPayload<S extends boolean | null | undefined | WhatsAppActivityDefaultArgs> = $Result.GetResult<Prisma.$WhatsAppActivityPayload, S>

  type WhatsAppActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhatsAppActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhatsAppActivityCountAggregateInputType | true
    }

  export interface WhatsAppActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsAppActivity'], meta: { name: 'WhatsAppActivity' } }
    /**
     * Find zero or one WhatsAppActivity that matches the filter.
     * @param {WhatsAppActivityFindUniqueArgs} args - Arguments to find a WhatsAppActivity
     * @example
     * // Get one WhatsAppActivity
     * const whatsAppActivity = await prisma.whatsAppActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsAppActivityFindUniqueArgs>(args: SelectSubset<T, WhatsAppActivityFindUniqueArgs<ExtArgs>>): Prisma__WhatsAppActivityClient<$Result.GetResult<Prisma.$WhatsAppActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhatsAppActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhatsAppActivityFindUniqueOrThrowArgs} args - Arguments to find a WhatsAppActivity
     * @example
     * // Get one WhatsAppActivity
     * const whatsAppActivity = await prisma.whatsAppActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsAppActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsAppActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsAppActivityClient<$Result.GetResult<Prisma.$WhatsAppActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppActivityFindFirstArgs} args - Arguments to find a WhatsAppActivity
     * @example
     * // Get one WhatsAppActivity
     * const whatsAppActivity = await prisma.whatsAppActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsAppActivityFindFirstArgs>(args?: SelectSubset<T, WhatsAppActivityFindFirstArgs<ExtArgs>>): Prisma__WhatsAppActivityClient<$Result.GetResult<Prisma.$WhatsAppActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppActivityFindFirstOrThrowArgs} args - Arguments to find a WhatsAppActivity
     * @example
     * // Get one WhatsAppActivity
     * const whatsAppActivity = await prisma.whatsAppActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsAppActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsAppActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsAppActivityClient<$Result.GetResult<Prisma.$WhatsAppActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhatsAppActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsAppActivities
     * const whatsAppActivities = await prisma.whatsAppActivity.findMany()
     * 
     * // Get first 10 WhatsAppActivities
     * const whatsAppActivities = await prisma.whatsAppActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsAppActivityWithIdOnly = await prisma.whatsAppActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsAppActivityFindManyArgs>(args?: SelectSubset<T, WhatsAppActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhatsAppActivity.
     * @param {WhatsAppActivityCreateArgs} args - Arguments to create a WhatsAppActivity.
     * @example
     * // Create one WhatsAppActivity
     * const WhatsAppActivity = await prisma.whatsAppActivity.create({
     *   data: {
     *     // ... data to create a WhatsAppActivity
     *   }
     * })
     * 
     */
    create<T extends WhatsAppActivityCreateArgs>(args: SelectSubset<T, WhatsAppActivityCreateArgs<ExtArgs>>): Prisma__WhatsAppActivityClient<$Result.GetResult<Prisma.$WhatsAppActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhatsAppActivities.
     * @param {WhatsAppActivityCreateManyArgs} args - Arguments to create many WhatsAppActivities.
     * @example
     * // Create many WhatsAppActivities
     * const whatsAppActivity = await prisma.whatsAppActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsAppActivityCreateManyArgs>(args?: SelectSubset<T, WhatsAppActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsAppActivities and returns the data saved in the database.
     * @param {WhatsAppActivityCreateManyAndReturnArgs} args - Arguments to create many WhatsAppActivities.
     * @example
     * // Create many WhatsAppActivities
     * const whatsAppActivity = await prisma.whatsAppActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsAppActivities and only return the `id`
     * const whatsAppActivityWithIdOnly = await prisma.whatsAppActivity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsAppActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsAppActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhatsAppActivity.
     * @param {WhatsAppActivityDeleteArgs} args - Arguments to delete one WhatsAppActivity.
     * @example
     * // Delete one WhatsAppActivity
     * const WhatsAppActivity = await prisma.whatsAppActivity.delete({
     *   where: {
     *     // ... filter to delete one WhatsAppActivity
     *   }
     * })
     * 
     */
    delete<T extends WhatsAppActivityDeleteArgs>(args: SelectSubset<T, WhatsAppActivityDeleteArgs<ExtArgs>>): Prisma__WhatsAppActivityClient<$Result.GetResult<Prisma.$WhatsAppActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhatsAppActivity.
     * @param {WhatsAppActivityUpdateArgs} args - Arguments to update one WhatsAppActivity.
     * @example
     * // Update one WhatsAppActivity
     * const whatsAppActivity = await prisma.whatsAppActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsAppActivityUpdateArgs>(args: SelectSubset<T, WhatsAppActivityUpdateArgs<ExtArgs>>): Prisma__WhatsAppActivityClient<$Result.GetResult<Prisma.$WhatsAppActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhatsAppActivities.
     * @param {WhatsAppActivityDeleteManyArgs} args - Arguments to filter WhatsAppActivities to delete.
     * @example
     * // Delete a few WhatsAppActivities
     * const { count } = await prisma.whatsAppActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsAppActivityDeleteManyArgs>(args?: SelectSubset<T, WhatsAppActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsAppActivities
     * const whatsAppActivity = await prisma.whatsAppActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsAppActivityUpdateManyArgs>(args: SelectSubset<T, WhatsAppActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppActivities and returns the data updated in the database.
     * @param {WhatsAppActivityUpdateManyAndReturnArgs} args - Arguments to update many WhatsAppActivities.
     * @example
     * // Update many WhatsAppActivities
     * const whatsAppActivity = await prisma.whatsAppActivity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhatsAppActivities and only return the `id`
     * const whatsAppActivityWithIdOnly = await prisma.whatsAppActivity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhatsAppActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, WhatsAppActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhatsAppActivity.
     * @param {WhatsAppActivityUpsertArgs} args - Arguments to update or create a WhatsAppActivity.
     * @example
     * // Update or create a WhatsAppActivity
     * const whatsAppActivity = await prisma.whatsAppActivity.upsert({
     *   create: {
     *     // ... data to create a WhatsAppActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsAppActivity we want to update
     *   }
     * })
     */
    upsert<T extends WhatsAppActivityUpsertArgs>(args: SelectSubset<T, WhatsAppActivityUpsertArgs<ExtArgs>>): Prisma__WhatsAppActivityClient<$Result.GetResult<Prisma.$WhatsAppActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhatsAppActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppActivityCountArgs} args - Arguments to filter WhatsAppActivities to count.
     * @example
     * // Count the number of WhatsAppActivities
     * const count = await prisma.whatsAppActivity.count({
     *   where: {
     *     // ... the filter for the WhatsAppActivities we want to count
     *   }
     * })
    **/
    count<T extends WhatsAppActivityCountArgs>(
      args?: Subset<T, WhatsAppActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsAppActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsAppActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsAppActivityAggregateArgs>(args: Subset<T, WhatsAppActivityAggregateArgs>): Prisma.PrismaPromise<GetWhatsAppActivityAggregateType<T>>

    /**
     * Group by WhatsAppActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsAppActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsAppActivityGroupByArgs['orderBy'] }
        : { orderBy?: WhatsAppActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsAppActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsAppActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsAppActivity model
   */
  readonly fields: WhatsAppActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsAppActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsAppActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends WhatsAppCampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppCampaignDefaultArgs<ExtArgs>>): Prisma__WhatsAppCampaignClient<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsAppActivity model
   */
  interface WhatsAppActivityFieldRefs {
    readonly id: FieldRef<"WhatsAppActivity", 'String'>
    readonly campaignId: FieldRef<"WhatsAppActivity", 'String'>
    readonly contactId: FieldRef<"WhatsAppActivity", 'String'>
    readonly type: FieldRef<"WhatsAppActivity", 'ActivityType'>
    readonly timestamp: FieldRef<"WhatsAppActivity", 'DateTime'>
    readonly metadata: FieldRef<"WhatsAppActivity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WhatsAppActivity findUnique
   */
  export type WhatsAppActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppActivity
     */
    select?: WhatsAppActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppActivity
     */
    omit?: WhatsAppActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppActivityInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppActivity to fetch.
     */
    where: WhatsAppActivityWhereUniqueInput
  }

  /**
   * WhatsAppActivity findUniqueOrThrow
   */
  export type WhatsAppActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppActivity
     */
    select?: WhatsAppActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppActivity
     */
    omit?: WhatsAppActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppActivityInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppActivity to fetch.
     */
    where: WhatsAppActivityWhereUniqueInput
  }

  /**
   * WhatsAppActivity findFirst
   */
  export type WhatsAppActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppActivity
     */
    select?: WhatsAppActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppActivity
     */
    omit?: WhatsAppActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppActivityInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppActivity to fetch.
     */
    where?: WhatsAppActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppActivities to fetch.
     */
    orderBy?: WhatsAppActivityOrderByWithRelationInput | WhatsAppActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppActivities.
     */
    cursor?: WhatsAppActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppActivities.
     */
    distinct?: WhatsAppActivityScalarFieldEnum | WhatsAppActivityScalarFieldEnum[]
  }

  /**
   * WhatsAppActivity findFirstOrThrow
   */
  export type WhatsAppActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppActivity
     */
    select?: WhatsAppActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppActivity
     */
    omit?: WhatsAppActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppActivityInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppActivity to fetch.
     */
    where?: WhatsAppActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppActivities to fetch.
     */
    orderBy?: WhatsAppActivityOrderByWithRelationInput | WhatsAppActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppActivities.
     */
    cursor?: WhatsAppActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppActivities.
     */
    distinct?: WhatsAppActivityScalarFieldEnum | WhatsAppActivityScalarFieldEnum[]
  }

  /**
   * WhatsAppActivity findMany
   */
  export type WhatsAppActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppActivity
     */
    select?: WhatsAppActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppActivity
     */
    omit?: WhatsAppActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppActivityInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppActivities to fetch.
     */
    where?: WhatsAppActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppActivities to fetch.
     */
    orderBy?: WhatsAppActivityOrderByWithRelationInput | WhatsAppActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsAppActivities.
     */
    cursor?: WhatsAppActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppActivities.
     */
    skip?: number
    distinct?: WhatsAppActivityScalarFieldEnum | WhatsAppActivityScalarFieldEnum[]
  }

  /**
   * WhatsAppActivity create
   */
  export type WhatsAppActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppActivity
     */
    select?: WhatsAppActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppActivity
     */
    omit?: WhatsAppActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsAppActivity.
     */
    data: XOR<WhatsAppActivityCreateInput, WhatsAppActivityUncheckedCreateInput>
  }

  /**
   * WhatsAppActivity createMany
   */
  export type WhatsAppActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsAppActivities.
     */
    data: WhatsAppActivityCreateManyInput | WhatsAppActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsAppActivity createManyAndReturn
   */
  export type WhatsAppActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppActivity
     */
    select?: WhatsAppActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppActivity
     */
    omit?: WhatsAppActivityOmit<ExtArgs> | null
    /**
     * The data used to create many WhatsAppActivities.
     */
    data: WhatsAppActivityCreateManyInput | WhatsAppActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppActivity update
   */
  export type WhatsAppActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppActivity
     */
    select?: WhatsAppActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppActivity
     */
    omit?: WhatsAppActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsAppActivity.
     */
    data: XOR<WhatsAppActivityUpdateInput, WhatsAppActivityUncheckedUpdateInput>
    /**
     * Choose, which WhatsAppActivity to update.
     */
    where: WhatsAppActivityWhereUniqueInput
  }

  /**
   * WhatsAppActivity updateMany
   */
  export type WhatsAppActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsAppActivities.
     */
    data: XOR<WhatsAppActivityUpdateManyMutationInput, WhatsAppActivityUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppActivities to update
     */
    where?: WhatsAppActivityWhereInput
    /**
     * Limit how many WhatsAppActivities to update.
     */
    limit?: number
  }

  /**
   * WhatsAppActivity updateManyAndReturn
   */
  export type WhatsAppActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppActivity
     */
    select?: WhatsAppActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppActivity
     */
    omit?: WhatsAppActivityOmit<ExtArgs> | null
    /**
     * The data used to update WhatsAppActivities.
     */
    data: XOR<WhatsAppActivityUpdateManyMutationInput, WhatsAppActivityUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppActivities to update
     */
    where?: WhatsAppActivityWhereInput
    /**
     * Limit how many WhatsAppActivities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppActivity upsert
   */
  export type WhatsAppActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppActivity
     */
    select?: WhatsAppActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppActivity
     */
    omit?: WhatsAppActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsAppActivity to update in case it exists.
     */
    where: WhatsAppActivityWhereUniqueInput
    /**
     * In case the WhatsAppActivity found by the `where` argument doesn't exist, create a new WhatsAppActivity with this data.
     */
    create: XOR<WhatsAppActivityCreateInput, WhatsAppActivityUncheckedCreateInput>
    /**
     * In case the WhatsAppActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsAppActivityUpdateInput, WhatsAppActivityUncheckedUpdateInput>
  }

  /**
   * WhatsAppActivity delete
   */
  export type WhatsAppActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppActivity
     */
    select?: WhatsAppActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppActivity
     */
    omit?: WhatsAppActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppActivityInclude<ExtArgs> | null
    /**
     * Filter which WhatsAppActivity to delete.
     */
    where: WhatsAppActivityWhereUniqueInput
  }

  /**
   * WhatsAppActivity deleteMany
   */
  export type WhatsAppActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppActivities to delete
     */
    where?: WhatsAppActivityWhereInput
    /**
     * Limit how many WhatsAppActivities to delete.
     */
    limit?: number
  }

  /**
   * WhatsAppActivity without action
   */
  export type WhatsAppActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppActivity
     */
    select?: WhatsAppActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppActivity
     */
    omit?: WhatsAppActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppActivityInclude<ExtArgs> | null
  }


  /**
   * Model Workflow
   */

  export type AggregateWorkflow = {
    _count: WorkflowCountAggregateOutputType | null
    _min: WorkflowMinAggregateOutputType | null
    _max: WorkflowMaxAggregateOutputType | null
  }

  export type WorkflowMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.WorkflowStatus | null
    definition: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type WorkflowMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.WorkflowStatus | null
    definition: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type WorkflowCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    definition: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type WorkflowMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    definition?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type WorkflowMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    definition?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type WorkflowCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    definition?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type WorkflowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workflow to aggregate.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workflows
    **/
    _count?: true | WorkflowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowMaxAggregateInputType
  }

  export type GetWorkflowAggregateType<T extends WorkflowAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflow[P]>
      : GetScalarType<T[P], AggregateWorkflow[P]>
  }




  export type WorkflowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithAggregationInput | WorkflowOrderByWithAggregationInput[]
    by: WorkflowScalarFieldEnum[] | WorkflowScalarFieldEnum
    having?: WorkflowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowCountAggregateInputType | true
    _min?: WorkflowMinAggregateInputType
    _max?: WorkflowMaxAggregateInputType
  }

  export type WorkflowGroupByOutputType = {
    id: string
    name: string
    description: string | null
    status: $Enums.WorkflowStatus
    definition: string
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: WorkflowCountAggregateOutputType | null
    _min: WorkflowMinAggregateOutputType | null
    _max: WorkflowMaxAggregateOutputType | null
  }

  type GetWorkflowGroupByPayload<T extends WorkflowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    definition?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    nodes?: boolean | Workflow$nodesArgs<ExtArgs>
    triggers?: boolean | Workflow$triggersArgs<ExtArgs>
    _count?: boolean | WorkflowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflow"]>

  export type WorkflowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    definition?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflow"]>

  export type WorkflowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    definition?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflow"]>

  export type WorkflowSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    definition?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type WorkflowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "status" | "definition" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["workflow"]>
  export type WorkflowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    nodes?: boolean | Workflow$nodesArgs<ExtArgs>
    triggers?: boolean | Workflow$triggersArgs<ExtArgs>
    _count?: boolean | WorkflowCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkflowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WorkflowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WorkflowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workflow"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      nodes: Prisma.$WorkflowNodePayload<ExtArgs>[]
      triggers: Prisma.$WorkflowTriggerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      status: $Enums.WorkflowStatus
      definition: string
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["workflow"]>
    composites: {}
  }

  type WorkflowGetPayload<S extends boolean | null | undefined | WorkflowDefaultArgs> = $Result.GetResult<Prisma.$WorkflowPayload, S>

  type WorkflowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkflowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkflowCountAggregateInputType | true
    }

  export interface WorkflowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workflow'], meta: { name: 'Workflow' } }
    /**
     * Find zero or one Workflow that matches the filter.
     * @param {WorkflowFindUniqueArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowFindUniqueArgs>(args: SelectSubset<T, WorkflowFindUniqueArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Workflow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkflowFindUniqueOrThrowArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workflow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindFirstArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowFindFirstArgs>(args?: SelectSubset<T, WorkflowFindFirstArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workflow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindFirstOrThrowArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Workflows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workflows
     * const workflows = await prisma.workflow.findMany()
     * 
     * // Get first 10 Workflows
     * const workflows = await prisma.workflow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowWithIdOnly = await prisma.workflow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowFindManyArgs>(args?: SelectSubset<T, WorkflowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Workflow.
     * @param {WorkflowCreateArgs} args - Arguments to create a Workflow.
     * @example
     * // Create one Workflow
     * const Workflow = await prisma.workflow.create({
     *   data: {
     *     // ... data to create a Workflow
     *   }
     * })
     * 
     */
    create<T extends WorkflowCreateArgs>(args: SelectSubset<T, WorkflowCreateArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Workflows.
     * @param {WorkflowCreateManyArgs} args - Arguments to create many Workflows.
     * @example
     * // Create many Workflows
     * const workflow = await prisma.workflow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowCreateManyArgs>(args?: SelectSubset<T, WorkflowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workflows and returns the data saved in the database.
     * @param {WorkflowCreateManyAndReturnArgs} args - Arguments to create many Workflows.
     * @example
     * // Create many Workflows
     * const workflow = await prisma.workflow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workflows and only return the `id`
     * const workflowWithIdOnly = await prisma.workflow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Workflow.
     * @param {WorkflowDeleteArgs} args - Arguments to delete one Workflow.
     * @example
     * // Delete one Workflow
     * const Workflow = await prisma.workflow.delete({
     *   where: {
     *     // ... filter to delete one Workflow
     *   }
     * })
     * 
     */
    delete<T extends WorkflowDeleteArgs>(args: SelectSubset<T, WorkflowDeleteArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Workflow.
     * @param {WorkflowUpdateArgs} args - Arguments to update one Workflow.
     * @example
     * // Update one Workflow
     * const workflow = await prisma.workflow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowUpdateArgs>(args: SelectSubset<T, WorkflowUpdateArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Workflows.
     * @param {WorkflowDeleteManyArgs} args - Arguments to filter Workflows to delete.
     * @example
     * // Delete a few Workflows
     * const { count } = await prisma.workflow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowDeleteManyArgs>(args?: SelectSubset<T, WorkflowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workflows
     * const workflow = await prisma.workflow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowUpdateManyArgs>(args: SelectSubset<T, WorkflowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workflows and returns the data updated in the database.
     * @param {WorkflowUpdateManyAndReturnArgs} args - Arguments to update many Workflows.
     * @example
     * // Update many Workflows
     * const workflow = await prisma.workflow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Workflows and only return the `id`
     * const workflowWithIdOnly = await prisma.workflow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkflowUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkflowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Workflow.
     * @param {WorkflowUpsertArgs} args - Arguments to update or create a Workflow.
     * @example
     * // Update or create a Workflow
     * const workflow = await prisma.workflow.upsert({
     *   create: {
     *     // ... data to create a Workflow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workflow we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowUpsertArgs>(args: SelectSubset<T, WorkflowUpsertArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Workflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowCountArgs} args - Arguments to filter Workflows to count.
     * @example
     * // Count the number of Workflows
     * const count = await prisma.workflow.count({
     *   where: {
     *     // ... the filter for the Workflows we want to count
     *   }
     * })
    **/
    count<T extends WorkflowCountArgs>(
      args?: Subset<T, WorkflowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowAggregateArgs>(args: Subset<T, WorkflowAggregateArgs>): Prisma.PrismaPromise<GetWorkflowAggregateType<T>>

    /**
     * Group by Workflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workflow model
   */
  readonly fields: WorkflowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workflow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    nodes<T extends Workflow$nodesArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$nodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowNodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    triggers<T extends Workflow$triggersArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$triggersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowTriggerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workflow model
   */
  interface WorkflowFieldRefs {
    readonly id: FieldRef<"Workflow", 'String'>
    readonly name: FieldRef<"Workflow", 'String'>
    readonly description: FieldRef<"Workflow", 'String'>
    readonly status: FieldRef<"Workflow", 'WorkflowStatus'>
    readonly definition: FieldRef<"Workflow", 'String'>
    readonly createdAt: FieldRef<"Workflow", 'DateTime'>
    readonly updatedAt: FieldRef<"Workflow", 'DateTime'>
    readonly createdById: FieldRef<"Workflow", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Workflow findUnique
   */
  export type WorkflowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow findUniqueOrThrow
   */
  export type WorkflowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow findFirst
   */
  export type WorkflowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workflows.
     */
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Workflow findFirstOrThrow
   */
  export type WorkflowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workflows.
     */
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Workflow findMany
   */
  export type WorkflowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflows to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Workflow create
   */
  export type WorkflowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * The data needed to create a Workflow.
     */
    data: XOR<WorkflowCreateInput, WorkflowUncheckedCreateInput>
  }

  /**
   * Workflow createMany
   */
  export type WorkflowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workflows.
     */
    data: WorkflowCreateManyInput | WorkflowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workflow createManyAndReturn
   */
  export type WorkflowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * The data used to create many Workflows.
     */
    data: WorkflowCreateManyInput | WorkflowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workflow update
   */
  export type WorkflowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * The data needed to update a Workflow.
     */
    data: XOR<WorkflowUpdateInput, WorkflowUncheckedUpdateInput>
    /**
     * Choose, which Workflow to update.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow updateMany
   */
  export type WorkflowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workflows.
     */
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyInput>
    /**
     * Filter which Workflows to update
     */
    where?: WorkflowWhereInput
    /**
     * Limit how many Workflows to update.
     */
    limit?: number
  }

  /**
   * Workflow updateManyAndReturn
   */
  export type WorkflowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * The data used to update Workflows.
     */
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyInput>
    /**
     * Filter which Workflows to update
     */
    where?: WorkflowWhereInput
    /**
     * Limit how many Workflows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workflow upsert
   */
  export type WorkflowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * The filter to search for the Workflow to update in case it exists.
     */
    where: WorkflowWhereUniqueInput
    /**
     * In case the Workflow found by the `where` argument doesn't exist, create a new Workflow with this data.
     */
    create: XOR<WorkflowCreateInput, WorkflowUncheckedCreateInput>
    /**
     * In case the Workflow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowUpdateInput, WorkflowUncheckedUpdateInput>
  }

  /**
   * Workflow delete
   */
  export type WorkflowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter which Workflow to delete.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow deleteMany
   */
  export type WorkflowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workflows to delete
     */
    where?: WorkflowWhereInput
    /**
     * Limit how many Workflows to delete.
     */
    limit?: number
  }

  /**
   * Workflow.nodes
   */
  export type Workflow$nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowNode
     */
    select?: WorkflowNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowNode
     */
    omit?: WorkflowNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowNodeInclude<ExtArgs> | null
    where?: WorkflowNodeWhereInput
    orderBy?: WorkflowNodeOrderByWithRelationInput | WorkflowNodeOrderByWithRelationInput[]
    cursor?: WorkflowNodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowNodeScalarFieldEnum | WorkflowNodeScalarFieldEnum[]
  }

  /**
   * Workflow.triggers
   */
  export type Workflow$triggersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTrigger
     */
    select?: WorkflowTriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowTrigger
     */
    omit?: WorkflowTriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTriggerInclude<ExtArgs> | null
    where?: WorkflowTriggerWhereInput
    orderBy?: WorkflowTriggerOrderByWithRelationInput | WorkflowTriggerOrderByWithRelationInput[]
    cursor?: WorkflowTriggerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowTriggerScalarFieldEnum | WorkflowTriggerScalarFieldEnum[]
  }

  /**
   * Workflow without action
   */
  export type WorkflowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowNode
   */

  export type AggregateWorkflowNode = {
    _count: WorkflowNodeCountAggregateOutputType | null
    _avg: WorkflowNodeAvgAggregateOutputType | null
    _sum: WorkflowNodeSumAggregateOutputType | null
    _min: WorkflowNodeMinAggregateOutputType | null
    _max: WorkflowNodeMaxAggregateOutputType | null
  }

  export type WorkflowNodeAvgAggregateOutputType = {
    positionX: number | null
    positionY: number | null
  }

  export type WorkflowNodeSumAggregateOutputType = {
    positionX: number | null
    positionY: number | null
  }

  export type WorkflowNodeMinAggregateOutputType = {
    id: string | null
    workflowId: string | null
    type: $Enums.WorkflowNodeType | null
    name: string | null
    config: string | null
    positionX: number | null
    positionY: number | null
  }

  export type WorkflowNodeMaxAggregateOutputType = {
    id: string | null
    workflowId: string | null
    type: $Enums.WorkflowNodeType | null
    name: string | null
    config: string | null
    positionX: number | null
    positionY: number | null
  }

  export type WorkflowNodeCountAggregateOutputType = {
    id: number
    workflowId: number
    type: number
    name: number
    config: number
    positionX: number
    positionY: number
    _all: number
  }


  export type WorkflowNodeAvgAggregateInputType = {
    positionX?: true
    positionY?: true
  }

  export type WorkflowNodeSumAggregateInputType = {
    positionX?: true
    positionY?: true
  }

  export type WorkflowNodeMinAggregateInputType = {
    id?: true
    workflowId?: true
    type?: true
    name?: true
    config?: true
    positionX?: true
    positionY?: true
  }

  export type WorkflowNodeMaxAggregateInputType = {
    id?: true
    workflowId?: true
    type?: true
    name?: true
    config?: true
    positionX?: true
    positionY?: true
  }

  export type WorkflowNodeCountAggregateInputType = {
    id?: true
    workflowId?: true
    type?: true
    name?: true
    config?: true
    positionX?: true
    positionY?: true
    _all?: true
  }

  export type WorkflowNodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowNode to aggregate.
     */
    where?: WorkflowNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowNodes to fetch.
     */
    orderBy?: WorkflowNodeOrderByWithRelationInput | WorkflowNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowNodes
    **/
    _count?: true | WorkflowNodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkflowNodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkflowNodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowNodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowNodeMaxAggregateInputType
  }

  export type GetWorkflowNodeAggregateType<T extends WorkflowNodeAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowNode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowNode[P]>
      : GetScalarType<T[P], AggregateWorkflowNode[P]>
  }




  export type WorkflowNodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowNodeWhereInput
    orderBy?: WorkflowNodeOrderByWithAggregationInput | WorkflowNodeOrderByWithAggregationInput[]
    by: WorkflowNodeScalarFieldEnum[] | WorkflowNodeScalarFieldEnum
    having?: WorkflowNodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowNodeCountAggregateInputType | true
    _avg?: WorkflowNodeAvgAggregateInputType
    _sum?: WorkflowNodeSumAggregateInputType
    _min?: WorkflowNodeMinAggregateInputType
    _max?: WorkflowNodeMaxAggregateInputType
  }

  export type WorkflowNodeGroupByOutputType = {
    id: string
    workflowId: string
    type: $Enums.WorkflowNodeType
    name: string | null
    config: string
    positionX: number | null
    positionY: number | null
    _count: WorkflowNodeCountAggregateOutputType | null
    _avg: WorkflowNodeAvgAggregateOutputType | null
    _sum: WorkflowNodeSumAggregateOutputType | null
    _min: WorkflowNodeMinAggregateOutputType | null
    _max: WorkflowNodeMaxAggregateOutputType | null
  }

  type GetWorkflowNodeGroupByPayload<T extends WorkflowNodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowNodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowNodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowNodeGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowNodeGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowNodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    type?: boolean
    name?: boolean
    config?: boolean
    positionX?: boolean
    positionY?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    outgoing?: boolean | WorkflowNode$outgoingArgs<ExtArgs>
    incoming?: boolean | WorkflowNode$incomingArgs<ExtArgs>
    _count?: boolean | WorkflowNodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowNode"]>

  export type WorkflowNodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    type?: boolean
    name?: boolean
    config?: boolean
    positionX?: boolean
    positionY?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowNode"]>

  export type WorkflowNodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    type?: boolean
    name?: boolean
    config?: boolean
    positionX?: boolean
    positionY?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowNode"]>

  export type WorkflowNodeSelectScalar = {
    id?: boolean
    workflowId?: boolean
    type?: boolean
    name?: boolean
    config?: boolean
    positionX?: boolean
    positionY?: boolean
  }

  export type WorkflowNodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workflowId" | "type" | "name" | "config" | "positionX" | "positionY", ExtArgs["result"]["workflowNode"]>
  export type WorkflowNodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    outgoing?: boolean | WorkflowNode$outgoingArgs<ExtArgs>
    incoming?: boolean | WorkflowNode$incomingArgs<ExtArgs>
    _count?: boolean | WorkflowNodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkflowNodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
  }
  export type WorkflowNodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
  }

  export type $WorkflowNodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowNode"
    objects: {
      workflow: Prisma.$WorkflowPayload<ExtArgs>
      outgoing: Prisma.$ConnectionPayload<ExtArgs>[]
      incoming: Prisma.$ConnectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workflowId: string
      type: $Enums.WorkflowNodeType
      name: string | null
      config: string
      positionX: number | null
      positionY: number | null
    }, ExtArgs["result"]["workflowNode"]>
    composites: {}
  }

  type WorkflowNodeGetPayload<S extends boolean | null | undefined | WorkflowNodeDefaultArgs> = $Result.GetResult<Prisma.$WorkflowNodePayload, S>

  type WorkflowNodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkflowNodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkflowNodeCountAggregateInputType | true
    }

  export interface WorkflowNodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowNode'], meta: { name: 'WorkflowNode' } }
    /**
     * Find zero or one WorkflowNode that matches the filter.
     * @param {WorkflowNodeFindUniqueArgs} args - Arguments to find a WorkflowNode
     * @example
     * // Get one WorkflowNode
     * const workflowNode = await prisma.workflowNode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowNodeFindUniqueArgs>(args: SelectSubset<T, WorkflowNodeFindUniqueArgs<ExtArgs>>): Prisma__WorkflowNodeClient<$Result.GetResult<Prisma.$WorkflowNodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkflowNode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkflowNodeFindUniqueOrThrowArgs} args - Arguments to find a WorkflowNode
     * @example
     * // Get one WorkflowNode
     * const workflowNode = await prisma.workflowNode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowNodeFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowNodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowNodeClient<$Result.GetResult<Prisma.$WorkflowNodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkflowNode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowNodeFindFirstArgs} args - Arguments to find a WorkflowNode
     * @example
     * // Get one WorkflowNode
     * const workflowNode = await prisma.workflowNode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowNodeFindFirstArgs>(args?: SelectSubset<T, WorkflowNodeFindFirstArgs<ExtArgs>>): Prisma__WorkflowNodeClient<$Result.GetResult<Prisma.$WorkflowNodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkflowNode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowNodeFindFirstOrThrowArgs} args - Arguments to find a WorkflowNode
     * @example
     * // Get one WorkflowNode
     * const workflowNode = await prisma.workflowNode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowNodeFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowNodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowNodeClient<$Result.GetResult<Prisma.$WorkflowNodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkflowNodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowNodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowNodes
     * const workflowNodes = await prisma.workflowNode.findMany()
     * 
     * // Get first 10 WorkflowNodes
     * const workflowNodes = await prisma.workflowNode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowNodeWithIdOnly = await prisma.workflowNode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowNodeFindManyArgs>(args?: SelectSubset<T, WorkflowNodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowNodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkflowNode.
     * @param {WorkflowNodeCreateArgs} args - Arguments to create a WorkflowNode.
     * @example
     * // Create one WorkflowNode
     * const WorkflowNode = await prisma.workflowNode.create({
     *   data: {
     *     // ... data to create a WorkflowNode
     *   }
     * })
     * 
     */
    create<T extends WorkflowNodeCreateArgs>(args: SelectSubset<T, WorkflowNodeCreateArgs<ExtArgs>>): Prisma__WorkflowNodeClient<$Result.GetResult<Prisma.$WorkflowNodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkflowNodes.
     * @param {WorkflowNodeCreateManyArgs} args - Arguments to create many WorkflowNodes.
     * @example
     * // Create many WorkflowNodes
     * const workflowNode = await prisma.workflowNode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowNodeCreateManyArgs>(args?: SelectSubset<T, WorkflowNodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkflowNodes and returns the data saved in the database.
     * @param {WorkflowNodeCreateManyAndReturnArgs} args - Arguments to create many WorkflowNodes.
     * @example
     * // Create many WorkflowNodes
     * const workflowNode = await prisma.workflowNode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkflowNodes and only return the `id`
     * const workflowNodeWithIdOnly = await prisma.workflowNode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowNodeCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowNodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowNodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkflowNode.
     * @param {WorkflowNodeDeleteArgs} args - Arguments to delete one WorkflowNode.
     * @example
     * // Delete one WorkflowNode
     * const WorkflowNode = await prisma.workflowNode.delete({
     *   where: {
     *     // ... filter to delete one WorkflowNode
     *   }
     * })
     * 
     */
    delete<T extends WorkflowNodeDeleteArgs>(args: SelectSubset<T, WorkflowNodeDeleteArgs<ExtArgs>>): Prisma__WorkflowNodeClient<$Result.GetResult<Prisma.$WorkflowNodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkflowNode.
     * @param {WorkflowNodeUpdateArgs} args - Arguments to update one WorkflowNode.
     * @example
     * // Update one WorkflowNode
     * const workflowNode = await prisma.workflowNode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowNodeUpdateArgs>(args: SelectSubset<T, WorkflowNodeUpdateArgs<ExtArgs>>): Prisma__WorkflowNodeClient<$Result.GetResult<Prisma.$WorkflowNodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkflowNodes.
     * @param {WorkflowNodeDeleteManyArgs} args - Arguments to filter WorkflowNodes to delete.
     * @example
     * // Delete a few WorkflowNodes
     * const { count } = await prisma.workflowNode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowNodeDeleteManyArgs>(args?: SelectSubset<T, WorkflowNodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowNodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowNodes
     * const workflowNode = await prisma.workflowNode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowNodeUpdateManyArgs>(args: SelectSubset<T, WorkflowNodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowNodes and returns the data updated in the database.
     * @param {WorkflowNodeUpdateManyAndReturnArgs} args - Arguments to update many WorkflowNodes.
     * @example
     * // Update many WorkflowNodes
     * const workflowNode = await prisma.workflowNode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkflowNodes and only return the `id`
     * const workflowNodeWithIdOnly = await prisma.workflowNode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkflowNodeUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkflowNodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowNodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkflowNode.
     * @param {WorkflowNodeUpsertArgs} args - Arguments to update or create a WorkflowNode.
     * @example
     * // Update or create a WorkflowNode
     * const workflowNode = await prisma.workflowNode.upsert({
     *   create: {
     *     // ... data to create a WorkflowNode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowNode we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowNodeUpsertArgs>(args: SelectSubset<T, WorkflowNodeUpsertArgs<ExtArgs>>): Prisma__WorkflowNodeClient<$Result.GetResult<Prisma.$WorkflowNodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkflowNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowNodeCountArgs} args - Arguments to filter WorkflowNodes to count.
     * @example
     * // Count the number of WorkflowNodes
     * const count = await prisma.workflowNode.count({
     *   where: {
     *     // ... the filter for the WorkflowNodes we want to count
     *   }
     * })
    **/
    count<T extends WorkflowNodeCountArgs>(
      args?: Subset<T, WorkflowNodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowNodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowNodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowNodeAggregateArgs>(args: Subset<T, WorkflowNodeAggregateArgs>): Prisma.PrismaPromise<GetWorkflowNodeAggregateType<T>>

    /**
     * Group by WorkflowNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowNodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowNodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowNodeGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowNodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowNodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowNodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowNode model
   */
  readonly fields: WorkflowNodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowNode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowNodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workflow<T extends WorkflowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowDefaultArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    outgoing<T extends WorkflowNode$outgoingArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowNode$outgoingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    incoming<T extends WorkflowNode$incomingArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowNode$incomingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowNode model
   */
  interface WorkflowNodeFieldRefs {
    readonly id: FieldRef<"WorkflowNode", 'String'>
    readonly workflowId: FieldRef<"WorkflowNode", 'String'>
    readonly type: FieldRef<"WorkflowNode", 'WorkflowNodeType'>
    readonly name: FieldRef<"WorkflowNode", 'String'>
    readonly config: FieldRef<"WorkflowNode", 'String'>
    readonly positionX: FieldRef<"WorkflowNode", 'Float'>
    readonly positionY: FieldRef<"WorkflowNode", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowNode findUnique
   */
  export type WorkflowNodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowNode
     */
    select?: WorkflowNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowNode
     */
    omit?: WorkflowNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowNodeInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowNode to fetch.
     */
    where: WorkflowNodeWhereUniqueInput
  }

  /**
   * WorkflowNode findUniqueOrThrow
   */
  export type WorkflowNodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowNode
     */
    select?: WorkflowNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowNode
     */
    omit?: WorkflowNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowNodeInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowNode to fetch.
     */
    where: WorkflowNodeWhereUniqueInput
  }

  /**
   * WorkflowNode findFirst
   */
  export type WorkflowNodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowNode
     */
    select?: WorkflowNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowNode
     */
    omit?: WorkflowNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowNodeInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowNode to fetch.
     */
    where?: WorkflowNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowNodes to fetch.
     */
    orderBy?: WorkflowNodeOrderByWithRelationInput | WorkflowNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowNodes.
     */
    cursor?: WorkflowNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowNodes.
     */
    distinct?: WorkflowNodeScalarFieldEnum | WorkflowNodeScalarFieldEnum[]
  }

  /**
   * WorkflowNode findFirstOrThrow
   */
  export type WorkflowNodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowNode
     */
    select?: WorkflowNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowNode
     */
    omit?: WorkflowNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowNodeInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowNode to fetch.
     */
    where?: WorkflowNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowNodes to fetch.
     */
    orderBy?: WorkflowNodeOrderByWithRelationInput | WorkflowNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowNodes.
     */
    cursor?: WorkflowNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowNodes.
     */
    distinct?: WorkflowNodeScalarFieldEnum | WorkflowNodeScalarFieldEnum[]
  }

  /**
   * WorkflowNode findMany
   */
  export type WorkflowNodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowNode
     */
    select?: WorkflowNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowNode
     */
    omit?: WorkflowNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowNodeInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowNodes to fetch.
     */
    where?: WorkflowNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowNodes to fetch.
     */
    orderBy?: WorkflowNodeOrderByWithRelationInput | WorkflowNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowNodes.
     */
    cursor?: WorkflowNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowNodes.
     */
    skip?: number
    distinct?: WorkflowNodeScalarFieldEnum | WorkflowNodeScalarFieldEnum[]
  }

  /**
   * WorkflowNode create
   */
  export type WorkflowNodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowNode
     */
    select?: WorkflowNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowNode
     */
    omit?: WorkflowNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowNodeInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkflowNode.
     */
    data: XOR<WorkflowNodeCreateInput, WorkflowNodeUncheckedCreateInput>
  }

  /**
   * WorkflowNode createMany
   */
  export type WorkflowNodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowNodes.
     */
    data: WorkflowNodeCreateManyInput | WorkflowNodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowNode createManyAndReturn
   */
  export type WorkflowNodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowNode
     */
    select?: WorkflowNodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowNode
     */
    omit?: WorkflowNodeOmit<ExtArgs> | null
    /**
     * The data used to create many WorkflowNodes.
     */
    data: WorkflowNodeCreateManyInput | WorkflowNodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowNodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowNode update
   */
  export type WorkflowNodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowNode
     */
    select?: WorkflowNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowNode
     */
    omit?: WorkflowNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowNodeInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkflowNode.
     */
    data: XOR<WorkflowNodeUpdateInput, WorkflowNodeUncheckedUpdateInput>
    /**
     * Choose, which WorkflowNode to update.
     */
    where: WorkflowNodeWhereUniqueInput
  }

  /**
   * WorkflowNode updateMany
   */
  export type WorkflowNodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowNodes.
     */
    data: XOR<WorkflowNodeUpdateManyMutationInput, WorkflowNodeUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowNodes to update
     */
    where?: WorkflowNodeWhereInput
    /**
     * Limit how many WorkflowNodes to update.
     */
    limit?: number
  }

  /**
   * WorkflowNode updateManyAndReturn
   */
  export type WorkflowNodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowNode
     */
    select?: WorkflowNodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowNode
     */
    omit?: WorkflowNodeOmit<ExtArgs> | null
    /**
     * The data used to update WorkflowNodes.
     */
    data: XOR<WorkflowNodeUpdateManyMutationInput, WorkflowNodeUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowNodes to update
     */
    where?: WorkflowNodeWhereInput
    /**
     * Limit how many WorkflowNodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowNodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowNode upsert
   */
  export type WorkflowNodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowNode
     */
    select?: WorkflowNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowNode
     */
    omit?: WorkflowNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowNodeInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkflowNode to update in case it exists.
     */
    where: WorkflowNodeWhereUniqueInput
    /**
     * In case the WorkflowNode found by the `where` argument doesn't exist, create a new WorkflowNode with this data.
     */
    create: XOR<WorkflowNodeCreateInput, WorkflowNodeUncheckedCreateInput>
    /**
     * In case the WorkflowNode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowNodeUpdateInput, WorkflowNodeUncheckedUpdateInput>
  }

  /**
   * WorkflowNode delete
   */
  export type WorkflowNodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowNode
     */
    select?: WorkflowNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowNode
     */
    omit?: WorkflowNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowNodeInclude<ExtArgs> | null
    /**
     * Filter which WorkflowNode to delete.
     */
    where: WorkflowNodeWhereUniqueInput
  }

  /**
   * WorkflowNode deleteMany
   */
  export type WorkflowNodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowNodes to delete
     */
    where?: WorkflowNodeWhereInput
    /**
     * Limit how many WorkflowNodes to delete.
     */
    limit?: number
  }

  /**
   * WorkflowNode.outgoing
   */
  export type WorkflowNode$outgoingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    where?: ConnectionWhereInput
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    cursor?: ConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * WorkflowNode.incoming
   */
  export type WorkflowNode$incomingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    where?: ConnectionWhereInput
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    cursor?: ConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * WorkflowNode without action
   */
  export type WorkflowNodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowNode
     */
    select?: WorkflowNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowNode
     */
    omit?: WorkflowNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowNodeInclude<ExtArgs> | null
  }


  /**
   * Model Connection
   */

  export type AggregateConnection = {
    _count: ConnectionCountAggregateOutputType | null
    _min: ConnectionMinAggregateOutputType | null
    _max: ConnectionMaxAggregateOutputType | null
  }

  export type ConnectionMinAggregateOutputType = {
    id: string | null
    sourceId: string | null
    targetId: string | null
    condition: string | null
  }

  export type ConnectionMaxAggregateOutputType = {
    id: string | null
    sourceId: string | null
    targetId: string | null
    condition: string | null
  }

  export type ConnectionCountAggregateOutputType = {
    id: number
    sourceId: number
    targetId: number
    condition: number
    _all: number
  }


  export type ConnectionMinAggregateInputType = {
    id?: true
    sourceId?: true
    targetId?: true
    condition?: true
  }

  export type ConnectionMaxAggregateInputType = {
    id?: true
    sourceId?: true
    targetId?: true
    condition?: true
  }

  export type ConnectionCountAggregateInputType = {
    id?: true
    sourceId?: true
    targetId?: true
    condition?: true
    _all?: true
  }

  export type ConnectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Connection to aggregate.
     */
    where?: ConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Connections
    **/
    _count?: true | ConnectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConnectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConnectionMaxAggregateInputType
  }

  export type GetConnectionAggregateType<T extends ConnectionAggregateArgs> = {
        [P in keyof T & keyof AggregateConnection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConnection[P]>
      : GetScalarType<T[P], AggregateConnection[P]>
  }




  export type ConnectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionWhereInput
    orderBy?: ConnectionOrderByWithAggregationInput | ConnectionOrderByWithAggregationInput[]
    by: ConnectionScalarFieldEnum[] | ConnectionScalarFieldEnum
    having?: ConnectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConnectionCountAggregateInputType | true
    _min?: ConnectionMinAggregateInputType
    _max?: ConnectionMaxAggregateInputType
  }

  export type ConnectionGroupByOutputType = {
    id: string
    sourceId: string
    targetId: string
    condition: string | null
    _count: ConnectionCountAggregateOutputType | null
    _min: ConnectionMinAggregateOutputType | null
    _max: ConnectionMaxAggregateOutputType | null
  }

  type GetConnectionGroupByPayload<T extends ConnectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConnectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConnectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConnectionGroupByOutputType[P]>
            : GetScalarType<T[P], ConnectionGroupByOutputType[P]>
        }
      >
    >


  export type ConnectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceId?: boolean
    targetId?: boolean
    condition?: boolean
    source?: boolean | WorkflowNodeDefaultArgs<ExtArgs>
    target?: boolean | WorkflowNodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["connection"]>

  export type ConnectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceId?: boolean
    targetId?: boolean
    condition?: boolean
    source?: boolean | WorkflowNodeDefaultArgs<ExtArgs>
    target?: boolean | WorkflowNodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["connection"]>

  export type ConnectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceId?: boolean
    targetId?: boolean
    condition?: boolean
    source?: boolean | WorkflowNodeDefaultArgs<ExtArgs>
    target?: boolean | WorkflowNodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["connection"]>

  export type ConnectionSelectScalar = {
    id?: boolean
    sourceId?: boolean
    targetId?: boolean
    condition?: boolean
  }

  export type ConnectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sourceId" | "targetId" | "condition", ExtArgs["result"]["connection"]>
  export type ConnectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | WorkflowNodeDefaultArgs<ExtArgs>
    target?: boolean | WorkflowNodeDefaultArgs<ExtArgs>
  }
  export type ConnectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | WorkflowNodeDefaultArgs<ExtArgs>
    target?: boolean | WorkflowNodeDefaultArgs<ExtArgs>
  }
  export type ConnectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | WorkflowNodeDefaultArgs<ExtArgs>
    target?: boolean | WorkflowNodeDefaultArgs<ExtArgs>
  }

  export type $ConnectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Connection"
    objects: {
      source: Prisma.$WorkflowNodePayload<ExtArgs>
      target: Prisma.$WorkflowNodePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sourceId: string
      targetId: string
      condition: string | null
    }, ExtArgs["result"]["connection"]>
    composites: {}
  }

  type ConnectionGetPayload<S extends boolean | null | undefined | ConnectionDefaultArgs> = $Result.GetResult<Prisma.$ConnectionPayload, S>

  type ConnectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConnectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConnectionCountAggregateInputType | true
    }

  export interface ConnectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Connection'], meta: { name: 'Connection' } }
    /**
     * Find zero or one Connection that matches the filter.
     * @param {ConnectionFindUniqueArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConnectionFindUniqueArgs>(args: SelectSubset<T, ConnectionFindUniqueArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Connection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConnectionFindUniqueOrThrowArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConnectionFindUniqueOrThrowArgs>(args: SelectSubset<T, ConnectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Connection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionFindFirstArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConnectionFindFirstArgs>(args?: SelectSubset<T, ConnectionFindFirstArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Connection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionFindFirstOrThrowArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConnectionFindFirstOrThrowArgs>(args?: SelectSubset<T, ConnectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Connections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Connections
     * const connections = await prisma.connection.findMany()
     * 
     * // Get first 10 Connections
     * const connections = await prisma.connection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const connectionWithIdOnly = await prisma.connection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConnectionFindManyArgs>(args?: SelectSubset<T, ConnectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Connection.
     * @param {ConnectionCreateArgs} args - Arguments to create a Connection.
     * @example
     * // Create one Connection
     * const Connection = await prisma.connection.create({
     *   data: {
     *     // ... data to create a Connection
     *   }
     * })
     * 
     */
    create<T extends ConnectionCreateArgs>(args: SelectSubset<T, ConnectionCreateArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Connections.
     * @param {ConnectionCreateManyArgs} args - Arguments to create many Connections.
     * @example
     * // Create many Connections
     * const connection = await prisma.connection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConnectionCreateManyArgs>(args?: SelectSubset<T, ConnectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Connections and returns the data saved in the database.
     * @param {ConnectionCreateManyAndReturnArgs} args - Arguments to create many Connections.
     * @example
     * // Create many Connections
     * const connection = await prisma.connection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Connections and only return the `id`
     * const connectionWithIdOnly = await prisma.connection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConnectionCreateManyAndReturnArgs>(args?: SelectSubset<T, ConnectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Connection.
     * @param {ConnectionDeleteArgs} args - Arguments to delete one Connection.
     * @example
     * // Delete one Connection
     * const Connection = await prisma.connection.delete({
     *   where: {
     *     // ... filter to delete one Connection
     *   }
     * })
     * 
     */
    delete<T extends ConnectionDeleteArgs>(args: SelectSubset<T, ConnectionDeleteArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Connection.
     * @param {ConnectionUpdateArgs} args - Arguments to update one Connection.
     * @example
     * // Update one Connection
     * const connection = await prisma.connection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConnectionUpdateArgs>(args: SelectSubset<T, ConnectionUpdateArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Connections.
     * @param {ConnectionDeleteManyArgs} args - Arguments to filter Connections to delete.
     * @example
     * // Delete a few Connections
     * const { count } = await prisma.connection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConnectionDeleteManyArgs>(args?: SelectSubset<T, ConnectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Connections
     * const connection = await prisma.connection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConnectionUpdateManyArgs>(args: SelectSubset<T, ConnectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Connections and returns the data updated in the database.
     * @param {ConnectionUpdateManyAndReturnArgs} args - Arguments to update many Connections.
     * @example
     * // Update many Connections
     * const connection = await prisma.connection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Connections and only return the `id`
     * const connectionWithIdOnly = await prisma.connection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConnectionUpdateManyAndReturnArgs>(args: SelectSubset<T, ConnectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Connection.
     * @param {ConnectionUpsertArgs} args - Arguments to update or create a Connection.
     * @example
     * // Update or create a Connection
     * const connection = await prisma.connection.upsert({
     *   create: {
     *     // ... data to create a Connection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Connection we want to update
     *   }
     * })
     */
    upsert<T extends ConnectionUpsertArgs>(args: SelectSubset<T, ConnectionUpsertArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionCountArgs} args - Arguments to filter Connections to count.
     * @example
     * // Count the number of Connections
     * const count = await prisma.connection.count({
     *   where: {
     *     // ... the filter for the Connections we want to count
     *   }
     * })
    **/
    count<T extends ConnectionCountArgs>(
      args?: Subset<T, ConnectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConnectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Connection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConnectionAggregateArgs>(args: Subset<T, ConnectionAggregateArgs>): Prisma.PrismaPromise<GetConnectionAggregateType<T>>

    /**
     * Group by Connection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConnectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConnectionGroupByArgs['orderBy'] }
        : { orderBy?: ConnectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConnectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConnectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Connection model
   */
  readonly fields: ConnectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Connection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConnectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    source<T extends WorkflowNodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowNodeDefaultArgs<ExtArgs>>): Prisma__WorkflowNodeClient<$Result.GetResult<Prisma.$WorkflowNodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    target<T extends WorkflowNodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowNodeDefaultArgs<ExtArgs>>): Prisma__WorkflowNodeClient<$Result.GetResult<Prisma.$WorkflowNodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Connection model
   */
  interface ConnectionFieldRefs {
    readonly id: FieldRef<"Connection", 'String'>
    readonly sourceId: FieldRef<"Connection", 'String'>
    readonly targetId: FieldRef<"Connection", 'String'>
    readonly condition: FieldRef<"Connection", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Connection findUnique
   */
  export type ConnectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connection to fetch.
     */
    where: ConnectionWhereUniqueInput
  }

  /**
   * Connection findUniqueOrThrow
   */
  export type ConnectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connection to fetch.
     */
    where: ConnectionWhereUniqueInput
  }

  /**
   * Connection findFirst
   */
  export type ConnectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connection to fetch.
     */
    where?: ConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Connections.
     */
    cursor?: ConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Connections.
     */
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * Connection findFirstOrThrow
   */
  export type ConnectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connection to fetch.
     */
    where?: ConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Connections.
     */
    cursor?: ConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Connections.
     */
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * Connection findMany
   */
  export type ConnectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connections to fetch.
     */
    where?: ConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Connections.
     */
    cursor?: ConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Connections.
     */
    skip?: number
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * Connection create
   */
  export type ConnectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Connection.
     */
    data: XOR<ConnectionCreateInput, ConnectionUncheckedCreateInput>
  }

  /**
   * Connection createMany
   */
  export type ConnectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Connections.
     */
    data: ConnectionCreateManyInput | ConnectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Connection createManyAndReturn
   */
  export type ConnectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * The data used to create many Connections.
     */
    data: ConnectionCreateManyInput | ConnectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Connection update
   */
  export type ConnectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Connection.
     */
    data: XOR<ConnectionUpdateInput, ConnectionUncheckedUpdateInput>
    /**
     * Choose, which Connection to update.
     */
    where: ConnectionWhereUniqueInput
  }

  /**
   * Connection updateMany
   */
  export type ConnectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Connections.
     */
    data: XOR<ConnectionUpdateManyMutationInput, ConnectionUncheckedUpdateManyInput>
    /**
     * Filter which Connections to update
     */
    where?: ConnectionWhereInput
    /**
     * Limit how many Connections to update.
     */
    limit?: number
  }

  /**
   * Connection updateManyAndReturn
   */
  export type ConnectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * The data used to update Connections.
     */
    data: XOR<ConnectionUpdateManyMutationInput, ConnectionUncheckedUpdateManyInput>
    /**
     * Filter which Connections to update
     */
    where?: ConnectionWhereInput
    /**
     * Limit how many Connections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Connection upsert
   */
  export type ConnectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Connection to update in case it exists.
     */
    where: ConnectionWhereUniqueInput
    /**
     * In case the Connection found by the `where` argument doesn't exist, create a new Connection with this data.
     */
    create: XOR<ConnectionCreateInput, ConnectionUncheckedCreateInput>
    /**
     * In case the Connection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConnectionUpdateInput, ConnectionUncheckedUpdateInput>
  }

  /**
   * Connection delete
   */
  export type ConnectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter which Connection to delete.
     */
    where: ConnectionWhereUniqueInput
  }

  /**
   * Connection deleteMany
   */
  export type ConnectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Connections to delete
     */
    where?: ConnectionWhereInput
    /**
     * Limit how many Connections to delete.
     */
    limit?: number
  }

  /**
   * Connection without action
   */
  export type ConnectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowTrigger
   */

  export type AggregateWorkflowTrigger = {
    _count: WorkflowTriggerCountAggregateOutputType | null
    _min: WorkflowTriggerMinAggregateOutputType | null
    _max: WorkflowTriggerMaxAggregateOutputType | null
  }

  export type WorkflowTriggerMinAggregateOutputType = {
    id: string | null
    workflowId: string | null
    type: $Enums.TriggerType | null
    config: string | null
  }

  export type WorkflowTriggerMaxAggregateOutputType = {
    id: string | null
    workflowId: string | null
    type: $Enums.TriggerType | null
    config: string | null
  }

  export type WorkflowTriggerCountAggregateOutputType = {
    id: number
    workflowId: number
    type: number
    config: number
    _all: number
  }


  export type WorkflowTriggerMinAggregateInputType = {
    id?: true
    workflowId?: true
    type?: true
    config?: true
  }

  export type WorkflowTriggerMaxAggregateInputType = {
    id?: true
    workflowId?: true
    type?: true
    config?: true
  }

  export type WorkflowTriggerCountAggregateInputType = {
    id?: true
    workflowId?: true
    type?: true
    config?: true
    _all?: true
  }

  export type WorkflowTriggerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowTrigger to aggregate.
     */
    where?: WorkflowTriggerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowTriggers to fetch.
     */
    orderBy?: WorkflowTriggerOrderByWithRelationInput | WorkflowTriggerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowTriggerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowTriggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowTriggers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowTriggers
    **/
    _count?: true | WorkflowTriggerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowTriggerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowTriggerMaxAggregateInputType
  }

  export type GetWorkflowTriggerAggregateType<T extends WorkflowTriggerAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowTrigger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowTrigger[P]>
      : GetScalarType<T[P], AggregateWorkflowTrigger[P]>
  }




  export type WorkflowTriggerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowTriggerWhereInput
    orderBy?: WorkflowTriggerOrderByWithAggregationInput | WorkflowTriggerOrderByWithAggregationInput[]
    by: WorkflowTriggerScalarFieldEnum[] | WorkflowTriggerScalarFieldEnum
    having?: WorkflowTriggerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowTriggerCountAggregateInputType | true
    _min?: WorkflowTriggerMinAggregateInputType
    _max?: WorkflowTriggerMaxAggregateInputType
  }

  export type WorkflowTriggerGroupByOutputType = {
    id: string
    workflowId: string
    type: $Enums.TriggerType
    config: string
    _count: WorkflowTriggerCountAggregateOutputType | null
    _min: WorkflowTriggerMinAggregateOutputType | null
    _max: WorkflowTriggerMaxAggregateOutputType | null
  }

  type GetWorkflowTriggerGroupByPayload<T extends WorkflowTriggerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowTriggerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowTriggerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowTriggerGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowTriggerGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowTriggerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    type?: boolean
    config?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowTrigger"]>

  export type WorkflowTriggerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    type?: boolean
    config?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowTrigger"]>

  export type WorkflowTriggerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    type?: boolean
    config?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowTrigger"]>

  export type WorkflowTriggerSelectScalar = {
    id?: boolean
    workflowId?: boolean
    type?: boolean
    config?: boolean
  }

  export type WorkflowTriggerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workflowId" | "type" | "config", ExtArgs["result"]["workflowTrigger"]>
  export type WorkflowTriggerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
  }
  export type WorkflowTriggerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
  }
  export type WorkflowTriggerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
  }

  export type $WorkflowTriggerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowTrigger"
    objects: {
      workflow: Prisma.$WorkflowPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workflowId: string
      type: $Enums.TriggerType
      config: string
    }, ExtArgs["result"]["workflowTrigger"]>
    composites: {}
  }

  type WorkflowTriggerGetPayload<S extends boolean | null | undefined | WorkflowTriggerDefaultArgs> = $Result.GetResult<Prisma.$WorkflowTriggerPayload, S>

  type WorkflowTriggerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkflowTriggerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkflowTriggerCountAggregateInputType | true
    }

  export interface WorkflowTriggerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowTrigger'], meta: { name: 'WorkflowTrigger' } }
    /**
     * Find zero or one WorkflowTrigger that matches the filter.
     * @param {WorkflowTriggerFindUniqueArgs} args - Arguments to find a WorkflowTrigger
     * @example
     * // Get one WorkflowTrigger
     * const workflowTrigger = await prisma.workflowTrigger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowTriggerFindUniqueArgs>(args: SelectSubset<T, WorkflowTriggerFindUniqueArgs<ExtArgs>>): Prisma__WorkflowTriggerClient<$Result.GetResult<Prisma.$WorkflowTriggerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkflowTrigger that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkflowTriggerFindUniqueOrThrowArgs} args - Arguments to find a WorkflowTrigger
     * @example
     * // Get one WorkflowTrigger
     * const workflowTrigger = await prisma.workflowTrigger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowTriggerFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowTriggerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowTriggerClient<$Result.GetResult<Prisma.$WorkflowTriggerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkflowTrigger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTriggerFindFirstArgs} args - Arguments to find a WorkflowTrigger
     * @example
     * // Get one WorkflowTrigger
     * const workflowTrigger = await prisma.workflowTrigger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowTriggerFindFirstArgs>(args?: SelectSubset<T, WorkflowTriggerFindFirstArgs<ExtArgs>>): Prisma__WorkflowTriggerClient<$Result.GetResult<Prisma.$WorkflowTriggerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkflowTrigger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTriggerFindFirstOrThrowArgs} args - Arguments to find a WorkflowTrigger
     * @example
     * // Get one WorkflowTrigger
     * const workflowTrigger = await prisma.workflowTrigger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowTriggerFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowTriggerFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowTriggerClient<$Result.GetResult<Prisma.$WorkflowTriggerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkflowTriggers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTriggerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowTriggers
     * const workflowTriggers = await prisma.workflowTrigger.findMany()
     * 
     * // Get first 10 WorkflowTriggers
     * const workflowTriggers = await prisma.workflowTrigger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowTriggerWithIdOnly = await prisma.workflowTrigger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowTriggerFindManyArgs>(args?: SelectSubset<T, WorkflowTriggerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowTriggerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkflowTrigger.
     * @param {WorkflowTriggerCreateArgs} args - Arguments to create a WorkflowTrigger.
     * @example
     * // Create one WorkflowTrigger
     * const WorkflowTrigger = await prisma.workflowTrigger.create({
     *   data: {
     *     // ... data to create a WorkflowTrigger
     *   }
     * })
     * 
     */
    create<T extends WorkflowTriggerCreateArgs>(args: SelectSubset<T, WorkflowTriggerCreateArgs<ExtArgs>>): Prisma__WorkflowTriggerClient<$Result.GetResult<Prisma.$WorkflowTriggerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkflowTriggers.
     * @param {WorkflowTriggerCreateManyArgs} args - Arguments to create many WorkflowTriggers.
     * @example
     * // Create many WorkflowTriggers
     * const workflowTrigger = await prisma.workflowTrigger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowTriggerCreateManyArgs>(args?: SelectSubset<T, WorkflowTriggerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkflowTriggers and returns the data saved in the database.
     * @param {WorkflowTriggerCreateManyAndReturnArgs} args - Arguments to create many WorkflowTriggers.
     * @example
     * // Create many WorkflowTriggers
     * const workflowTrigger = await prisma.workflowTrigger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkflowTriggers and only return the `id`
     * const workflowTriggerWithIdOnly = await prisma.workflowTrigger.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowTriggerCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowTriggerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowTriggerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkflowTrigger.
     * @param {WorkflowTriggerDeleteArgs} args - Arguments to delete one WorkflowTrigger.
     * @example
     * // Delete one WorkflowTrigger
     * const WorkflowTrigger = await prisma.workflowTrigger.delete({
     *   where: {
     *     // ... filter to delete one WorkflowTrigger
     *   }
     * })
     * 
     */
    delete<T extends WorkflowTriggerDeleteArgs>(args: SelectSubset<T, WorkflowTriggerDeleteArgs<ExtArgs>>): Prisma__WorkflowTriggerClient<$Result.GetResult<Prisma.$WorkflowTriggerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkflowTrigger.
     * @param {WorkflowTriggerUpdateArgs} args - Arguments to update one WorkflowTrigger.
     * @example
     * // Update one WorkflowTrigger
     * const workflowTrigger = await prisma.workflowTrigger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowTriggerUpdateArgs>(args: SelectSubset<T, WorkflowTriggerUpdateArgs<ExtArgs>>): Prisma__WorkflowTriggerClient<$Result.GetResult<Prisma.$WorkflowTriggerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkflowTriggers.
     * @param {WorkflowTriggerDeleteManyArgs} args - Arguments to filter WorkflowTriggers to delete.
     * @example
     * // Delete a few WorkflowTriggers
     * const { count } = await prisma.workflowTrigger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowTriggerDeleteManyArgs>(args?: SelectSubset<T, WorkflowTriggerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowTriggers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTriggerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowTriggers
     * const workflowTrigger = await prisma.workflowTrigger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowTriggerUpdateManyArgs>(args: SelectSubset<T, WorkflowTriggerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowTriggers and returns the data updated in the database.
     * @param {WorkflowTriggerUpdateManyAndReturnArgs} args - Arguments to update many WorkflowTriggers.
     * @example
     * // Update many WorkflowTriggers
     * const workflowTrigger = await prisma.workflowTrigger.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkflowTriggers and only return the `id`
     * const workflowTriggerWithIdOnly = await prisma.workflowTrigger.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkflowTriggerUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkflowTriggerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowTriggerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkflowTrigger.
     * @param {WorkflowTriggerUpsertArgs} args - Arguments to update or create a WorkflowTrigger.
     * @example
     * // Update or create a WorkflowTrigger
     * const workflowTrigger = await prisma.workflowTrigger.upsert({
     *   create: {
     *     // ... data to create a WorkflowTrigger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowTrigger we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowTriggerUpsertArgs>(args: SelectSubset<T, WorkflowTriggerUpsertArgs<ExtArgs>>): Prisma__WorkflowTriggerClient<$Result.GetResult<Prisma.$WorkflowTriggerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkflowTriggers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTriggerCountArgs} args - Arguments to filter WorkflowTriggers to count.
     * @example
     * // Count the number of WorkflowTriggers
     * const count = await prisma.workflowTrigger.count({
     *   where: {
     *     // ... the filter for the WorkflowTriggers we want to count
     *   }
     * })
    **/
    count<T extends WorkflowTriggerCountArgs>(
      args?: Subset<T, WorkflowTriggerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowTriggerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowTrigger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTriggerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowTriggerAggregateArgs>(args: Subset<T, WorkflowTriggerAggregateArgs>): Prisma.PrismaPromise<GetWorkflowTriggerAggregateType<T>>

    /**
     * Group by WorkflowTrigger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTriggerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowTriggerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowTriggerGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowTriggerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowTriggerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowTriggerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowTrigger model
   */
  readonly fields: WorkflowTriggerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowTrigger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowTriggerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workflow<T extends WorkflowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowDefaultArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowTrigger model
   */
  interface WorkflowTriggerFieldRefs {
    readonly id: FieldRef<"WorkflowTrigger", 'String'>
    readonly workflowId: FieldRef<"WorkflowTrigger", 'String'>
    readonly type: FieldRef<"WorkflowTrigger", 'TriggerType'>
    readonly config: FieldRef<"WorkflowTrigger", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowTrigger findUnique
   */
  export type WorkflowTriggerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTrigger
     */
    select?: WorkflowTriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowTrigger
     */
    omit?: WorkflowTriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTriggerInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowTrigger to fetch.
     */
    where: WorkflowTriggerWhereUniqueInput
  }

  /**
   * WorkflowTrigger findUniqueOrThrow
   */
  export type WorkflowTriggerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTrigger
     */
    select?: WorkflowTriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowTrigger
     */
    omit?: WorkflowTriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTriggerInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowTrigger to fetch.
     */
    where: WorkflowTriggerWhereUniqueInput
  }

  /**
   * WorkflowTrigger findFirst
   */
  export type WorkflowTriggerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTrigger
     */
    select?: WorkflowTriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowTrigger
     */
    omit?: WorkflowTriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTriggerInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowTrigger to fetch.
     */
    where?: WorkflowTriggerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowTriggers to fetch.
     */
    orderBy?: WorkflowTriggerOrderByWithRelationInput | WorkflowTriggerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowTriggers.
     */
    cursor?: WorkflowTriggerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowTriggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowTriggers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowTriggers.
     */
    distinct?: WorkflowTriggerScalarFieldEnum | WorkflowTriggerScalarFieldEnum[]
  }

  /**
   * WorkflowTrigger findFirstOrThrow
   */
  export type WorkflowTriggerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTrigger
     */
    select?: WorkflowTriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowTrigger
     */
    omit?: WorkflowTriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTriggerInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowTrigger to fetch.
     */
    where?: WorkflowTriggerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowTriggers to fetch.
     */
    orderBy?: WorkflowTriggerOrderByWithRelationInput | WorkflowTriggerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowTriggers.
     */
    cursor?: WorkflowTriggerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowTriggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowTriggers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowTriggers.
     */
    distinct?: WorkflowTriggerScalarFieldEnum | WorkflowTriggerScalarFieldEnum[]
  }

  /**
   * WorkflowTrigger findMany
   */
  export type WorkflowTriggerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTrigger
     */
    select?: WorkflowTriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowTrigger
     */
    omit?: WorkflowTriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTriggerInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowTriggers to fetch.
     */
    where?: WorkflowTriggerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowTriggers to fetch.
     */
    orderBy?: WorkflowTriggerOrderByWithRelationInput | WorkflowTriggerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowTriggers.
     */
    cursor?: WorkflowTriggerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowTriggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowTriggers.
     */
    skip?: number
    distinct?: WorkflowTriggerScalarFieldEnum | WorkflowTriggerScalarFieldEnum[]
  }

  /**
   * WorkflowTrigger create
   */
  export type WorkflowTriggerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTrigger
     */
    select?: WorkflowTriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowTrigger
     */
    omit?: WorkflowTriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTriggerInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkflowTrigger.
     */
    data: XOR<WorkflowTriggerCreateInput, WorkflowTriggerUncheckedCreateInput>
  }

  /**
   * WorkflowTrigger createMany
   */
  export type WorkflowTriggerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowTriggers.
     */
    data: WorkflowTriggerCreateManyInput | WorkflowTriggerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowTrigger createManyAndReturn
   */
  export type WorkflowTriggerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTrigger
     */
    select?: WorkflowTriggerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowTrigger
     */
    omit?: WorkflowTriggerOmit<ExtArgs> | null
    /**
     * The data used to create many WorkflowTriggers.
     */
    data: WorkflowTriggerCreateManyInput | WorkflowTriggerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTriggerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowTrigger update
   */
  export type WorkflowTriggerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTrigger
     */
    select?: WorkflowTriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowTrigger
     */
    omit?: WorkflowTriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTriggerInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkflowTrigger.
     */
    data: XOR<WorkflowTriggerUpdateInput, WorkflowTriggerUncheckedUpdateInput>
    /**
     * Choose, which WorkflowTrigger to update.
     */
    where: WorkflowTriggerWhereUniqueInput
  }

  /**
   * WorkflowTrigger updateMany
   */
  export type WorkflowTriggerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowTriggers.
     */
    data: XOR<WorkflowTriggerUpdateManyMutationInput, WorkflowTriggerUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowTriggers to update
     */
    where?: WorkflowTriggerWhereInput
    /**
     * Limit how many WorkflowTriggers to update.
     */
    limit?: number
  }

  /**
   * WorkflowTrigger updateManyAndReturn
   */
  export type WorkflowTriggerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTrigger
     */
    select?: WorkflowTriggerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowTrigger
     */
    omit?: WorkflowTriggerOmit<ExtArgs> | null
    /**
     * The data used to update WorkflowTriggers.
     */
    data: XOR<WorkflowTriggerUpdateManyMutationInput, WorkflowTriggerUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowTriggers to update
     */
    where?: WorkflowTriggerWhereInput
    /**
     * Limit how many WorkflowTriggers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTriggerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowTrigger upsert
   */
  export type WorkflowTriggerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTrigger
     */
    select?: WorkflowTriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowTrigger
     */
    omit?: WorkflowTriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTriggerInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkflowTrigger to update in case it exists.
     */
    where: WorkflowTriggerWhereUniqueInput
    /**
     * In case the WorkflowTrigger found by the `where` argument doesn't exist, create a new WorkflowTrigger with this data.
     */
    create: XOR<WorkflowTriggerCreateInput, WorkflowTriggerUncheckedCreateInput>
    /**
     * In case the WorkflowTrigger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowTriggerUpdateInput, WorkflowTriggerUncheckedUpdateInput>
  }

  /**
   * WorkflowTrigger delete
   */
  export type WorkflowTriggerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTrigger
     */
    select?: WorkflowTriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowTrigger
     */
    omit?: WorkflowTriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTriggerInclude<ExtArgs> | null
    /**
     * Filter which WorkflowTrigger to delete.
     */
    where: WorkflowTriggerWhereUniqueInput
  }

  /**
   * WorkflowTrigger deleteMany
   */
  export type WorkflowTriggerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowTriggers to delete
     */
    where?: WorkflowTriggerWhereInput
    /**
     * Limit how many WorkflowTriggers to delete.
     */
    limit?: number
  }

  /**
   * WorkflowTrigger without action
   */
  export type WorkflowTriggerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTrigger
     */
    select?: WorkflowTriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowTrigger
     */
    omit?: WorkflowTriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTriggerInclude<ExtArgs> | null
  }


  /**
   * Model Analytics
   */

  export type AggregateAnalytics = {
    _count: AnalyticsCountAggregateOutputType | null
    _min: AnalyticsMinAggregateOutputType | null
    _max: AnalyticsMaxAggregateOutputType | null
  }

  export type AnalyticsMinAggregateOutputType = {
    id: string | null
    entityType: $Enums.EntityType | null
    entityId: string | null
    period: $Enums.AnalyticsPeriod | null
    metrics: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalyticsMaxAggregateOutputType = {
    id: string | null
    entityType: $Enums.EntityType | null
    entityId: string | null
    period: $Enums.AnalyticsPeriod | null
    metrics: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalyticsCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    period: number
    metrics: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnalyticsMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    period?: true
    metrics?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalyticsMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    period?: true
    metrics?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalyticsCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    period?: true
    metrics?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Analytics to aggregate.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Analytics
    **/
    _count?: true | AnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsMaxAggregateInputType
  }

  export type GetAnalyticsAggregateType<T extends AnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalytics[P]>
      : GetScalarType<T[P], AggregateAnalytics[P]>
  }




  export type AnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsWhereInput
    orderBy?: AnalyticsOrderByWithAggregationInput | AnalyticsOrderByWithAggregationInput[]
    by: AnalyticsScalarFieldEnum[] | AnalyticsScalarFieldEnum
    having?: AnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsCountAggregateInputType | true
    _min?: AnalyticsMinAggregateInputType
    _max?: AnalyticsMaxAggregateInputType
  }

  export type AnalyticsGroupByOutputType = {
    id: string
    entityType: $Enums.EntityType
    entityId: string
    period: $Enums.AnalyticsPeriod
    metrics: string
    createdAt: Date
    updatedAt: Date
    _count: AnalyticsCountAggregateOutputType | null
    _min: AnalyticsMinAggregateOutputType | null
    _max: AnalyticsMaxAggregateOutputType | null
  }

  type GetAnalyticsGroupByPayload<T extends AnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    period?: boolean
    metrics?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analytics"]>

  export type AnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    period?: boolean
    metrics?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analytics"]>

  export type AnalyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    period?: boolean
    metrics?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analytics"]>

  export type AnalyticsSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    period?: boolean
    metrics?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityType" | "entityId" | "period" | "metrics" | "createdAt" | "updatedAt", ExtArgs["result"]["analytics"]>

  export type $AnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Analytics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityType: $Enums.EntityType
      entityId: string
      period: $Enums.AnalyticsPeriod
      metrics: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["analytics"]>
    composites: {}
  }

  type AnalyticsGetPayload<S extends boolean | null | undefined | AnalyticsDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsPayload, S>

  type AnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalyticsCountAggregateInputType | true
    }

  export interface AnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Analytics'], meta: { name: 'Analytics' } }
    /**
     * Find zero or one Analytics that matches the filter.
     * @param {AnalyticsFindUniqueArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsFindUniqueArgs>(args: SelectSubset<T, AnalyticsFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Analytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticsFindUniqueOrThrowArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Analytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFindFirstArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsFindFirstArgs>(args?: SelectSubset<T, AnalyticsFindFirstArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Analytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFindFirstOrThrowArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Analytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Analytics
     * const analytics = await prisma.analytics.findMany()
     * 
     * // Get first 10 Analytics
     * const analytics = await prisma.analytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsWithIdOnly = await prisma.analytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsFindManyArgs>(args?: SelectSubset<T, AnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Analytics.
     * @param {AnalyticsCreateArgs} args - Arguments to create a Analytics.
     * @example
     * // Create one Analytics
     * const Analytics = await prisma.analytics.create({
     *   data: {
     *     // ... data to create a Analytics
     *   }
     * })
     * 
     */
    create<T extends AnalyticsCreateArgs>(args: SelectSubset<T, AnalyticsCreateArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Analytics.
     * @param {AnalyticsCreateManyArgs} args - Arguments to create many Analytics.
     * @example
     * // Create many Analytics
     * const analytics = await prisma.analytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsCreateManyArgs>(args?: SelectSubset<T, AnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Analytics and returns the data saved in the database.
     * @param {AnalyticsCreateManyAndReturnArgs} args - Arguments to create many Analytics.
     * @example
     * // Create many Analytics
     * const analytics = await prisma.analytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Analytics and only return the `id`
     * const analyticsWithIdOnly = await prisma.analytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Analytics.
     * @param {AnalyticsDeleteArgs} args - Arguments to delete one Analytics.
     * @example
     * // Delete one Analytics
     * const Analytics = await prisma.analytics.delete({
     *   where: {
     *     // ... filter to delete one Analytics
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsDeleteArgs>(args: SelectSubset<T, AnalyticsDeleteArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Analytics.
     * @param {AnalyticsUpdateArgs} args - Arguments to update one Analytics.
     * @example
     * // Update one Analytics
     * const analytics = await prisma.analytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsUpdateArgs>(args: SelectSubset<T, AnalyticsUpdateArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Analytics.
     * @param {AnalyticsDeleteManyArgs} args - Arguments to filter Analytics to delete.
     * @example
     * // Delete a few Analytics
     * const { count } = await prisma.analytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsDeleteManyArgs>(args?: SelectSubset<T, AnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Analytics
     * const analytics = await prisma.analytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsUpdateManyArgs>(args: SelectSubset<T, AnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Analytics and returns the data updated in the database.
     * @param {AnalyticsUpdateManyAndReturnArgs} args - Arguments to update many Analytics.
     * @example
     * // Update many Analytics
     * const analytics = await prisma.analytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Analytics and only return the `id`
     * const analyticsWithIdOnly = await prisma.analytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Analytics.
     * @param {AnalyticsUpsertArgs} args - Arguments to update or create a Analytics.
     * @example
     * // Update or create a Analytics
     * const analytics = await prisma.analytics.upsert({
     *   create: {
     *     // ... data to create a Analytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Analytics we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsUpsertArgs>(args: SelectSubset<T, AnalyticsUpsertArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsCountArgs} args - Arguments to filter Analytics to count.
     * @example
     * // Count the number of Analytics
     * const count = await prisma.analytics.count({
     *   where: {
     *     // ... the filter for the Analytics we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsCountArgs>(
      args?: Subset<T, AnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsAggregateArgs>(args: Subset<T, AnalyticsAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsAggregateType<T>>

    /**
     * Group by Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Analytics model
   */
  readonly fields: AnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Analytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Analytics model
   */
  interface AnalyticsFieldRefs {
    readonly id: FieldRef<"Analytics", 'String'>
    readonly entityType: FieldRef<"Analytics", 'EntityType'>
    readonly entityId: FieldRef<"Analytics", 'String'>
    readonly period: FieldRef<"Analytics", 'AnalyticsPeriod'>
    readonly metrics: FieldRef<"Analytics", 'String'>
    readonly createdAt: FieldRef<"Analytics", 'DateTime'>
    readonly updatedAt: FieldRef<"Analytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Analytics findUnique
   */
  export type AnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics findUniqueOrThrow
   */
  export type AnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics findFirst
   */
  export type AnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Analytics.
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Analytics.
     */
    distinct?: AnalyticsScalarFieldEnum | AnalyticsScalarFieldEnum[]
  }

  /**
   * Analytics findFirstOrThrow
   */
  export type AnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Analytics.
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Analytics.
     */
    distinct?: AnalyticsScalarFieldEnum | AnalyticsScalarFieldEnum[]
  }

  /**
   * Analytics findMany
   */
  export type AnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Analytics.
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    distinct?: AnalyticsScalarFieldEnum | AnalyticsScalarFieldEnum[]
  }

  /**
   * Analytics create
   */
  export type AnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * The data needed to create a Analytics.
     */
    data: XOR<AnalyticsCreateInput, AnalyticsUncheckedCreateInput>
  }

  /**
   * Analytics createMany
   */
  export type AnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Analytics.
     */
    data: AnalyticsCreateManyInput | AnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Analytics createManyAndReturn
   */
  export type AnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * The data used to create many Analytics.
     */
    data: AnalyticsCreateManyInput | AnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Analytics update
   */
  export type AnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * The data needed to update a Analytics.
     */
    data: XOR<AnalyticsUpdateInput, AnalyticsUncheckedUpdateInput>
    /**
     * Choose, which Analytics to update.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics updateMany
   */
  export type AnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Analytics.
     */
    data: XOR<AnalyticsUpdateManyMutationInput, AnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which Analytics to update
     */
    where?: AnalyticsWhereInput
    /**
     * Limit how many Analytics to update.
     */
    limit?: number
  }

  /**
   * Analytics updateManyAndReturn
   */
  export type AnalyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * The data used to update Analytics.
     */
    data: XOR<AnalyticsUpdateManyMutationInput, AnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which Analytics to update
     */
    where?: AnalyticsWhereInput
    /**
     * Limit how many Analytics to update.
     */
    limit?: number
  }

  /**
   * Analytics upsert
   */
  export type AnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * The filter to search for the Analytics to update in case it exists.
     */
    where: AnalyticsWhereUniqueInput
    /**
     * In case the Analytics found by the `where` argument doesn't exist, create a new Analytics with this data.
     */
    create: XOR<AnalyticsCreateInput, AnalyticsUncheckedCreateInput>
    /**
     * In case the Analytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsUpdateInput, AnalyticsUncheckedUpdateInput>
  }

  /**
   * Analytics delete
   */
  export type AnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Filter which Analytics to delete.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics deleteMany
   */
  export type AnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Analytics to delete
     */
    where?: AnalyticsWhereInput
    /**
     * Limit how many Analytics to delete.
     */
    limit?: number
  }

  /**
   * Analytics without action
   */
  export type AnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
  }


  /**
   * Model IntegrationConnection
   */

  export type AggregateIntegrationConnection = {
    _count: IntegrationConnectionCountAggregateOutputType | null
    _min: IntegrationConnectionMinAggregateOutputType | null
    _max: IntegrationConnectionMaxAggregateOutputType | null
  }

  export type IntegrationConnectionMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.IntegrationType | null
    config: string | null
    status: $Enums.ConnectionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegrationConnectionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.IntegrationType | null
    config: string | null
    status: $Enums.ConnectionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegrationConnectionCountAggregateOutputType = {
    id: number
    name: number
    type: number
    config: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntegrationConnectionMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    config?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegrationConnectionMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    config?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegrationConnectionCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    config?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntegrationConnectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntegrationConnection to aggregate.
     */
    where?: IntegrationConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationConnections to fetch.
     */
    orderBy?: IntegrationConnectionOrderByWithRelationInput | IntegrationConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntegrationConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntegrationConnections
    **/
    _count?: true | IntegrationConnectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegrationConnectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegrationConnectionMaxAggregateInputType
  }

  export type GetIntegrationConnectionAggregateType<T extends IntegrationConnectionAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegrationConnection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegrationConnection[P]>
      : GetScalarType<T[P], AggregateIntegrationConnection[P]>
  }




  export type IntegrationConnectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationConnectionWhereInput
    orderBy?: IntegrationConnectionOrderByWithAggregationInput | IntegrationConnectionOrderByWithAggregationInput[]
    by: IntegrationConnectionScalarFieldEnum[] | IntegrationConnectionScalarFieldEnum
    having?: IntegrationConnectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegrationConnectionCountAggregateInputType | true
    _min?: IntegrationConnectionMinAggregateInputType
    _max?: IntegrationConnectionMaxAggregateInputType
  }

  export type IntegrationConnectionGroupByOutputType = {
    id: string
    name: string
    type: $Enums.IntegrationType
    config: string
    status: $Enums.ConnectionStatus
    createdAt: Date
    updatedAt: Date
    _count: IntegrationConnectionCountAggregateOutputType | null
    _min: IntegrationConnectionMinAggregateOutputType | null
    _max: IntegrationConnectionMaxAggregateOutputType | null
  }

  type GetIntegrationConnectionGroupByPayload<T extends IntegrationConnectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntegrationConnectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegrationConnectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegrationConnectionGroupByOutputType[P]>
            : GetScalarType<T[P], IntegrationConnectionGroupByOutputType[P]>
        }
      >
    >


  export type IntegrationConnectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    config?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["integrationConnection"]>

  export type IntegrationConnectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    config?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["integrationConnection"]>

  export type IntegrationConnectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    config?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["integrationConnection"]>

  export type IntegrationConnectionSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    config?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntegrationConnectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "config" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["integrationConnection"]>

  export type $IntegrationConnectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IntegrationConnection"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.IntegrationType
      config: string
      status: $Enums.ConnectionStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["integrationConnection"]>
    composites: {}
  }

  type IntegrationConnectionGetPayload<S extends boolean | null | undefined | IntegrationConnectionDefaultArgs> = $Result.GetResult<Prisma.$IntegrationConnectionPayload, S>

  type IntegrationConnectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IntegrationConnectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IntegrationConnectionCountAggregateInputType | true
    }

  export interface IntegrationConnectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IntegrationConnection'], meta: { name: 'IntegrationConnection' } }
    /**
     * Find zero or one IntegrationConnection that matches the filter.
     * @param {IntegrationConnectionFindUniqueArgs} args - Arguments to find a IntegrationConnection
     * @example
     * // Get one IntegrationConnection
     * const integrationConnection = await prisma.integrationConnection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntegrationConnectionFindUniqueArgs>(args: SelectSubset<T, IntegrationConnectionFindUniqueArgs<ExtArgs>>): Prisma__IntegrationConnectionClient<$Result.GetResult<Prisma.$IntegrationConnectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IntegrationConnection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IntegrationConnectionFindUniqueOrThrowArgs} args - Arguments to find a IntegrationConnection
     * @example
     * // Get one IntegrationConnection
     * const integrationConnection = await prisma.integrationConnection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntegrationConnectionFindUniqueOrThrowArgs>(args: SelectSubset<T, IntegrationConnectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntegrationConnectionClient<$Result.GetResult<Prisma.$IntegrationConnectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IntegrationConnection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationConnectionFindFirstArgs} args - Arguments to find a IntegrationConnection
     * @example
     * // Get one IntegrationConnection
     * const integrationConnection = await prisma.integrationConnection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntegrationConnectionFindFirstArgs>(args?: SelectSubset<T, IntegrationConnectionFindFirstArgs<ExtArgs>>): Prisma__IntegrationConnectionClient<$Result.GetResult<Prisma.$IntegrationConnectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IntegrationConnection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationConnectionFindFirstOrThrowArgs} args - Arguments to find a IntegrationConnection
     * @example
     * // Get one IntegrationConnection
     * const integrationConnection = await prisma.integrationConnection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntegrationConnectionFindFirstOrThrowArgs>(args?: SelectSubset<T, IntegrationConnectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntegrationConnectionClient<$Result.GetResult<Prisma.$IntegrationConnectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IntegrationConnections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationConnectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntegrationConnections
     * const integrationConnections = await prisma.integrationConnection.findMany()
     * 
     * // Get first 10 IntegrationConnections
     * const integrationConnections = await prisma.integrationConnection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integrationConnectionWithIdOnly = await prisma.integrationConnection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntegrationConnectionFindManyArgs>(args?: SelectSubset<T, IntegrationConnectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IntegrationConnection.
     * @param {IntegrationConnectionCreateArgs} args - Arguments to create a IntegrationConnection.
     * @example
     * // Create one IntegrationConnection
     * const IntegrationConnection = await prisma.integrationConnection.create({
     *   data: {
     *     // ... data to create a IntegrationConnection
     *   }
     * })
     * 
     */
    create<T extends IntegrationConnectionCreateArgs>(args: SelectSubset<T, IntegrationConnectionCreateArgs<ExtArgs>>): Prisma__IntegrationConnectionClient<$Result.GetResult<Prisma.$IntegrationConnectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IntegrationConnections.
     * @param {IntegrationConnectionCreateManyArgs} args - Arguments to create many IntegrationConnections.
     * @example
     * // Create many IntegrationConnections
     * const integrationConnection = await prisma.integrationConnection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntegrationConnectionCreateManyArgs>(args?: SelectSubset<T, IntegrationConnectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IntegrationConnections and returns the data saved in the database.
     * @param {IntegrationConnectionCreateManyAndReturnArgs} args - Arguments to create many IntegrationConnections.
     * @example
     * // Create many IntegrationConnections
     * const integrationConnection = await prisma.integrationConnection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IntegrationConnections and only return the `id`
     * const integrationConnectionWithIdOnly = await prisma.integrationConnection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntegrationConnectionCreateManyAndReturnArgs>(args?: SelectSubset<T, IntegrationConnectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationConnectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IntegrationConnection.
     * @param {IntegrationConnectionDeleteArgs} args - Arguments to delete one IntegrationConnection.
     * @example
     * // Delete one IntegrationConnection
     * const IntegrationConnection = await prisma.integrationConnection.delete({
     *   where: {
     *     // ... filter to delete one IntegrationConnection
     *   }
     * })
     * 
     */
    delete<T extends IntegrationConnectionDeleteArgs>(args: SelectSubset<T, IntegrationConnectionDeleteArgs<ExtArgs>>): Prisma__IntegrationConnectionClient<$Result.GetResult<Prisma.$IntegrationConnectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IntegrationConnection.
     * @param {IntegrationConnectionUpdateArgs} args - Arguments to update one IntegrationConnection.
     * @example
     * // Update one IntegrationConnection
     * const integrationConnection = await prisma.integrationConnection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntegrationConnectionUpdateArgs>(args: SelectSubset<T, IntegrationConnectionUpdateArgs<ExtArgs>>): Prisma__IntegrationConnectionClient<$Result.GetResult<Prisma.$IntegrationConnectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IntegrationConnections.
     * @param {IntegrationConnectionDeleteManyArgs} args - Arguments to filter IntegrationConnections to delete.
     * @example
     * // Delete a few IntegrationConnections
     * const { count } = await prisma.integrationConnection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntegrationConnectionDeleteManyArgs>(args?: SelectSubset<T, IntegrationConnectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntegrationConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationConnectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntegrationConnections
     * const integrationConnection = await prisma.integrationConnection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntegrationConnectionUpdateManyArgs>(args: SelectSubset<T, IntegrationConnectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntegrationConnections and returns the data updated in the database.
     * @param {IntegrationConnectionUpdateManyAndReturnArgs} args - Arguments to update many IntegrationConnections.
     * @example
     * // Update many IntegrationConnections
     * const integrationConnection = await prisma.integrationConnection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IntegrationConnections and only return the `id`
     * const integrationConnectionWithIdOnly = await prisma.integrationConnection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IntegrationConnectionUpdateManyAndReturnArgs>(args: SelectSubset<T, IntegrationConnectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationConnectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IntegrationConnection.
     * @param {IntegrationConnectionUpsertArgs} args - Arguments to update or create a IntegrationConnection.
     * @example
     * // Update or create a IntegrationConnection
     * const integrationConnection = await prisma.integrationConnection.upsert({
     *   create: {
     *     // ... data to create a IntegrationConnection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntegrationConnection we want to update
     *   }
     * })
     */
    upsert<T extends IntegrationConnectionUpsertArgs>(args: SelectSubset<T, IntegrationConnectionUpsertArgs<ExtArgs>>): Prisma__IntegrationConnectionClient<$Result.GetResult<Prisma.$IntegrationConnectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IntegrationConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationConnectionCountArgs} args - Arguments to filter IntegrationConnections to count.
     * @example
     * // Count the number of IntegrationConnections
     * const count = await prisma.integrationConnection.count({
     *   where: {
     *     // ... the filter for the IntegrationConnections we want to count
     *   }
     * })
    **/
    count<T extends IntegrationConnectionCountArgs>(
      args?: Subset<T, IntegrationConnectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegrationConnectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntegrationConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationConnectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegrationConnectionAggregateArgs>(args: Subset<T, IntegrationConnectionAggregateArgs>): Prisma.PrismaPromise<GetIntegrationConnectionAggregateType<T>>

    /**
     * Group by IntegrationConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationConnectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntegrationConnectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntegrationConnectionGroupByArgs['orderBy'] }
        : { orderBy?: IntegrationConnectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntegrationConnectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegrationConnectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IntegrationConnection model
   */
  readonly fields: IntegrationConnectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntegrationConnection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntegrationConnectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IntegrationConnection model
   */
  interface IntegrationConnectionFieldRefs {
    readonly id: FieldRef<"IntegrationConnection", 'String'>
    readonly name: FieldRef<"IntegrationConnection", 'String'>
    readonly type: FieldRef<"IntegrationConnection", 'IntegrationType'>
    readonly config: FieldRef<"IntegrationConnection", 'String'>
    readonly status: FieldRef<"IntegrationConnection", 'ConnectionStatus'>
    readonly createdAt: FieldRef<"IntegrationConnection", 'DateTime'>
    readonly updatedAt: FieldRef<"IntegrationConnection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IntegrationConnection findUnique
   */
  export type IntegrationConnectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationConnection
     */
    select?: IntegrationConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationConnection
     */
    omit?: IntegrationConnectionOmit<ExtArgs> | null
    /**
     * Filter, which IntegrationConnection to fetch.
     */
    where: IntegrationConnectionWhereUniqueInput
  }

  /**
   * IntegrationConnection findUniqueOrThrow
   */
  export type IntegrationConnectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationConnection
     */
    select?: IntegrationConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationConnection
     */
    omit?: IntegrationConnectionOmit<ExtArgs> | null
    /**
     * Filter, which IntegrationConnection to fetch.
     */
    where: IntegrationConnectionWhereUniqueInput
  }

  /**
   * IntegrationConnection findFirst
   */
  export type IntegrationConnectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationConnection
     */
    select?: IntegrationConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationConnection
     */
    omit?: IntegrationConnectionOmit<ExtArgs> | null
    /**
     * Filter, which IntegrationConnection to fetch.
     */
    where?: IntegrationConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationConnections to fetch.
     */
    orderBy?: IntegrationConnectionOrderByWithRelationInput | IntegrationConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntegrationConnections.
     */
    cursor?: IntegrationConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntegrationConnections.
     */
    distinct?: IntegrationConnectionScalarFieldEnum | IntegrationConnectionScalarFieldEnum[]
  }

  /**
   * IntegrationConnection findFirstOrThrow
   */
  export type IntegrationConnectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationConnection
     */
    select?: IntegrationConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationConnection
     */
    omit?: IntegrationConnectionOmit<ExtArgs> | null
    /**
     * Filter, which IntegrationConnection to fetch.
     */
    where?: IntegrationConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationConnections to fetch.
     */
    orderBy?: IntegrationConnectionOrderByWithRelationInput | IntegrationConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntegrationConnections.
     */
    cursor?: IntegrationConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntegrationConnections.
     */
    distinct?: IntegrationConnectionScalarFieldEnum | IntegrationConnectionScalarFieldEnum[]
  }

  /**
   * IntegrationConnection findMany
   */
  export type IntegrationConnectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationConnection
     */
    select?: IntegrationConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationConnection
     */
    omit?: IntegrationConnectionOmit<ExtArgs> | null
    /**
     * Filter, which IntegrationConnections to fetch.
     */
    where?: IntegrationConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationConnections to fetch.
     */
    orderBy?: IntegrationConnectionOrderByWithRelationInput | IntegrationConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntegrationConnections.
     */
    cursor?: IntegrationConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationConnections.
     */
    skip?: number
    distinct?: IntegrationConnectionScalarFieldEnum | IntegrationConnectionScalarFieldEnum[]
  }

  /**
   * IntegrationConnection create
   */
  export type IntegrationConnectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationConnection
     */
    select?: IntegrationConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationConnection
     */
    omit?: IntegrationConnectionOmit<ExtArgs> | null
    /**
     * The data needed to create a IntegrationConnection.
     */
    data: XOR<IntegrationConnectionCreateInput, IntegrationConnectionUncheckedCreateInput>
  }

  /**
   * IntegrationConnection createMany
   */
  export type IntegrationConnectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IntegrationConnections.
     */
    data: IntegrationConnectionCreateManyInput | IntegrationConnectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IntegrationConnection createManyAndReturn
   */
  export type IntegrationConnectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationConnection
     */
    select?: IntegrationConnectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationConnection
     */
    omit?: IntegrationConnectionOmit<ExtArgs> | null
    /**
     * The data used to create many IntegrationConnections.
     */
    data: IntegrationConnectionCreateManyInput | IntegrationConnectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IntegrationConnection update
   */
  export type IntegrationConnectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationConnection
     */
    select?: IntegrationConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationConnection
     */
    omit?: IntegrationConnectionOmit<ExtArgs> | null
    /**
     * The data needed to update a IntegrationConnection.
     */
    data: XOR<IntegrationConnectionUpdateInput, IntegrationConnectionUncheckedUpdateInput>
    /**
     * Choose, which IntegrationConnection to update.
     */
    where: IntegrationConnectionWhereUniqueInput
  }

  /**
   * IntegrationConnection updateMany
   */
  export type IntegrationConnectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IntegrationConnections.
     */
    data: XOR<IntegrationConnectionUpdateManyMutationInput, IntegrationConnectionUncheckedUpdateManyInput>
    /**
     * Filter which IntegrationConnections to update
     */
    where?: IntegrationConnectionWhereInput
    /**
     * Limit how many IntegrationConnections to update.
     */
    limit?: number
  }

  /**
   * IntegrationConnection updateManyAndReturn
   */
  export type IntegrationConnectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationConnection
     */
    select?: IntegrationConnectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationConnection
     */
    omit?: IntegrationConnectionOmit<ExtArgs> | null
    /**
     * The data used to update IntegrationConnections.
     */
    data: XOR<IntegrationConnectionUpdateManyMutationInput, IntegrationConnectionUncheckedUpdateManyInput>
    /**
     * Filter which IntegrationConnections to update
     */
    where?: IntegrationConnectionWhereInput
    /**
     * Limit how many IntegrationConnections to update.
     */
    limit?: number
  }

  /**
   * IntegrationConnection upsert
   */
  export type IntegrationConnectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationConnection
     */
    select?: IntegrationConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationConnection
     */
    omit?: IntegrationConnectionOmit<ExtArgs> | null
    /**
     * The filter to search for the IntegrationConnection to update in case it exists.
     */
    where: IntegrationConnectionWhereUniqueInput
    /**
     * In case the IntegrationConnection found by the `where` argument doesn't exist, create a new IntegrationConnection with this data.
     */
    create: XOR<IntegrationConnectionCreateInput, IntegrationConnectionUncheckedCreateInput>
    /**
     * In case the IntegrationConnection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntegrationConnectionUpdateInput, IntegrationConnectionUncheckedUpdateInput>
  }

  /**
   * IntegrationConnection delete
   */
  export type IntegrationConnectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationConnection
     */
    select?: IntegrationConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationConnection
     */
    omit?: IntegrationConnectionOmit<ExtArgs> | null
    /**
     * Filter which IntegrationConnection to delete.
     */
    where: IntegrationConnectionWhereUniqueInput
  }

  /**
   * IntegrationConnection deleteMany
   */
  export type IntegrationConnectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntegrationConnections to delete
     */
    where?: IntegrationConnectionWhereInput
    /**
     * Limit how many IntegrationConnections to delete.
     */
    limit?: number
  }

  /**
   * IntegrationConnection without action
   */
  export type IntegrationConnectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationConnection
     */
    select?: IntegrationConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationConnection
     */
    omit?: IntegrationConnectionOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    password: 'password',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLogin: 'lastLogin',
    isActive: 'isActive',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    email: 'email',
    phone: 'phone',
    firstName: 'firstName',
    lastName: 'lastName',
    company: 'company',
    jobTitle: 'jobTitle',
    address: 'address',
    city: 'city',
    state: 'state',
    country: 'country',
    postalCode: 'postalCode',
    notes: 'notes',
    tagsString: 'tagsString',
    source: 'source',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const ListScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type ListScalarFieldEnum = (typeof ListScalarFieldEnum)[keyof typeof ListScalarFieldEnum]


  export const ListMemberScalarFieldEnum: {
    id: 'id',
    listId: 'listId',
    contactId: 'contactId',
    addedAt: 'addedAt'
  };

  export type ListMemberScalarFieldEnum = (typeof ListMemberScalarFieldEnum)[keyof typeof ListMemberScalarFieldEnum]


  export const SegmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    rules: 'rules',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type SegmentScalarFieldEnum = (typeof SegmentScalarFieldEnum)[keyof typeof SegmentScalarFieldEnum]


  export const EmailTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    subject: 'subject',
    content: 'content',
    design: 'design',
    previewText: 'previewText',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type EmailTemplateScalarFieldEnum = (typeof EmailTemplateScalarFieldEnum)[keyof typeof EmailTemplateScalarFieldEnum]


  export const EmailCampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    subject: 'subject',
    from: 'from',
    replyTo: 'replyTo',
    templateId: 'templateId',
    content: 'content',
    design: 'design',
    status: 'status',
    scheduledFor: 'scheduledFor',
    sentAt: 'sentAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type EmailCampaignScalarFieldEnum = (typeof EmailCampaignScalarFieldEnum)[keyof typeof EmailCampaignScalarFieldEnum]


  export const EmailActivityScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    contactId: 'contactId',
    type: 'type',
    timestamp: 'timestamp',
    metadata: 'metadata'
  };

  export type EmailActivityScalarFieldEnum = (typeof EmailActivityScalarFieldEnum)[keyof typeof EmailActivityScalarFieldEnum]


  export const SMSTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    content: 'content',
    variables: 'variables',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type SMSTemplateScalarFieldEnum = (typeof SMSTemplateScalarFieldEnum)[keyof typeof SMSTemplateScalarFieldEnum]


  export const SMSCampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    from: 'from',
    templateId: 'templateId',
    content: 'content',
    status: 'status',
    scheduledFor: 'scheduledFor',
    sentAt: 'sentAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type SMSCampaignScalarFieldEnum = (typeof SMSCampaignScalarFieldEnum)[keyof typeof SMSCampaignScalarFieldEnum]


  export const SMSActivityScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    contactId: 'contactId',
    type: 'type',
    timestamp: 'timestamp',
    metadata: 'metadata'
  };

  export type SMSActivityScalarFieldEnum = (typeof SMSActivityScalarFieldEnum)[keyof typeof SMSActivityScalarFieldEnum]


  export const WhatsAppTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    content: 'content',
    variables: 'variables',
    category: 'category',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type WhatsAppTemplateScalarFieldEnum = (typeof WhatsAppTemplateScalarFieldEnum)[keyof typeof WhatsAppTemplateScalarFieldEnum]


  export const WhatsAppCampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    from: 'from',
    templateId: 'templateId',
    content: 'content',
    status: 'status',
    scheduledFor: 'scheduledFor',
    sentAt: 'sentAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type WhatsAppCampaignScalarFieldEnum = (typeof WhatsAppCampaignScalarFieldEnum)[keyof typeof WhatsAppCampaignScalarFieldEnum]


  export const WhatsAppActivityScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    contactId: 'contactId',
    type: 'type',
    timestamp: 'timestamp',
    metadata: 'metadata'
  };

  export type WhatsAppActivityScalarFieldEnum = (typeof WhatsAppActivityScalarFieldEnum)[keyof typeof WhatsAppActivityScalarFieldEnum]


  export const WorkflowScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    definition: 'definition',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type WorkflowScalarFieldEnum = (typeof WorkflowScalarFieldEnum)[keyof typeof WorkflowScalarFieldEnum]


  export const WorkflowNodeScalarFieldEnum: {
    id: 'id',
    workflowId: 'workflowId',
    type: 'type',
    name: 'name',
    config: 'config',
    positionX: 'positionX',
    positionY: 'positionY'
  };

  export type WorkflowNodeScalarFieldEnum = (typeof WorkflowNodeScalarFieldEnum)[keyof typeof WorkflowNodeScalarFieldEnum]


  export const ConnectionScalarFieldEnum: {
    id: 'id',
    sourceId: 'sourceId',
    targetId: 'targetId',
    condition: 'condition'
  };

  export type ConnectionScalarFieldEnum = (typeof ConnectionScalarFieldEnum)[keyof typeof ConnectionScalarFieldEnum]


  export const WorkflowTriggerScalarFieldEnum: {
    id: 'id',
    workflowId: 'workflowId',
    type: 'type',
    config: 'config'
  };

  export type WorkflowTriggerScalarFieldEnum = (typeof WorkflowTriggerScalarFieldEnum)[keyof typeof WorkflowTriggerScalarFieldEnum]


  export const AnalyticsScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    period: 'period',
    metrics: 'metrics',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnalyticsScalarFieldEnum = (typeof AnalyticsScalarFieldEnum)[keyof typeof AnalyticsScalarFieldEnum]


  export const IntegrationConnectionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    config: 'config',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntegrationConnectionScalarFieldEnum = (typeof IntegrationConnectionScalarFieldEnum)[keyof typeof IntegrationConnectionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ContactStatus'
   */
  export type EnumContactStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactStatus'>
    


  /**
   * Reference to a field of type 'ContactStatus[]'
   */
  export type ListEnumContactStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactStatus[]'>
    


  /**
   * Reference to a field of type 'ListType'
   */
  export type EnumListTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListType'>
    


  /**
   * Reference to a field of type 'ListType[]'
   */
  export type ListEnumListTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListType[]'>
    


  /**
   * Reference to a field of type 'CampaignStatus'
   */
  export type EnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus'>
    


  /**
   * Reference to a field of type 'CampaignStatus[]'
   */
  export type ListEnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus[]'>
    


  /**
   * Reference to a field of type 'ActivityType'
   */
  export type EnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType'>
    


  /**
   * Reference to a field of type 'ActivityType[]'
   */
  export type ListEnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType[]'>
    


  /**
   * Reference to a field of type 'WATemplateStatus'
   */
  export type EnumWATemplateStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WATemplateStatus'>
    


  /**
   * Reference to a field of type 'WATemplateStatus[]'
   */
  export type ListEnumWATemplateStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WATemplateStatus[]'>
    


  /**
   * Reference to a field of type 'WorkflowStatus'
   */
  export type EnumWorkflowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowStatus'>
    


  /**
   * Reference to a field of type 'WorkflowStatus[]'
   */
  export type ListEnumWorkflowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowStatus[]'>
    


  /**
   * Reference to a field of type 'WorkflowNodeType'
   */
  export type EnumWorkflowNodeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowNodeType'>
    


  /**
   * Reference to a field of type 'WorkflowNodeType[]'
   */
  export type ListEnumWorkflowNodeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowNodeType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'TriggerType'
   */
  export type EnumTriggerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TriggerType'>
    


  /**
   * Reference to a field of type 'TriggerType[]'
   */
  export type ListEnumTriggerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TriggerType[]'>
    


  /**
   * Reference to a field of type 'EntityType'
   */
  export type EnumEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntityType'>
    


  /**
   * Reference to a field of type 'EntityType[]'
   */
  export type ListEnumEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntityType[]'>
    


  /**
   * Reference to a field of type 'AnalyticsPeriod'
   */
  export type EnumAnalyticsPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnalyticsPeriod'>
    


  /**
   * Reference to a field of type 'AnalyticsPeriod[]'
   */
  export type ListEnumAnalyticsPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnalyticsPeriod[]'>
    


  /**
   * Reference to a field of type 'IntegrationType'
   */
  export type EnumIntegrationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IntegrationType'>
    


  /**
   * Reference to a field of type 'IntegrationType[]'
   */
  export type ListEnumIntegrationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IntegrationType[]'>
    


  /**
   * Reference to a field of type 'ConnectionStatus'
   */
  export type EnumConnectionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConnectionStatus'>
    


  /**
   * Reference to a field of type 'ConnectionStatus[]'
   */
  export type ListEnumConnectionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConnectionStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    password?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    isActive?: BoolFilter<"User"> | boolean
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    contacts?: ContactListRelationFilter
    emailCampaigns?: EmailCampaignListRelationFilter
    emailTemplates?: EmailTemplateListRelationFilter
    smsCampaigns?: SMSCampaignListRelationFilter
    smsTemplates?: SMSTemplateListRelationFilter
    waCampaigns?: WhatsAppCampaignListRelationFilter
    waTemplates?: WhatsAppTemplateListRelationFilter
    workflows?: WorkflowListRelationFilter
    lists?: ListListRelationFilter
    segments?: SegmentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    isActive?: SortOrder
    role?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
    emailCampaigns?: EmailCampaignOrderByRelationAggregateInput
    emailTemplates?: EmailTemplateOrderByRelationAggregateInput
    smsCampaigns?: SMSCampaignOrderByRelationAggregateInput
    smsTemplates?: SMSTemplateOrderByRelationAggregateInput
    waCampaigns?: WhatsAppCampaignOrderByRelationAggregateInput
    waTemplates?: WhatsAppTemplateOrderByRelationAggregateInput
    workflows?: WorkflowOrderByRelationAggregateInput
    lists?: ListOrderByRelationAggregateInput
    segments?: SegmentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    password?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    isActive?: BoolFilter<"User"> | boolean
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    contacts?: ContactListRelationFilter
    emailCampaigns?: EmailCampaignListRelationFilter
    emailTemplates?: EmailTemplateListRelationFilter
    smsCampaigns?: SMSCampaignListRelationFilter
    smsTemplates?: SMSTemplateListRelationFilter
    waCampaigns?: WhatsAppCampaignListRelationFilter
    waTemplates?: WhatsAppTemplateListRelationFilter
    workflows?: WorkflowListRelationFilter
    lists?: ListListRelationFilter
    segments?: SegmentListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    isActive?: SortOrder
    role?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    email?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    firstName?: StringNullableFilter<"Contact"> | string | null
    lastName?: StringNullableFilter<"Contact"> | string | null
    company?: StringNullableFilter<"Contact"> | string | null
    jobTitle?: StringNullableFilter<"Contact"> | string | null
    address?: StringNullableFilter<"Contact"> | string | null
    city?: StringNullableFilter<"Contact"> | string | null
    state?: StringNullableFilter<"Contact"> | string | null
    country?: StringNullableFilter<"Contact"> | string | null
    postalCode?: StringNullableFilter<"Contact"> | string | null
    notes?: StringNullableFilter<"Contact"> | string | null
    tagsString?: StringNullableFilter<"Contact"> | string | null
    source?: StringNullableFilter<"Contact"> | string | null
    status?: EnumContactStatusFilter<"Contact"> | $Enums.ContactStatus
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    createdById?: StringFilter<"Contact"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    listMembers?: ListMemberListRelationFilter
    emailActivities?: EmailActivityListRelationFilter
    smsActivities?: SMSActivityListRelationFilter
    waActivities?: WhatsAppActivityListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    jobTitle?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tagsString?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    listMembers?: ListMemberOrderByRelationAggregateInput
    emailActivities?: EmailActivityOrderByRelationAggregateInput
    smsActivities?: SMSActivityOrderByRelationAggregateInput
    waActivities?: WhatsAppActivityOrderByRelationAggregateInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    email?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    firstName?: StringNullableFilter<"Contact"> | string | null
    lastName?: StringNullableFilter<"Contact"> | string | null
    company?: StringNullableFilter<"Contact"> | string | null
    jobTitle?: StringNullableFilter<"Contact"> | string | null
    address?: StringNullableFilter<"Contact"> | string | null
    city?: StringNullableFilter<"Contact"> | string | null
    state?: StringNullableFilter<"Contact"> | string | null
    country?: StringNullableFilter<"Contact"> | string | null
    postalCode?: StringNullableFilter<"Contact"> | string | null
    notes?: StringNullableFilter<"Contact"> | string | null
    tagsString?: StringNullableFilter<"Contact"> | string | null
    source?: StringNullableFilter<"Contact"> | string | null
    status?: EnumContactStatusFilter<"Contact"> | $Enums.ContactStatus
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    createdById?: StringFilter<"Contact"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    listMembers?: ListMemberListRelationFilter
    emailActivities?: EmailActivityListRelationFilter
    smsActivities?: SMSActivityListRelationFilter
    waActivities?: WhatsAppActivityListRelationFilter
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    jobTitle?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tagsString?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    email?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    company?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    jobTitle?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    address?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    city?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    state?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    country?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    tagsString?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    source?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    status?: EnumContactStatusWithAggregatesFilter<"Contact"> | $Enums.ContactStatus
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    createdById?: StringWithAggregatesFilter<"Contact"> | string
  }

  export type ListWhereInput = {
    AND?: ListWhereInput | ListWhereInput[]
    OR?: ListWhereInput[]
    NOT?: ListWhereInput | ListWhereInput[]
    id?: StringFilter<"List"> | string
    name?: StringFilter<"List"> | string
    description?: StringNullableFilter<"List"> | string | null
    type?: EnumListTypeFilter<"List"> | $Enums.ListType
    createdAt?: DateTimeFilter<"List"> | Date | string
    updatedAt?: DateTimeFilter<"List"> | Date | string
    createdById?: StringFilter<"List"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: ListMemberListRelationFilter
    emailCampaigns?: EmailCampaignListRelationFilter
    smsCampaigns?: SMSCampaignListRelationFilter
    waCampaigns?: WhatsAppCampaignListRelationFilter
  }

  export type ListOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    members?: ListMemberOrderByRelationAggregateInput
    emailCampaigns?: EmailCampaignOrderByRelationAggregateInput
    smsCampaigns?: SMSCampaignOrderByRelationAggregateInput
    waCampaigns?: WhatsAppCampaignOrderByRelationAggregateInput
  }

  export type ListWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ListWhereInput | ListWhereInput[]
    OR?: ListWhereInput[]
    NOT?: ListWhereInput | ListWhereInput[]
    name?: StringFilter<"List"> | string
    description?: StringNullableFilter<"List"> | string | null
    type?: EnumListTypeFilter<"List"> | $Enums.ListType
    createdAt?: DateTimeFilter<"List"> | Date | string
    updatedAt?: DateTimeFilter<"List"> | Date | string
    createdById?: StringFilter<"List"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: ListMemberListRelationFilter
    emailCampaigns?: EmailCampaignListRelationFilter
    smsCampaigns?: SMSCampaignListRelationFilter
    waCampaigns?: WhatsAppCampaignListRelationFilter
  }, "id">

  export type ListOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: ListCountOrderByAggregateInput
    _max?: ListMaxOrderByAggregateInput
    _min?: ListMinOrderByAggregateInput
  }

  export type ListScalarWhereWithAggregatesInput = {
    AND?: ListScalarWhereWithAggregatesInput | ListScalarWhereWithAggregatesInput[]
    OR?: ListScalarWhereWithAggregatesInput[]
    NOT?: ListScalarWhereWithAggregatesInput | ListScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"List"> | string
    name?: StringWithAggregatesFilter<"List"> | string
    description?: StringNullableWithAggregatesFilter<"List"> | string | null
    type?: EnumListTypeWithAggregatesFilter<"List"> | $Enums.ListType
    createdAt?: DateTimeWithAggregatesFilter<"List"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"List"> | Date | string
    createdById?: StringWithAggregatesFilter<"List"> | string
  }

  export type ListMemberWhereInput = {
    AND?: ListMemberWhereInput | ListMemberWhereInput[]
    OR?: ListMemberWhereInput[]
    NOT?: ListMemberWhereInput | ListMemberWhereInput[]
    id?: StringFilter<"ListMember"> | string
    listId?: StringFilter<"ListMember"> | string
    contactId?: StringFilter<"ListMember"> | string
    addedAt?: DateTimeFilter<"ListMember"> | Date | string
    list?: XOR<ListScalarRelationFilter, ListWhereInput>
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
  }

  export type ListMemberOrderByWithRelationInput = {
    id?: SortOrder
    listId?: SortOrder
    contactId?: SortOrder
    addedAt?: SortOrder
    list?: ListOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
  }

  export type ListMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    listId_contactId?: ListMemberListIdContactIdCompoundUniqueInput
    AND?: ListMemberWhereInput | ListMemberWhereInput[]
    OR?: ListMemberWhereInput[]
    NOT?: ListMemberWhereInput | ListMemberWhereInput[]
    listId?: StringFilter<"ListMember"> | string
    contactId?: StringFilter<"ListMember"> | string
    addedAt?: DateTimeFilter<"ListMember"> | Date | string
    list?: XOR<ListScalarRelationFilter, ListWhereInput>
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
  }, "id" | "listId_contactId">

  export type ListMemberOrderByWithAggregationInput = {
    id?: SortOrder
    listId?: SortOrder
    contactId?: SortOrder
    addedAt?: SortOrder
    _count?: ListMemberCountOrderByAggregateInput
    _max?: ListMemberMaxOrderByAggregateInput
    _min?: ListMemberMinOrderByAggregateInput
  }

  export type ListMemberScalarWhereWithAggregatesInput = {
    AND?: ListMemberScalarWhereWithAggregatesInput | ListMemberScalarWhereWithAggregatesInput[]
    OR?: ListMemberScalarWhereWithAggregatesInput[]
    NOT?: ListMemberScalarWhereWithAggregatesInput | ListMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ListMember"> | string
    listId?: StringWithAggregatesFilter<"ListMember"> | string
    contactId?: StringWithAggregatesFilter<"ListMember"> | string
    addedAt?: DateTimeWithAggregatesFilter<"ListMember"> | Date | string
  }

  export type SegmentWhereInput = {
    AND?: SegmentWhereInput | SegmentWhereInput[]
    OR?: SegmentWhereInput[]
    NOT?: SegmentWhereInput | SegmentWhereInput[]
    id?: StringFilter<"Segment"> | string
    name?: StringFilter<"Segment"> | string
    description?: StringNullableFilter<"Segment"> | string | null
    rules?: StringFilter<"Segment"> | string
    createdAt?: DateTimeFilter<"Segment"> | Date | string
    updatedAt?: DateTimeFilter<"Segment"> | Date | string
    createdById?: StringFilter<"Segment"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    emailCampaigns?: EmailCampaignListRelationFilter
    smsCampaigns?: SMSCampaignListRelationFilter
    waCampaigns?: WhatsAppCampaignListRelationFilter
  }

  export type SegmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    rules?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    emailCampaigns?: EmailCampaignOrderByRelationAggregateInput
    smsCampaigns?: SMSCampaignOrderByRelationAggregateInput
    waCampaigns?: WhatsAppCampaignOrderByRelationAggregateInput
  }

  export type SegmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SegmentWhereInput | SegmentWhereInput[]
    OR?: SegmentWhereInput[]
    NOT?: SegmentWhereInput | SegmentWhereInput[]
    name?: StringFilter<"Segment"> | string
    description?: StringNullableFilter<"Segment"> | string | null
    rules?: StringFilter<"Segment"> | string
    createdAt?: DateTimeFilter<"Segment"> | Date | string
    updatedAt?: DateTimeFilter<"Segment"> | Date | string
    createdById?: StringFilter<"Segment"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    emailCampaigns?: EmailCampaignListRelationFilter
    smsCampaigns?: SMSCampaignListRelationFilter
    waCampaigns?: WhatsAppCampaignListRelationFilter
  }, "id">

  export type SegmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    rules?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: SegmentCountOrderByAggregateInput
    _max?: SegmentMaxOrderByAggregateInput
    _min?: SegmentMinOrderByAggregateInput
  }

  export type SegmentScalarWhereWithAggregatesInput = {
    AND?: SegmentScalarWhereWithAggregatesInput | SegmentScalarWhereWithAggregatesInput[]
    OR?: SegmentScalarWhereWithAggregatesInput[]
    NOT?: SegmentScalarWhereWithAggregatesInput | SegmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Segment"> | string
    name?: StringWithAggregatesFilter<"Segment"> | string
    description?: StringNullableWithAggregatesFilter<"Segment"> | string | null
    rules?: StringWithAggregatesFilter<"Segment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Segment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Segment"> | Date | string
    createdById?: StringWithAggregatesFilter<"Segment"> | string
  }

  export type EmailTemplateWhereInput = {
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    id?: StringFilter<"EmailTemplate"> | string
    name?: StringFilter<"EmailTemplate"> | string
    description?: StringNullableFilter<"EmailTemplate"> | string | null
    subject?: StringFilter<"EmailTemplate"> | string
    content?: StringFilter<"EmailTemplate"> | string
    design?: StringNullableFilter<"EmailTemplate"> | string | null
    previewText?: StringNullableFilter<"EmailTemplate"> | string | null
    category?: StringNullableFilter<"EmailTemplate"> | string | null
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    createdById?: StringFilter<"EmailTemplate"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaigns?: EmailCampaignListRelationFilter
  }

  export type EmailTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    subject?: SortOrder
    content?: SortOrder
    design?: SortOrderInput | SortOrder
    previewText?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    campaigns?: EmailCampaignOrderByRelationAggregateInput
  }

  export type EmailTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    name?: StringFilter<"EmailTemplate"> | string
    description?: StringNullableFilter<"EmailTemplate"> | string | null
    subject?: StringFilter<"EmailTemplate"> | string
    content?: StringFilter<"EmailTemplate"> | string
    design?: StringNullableFilter<"EmailTemplate"> | string | null
    previewText?: StringNullableFilter<"EmailTemplate"> | string | null
    category?: StringNullableFilter<"EmailTemplate"> | string | null
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    createdById?: StringFilter<"EmailTemplate"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaigns?: EmailCampaignListRelationFilter
  }, "id">

  export type EmailTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    subject?: SortOrder
    content?: SortOrder
    design?: SortOrderInput | SortOrder
    previewText?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: EmailTemplateCountOrderByAggregateInput
    _max?: EmailTemplateMaxOrderByAggregateInput
    _min?: EmailTemplateMinOrderByAggregateInput
  }

  export type EmailTemplateScalarWhereWithAggregatesInput = {
    AND?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    OR?: EmailTemplateScalarWhereWithAggregatesInput[]
    NOT?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailTemplate"> | string
    name?: StringWithAggregatesFilter<"EmailTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"EmailTemplate"> | string | null
    subject?: StringWithAggregatesFilter<"EmailTemplate"> | string
    content?: StringWithAggregatesFilter<"EmailTemplate"> | string
    design?: StringNullableWithAggregatesFilter<"EmailTemplate"> | string | null
    previewText?: StringNullableWithAggregatesFilter<"EmailTemplate"> | string | null
    category?: StringNullableWithAggregatesFilter<"EmailTemplate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
    createdById?: StringWithAggregatesFilter<"EmailTemplate"> | string
  }

  export type EmailCampaignWhereInput = {
    AND?: EmailCampaignWhereInput | EmailCampaignWhereInput[]
    OR?: EmailCampaignWhereInput[]
    NOT?: EmailCampaignWhereInput | EmailCampaignWhereInput[]
    id?: StringFilter<"EmailCampaign"> | string
    name?: StringFilter<"EmailCampaign"> | string
    description?: StringNullableFilter<"EmailCampaign"> | string | null
    subject?: StringFilter<"EmailCampaign"> | string
    from?: StringFilter<"EmailCampaign"> | string
    replyTo?: StringNullableFilter<"EmailCampaign"> | string | null
    templateId?: StringNullableFilter<"EmailCampaign"> | string | null
    content?: StringNullableFilter<"EmailCampaign"> | string | null
    design?: StringNullableFilter<"EmailCampaign"> | string | null
    status?: EnumCampaignStatusFilter<"EmailCampaign"> | $Enums.CampaignStatus
    scheduledFor?: DateTimeNullableFilter<"EmailCampaign"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"EmailCampaign"> | Date | string | null
    createdAt?: DateTimeFilter<"EmailCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"EmailCampaign"> | Date | string
    createdById?: StringFilter<"EmailCampaign"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    template?: XOR<EmailTemplateNullableScalarRelationFilter, EmailTemplateWhereInput> | null
    lists?: ListListRelationFilter
    segments?: SegmentListRelationFilter
    activities?: EmailActivityListRelationFilter
  }

  export type EmailCampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    subject?: SortOrder
    from?: SortOrder
    replyTo?: SortOrderInput | SortOrder
    templateId?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    design?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    template?: EmailTemplateOrderByWithRelationInput
    lists?: ListOrderByRelationAggregateInput
    segments?: SegmentOrderByRelationAggregateInput
    activities?: EmailActivityOrderByRelationAggregateInput
  }

  export type EmailCampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailCampaignWhereInput | EmailCampaignWhereInput[]
    OR?: EmailCampaignWhereInput[]
    NOT?: EmailCampaignWhereInput | EmailCampaignWhereInput[]
    name?: StringFilter<"EmailCampaign"> | string
    description?: StringNullableFilter<"EmailCampaign"> | string | null
    subject?: StringFilter<"EmailCampaign"> | string
    from?: StringFilter<"EmailCampaign"> | string
    replyTo?: StringNullableFilter<"EmailCampaign"> | string | null
    templateId?: StringNullableFilter<"EmailCampaign"> | string | null
    content?: StringNullableFilter<"EmailCampaign"> | string | null
    design?: StringNullableFilter<"EmailCampaign"> | string | null
    status?: EnumCampaignStatusFilter<"EmailCampaign"> | $Enums.CampaignStatus
    scheduledFor?: DateTimeNullableFilter<"EmailCampaign"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"EmailCampaign"> | Date | string | null
    createdAt?: DateTimeFilter<"EmailCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"EmailCampaign"> | Date | string
    createdById?: StringFilter<"EmailCampaign"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    template?: XOR<EmailTemplateNullableScalarRelationFilter, EmailTemplateWhereInput> | null
    lists?: ListListRelationFilter
    segments?: SegmentListRelationFilter
    activities?: EmailActivityListRelationFilter
  }, "id">

  export type EmailCampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    subject?: SortOrder
    from?: SortOrder
    replyTo?: SortOrderInput | SortOrder
    templateId?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    design?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: EmailCampaignCountOrderByAggregateInput
    _max?: EmailCampaignMaxOrderByAggregateInput
    _min?: EmailCampaignMinOrderByAggregateInput
  }

  export type EmailCampaignScalarWhereWithAggregatesInput = {
    AND?: EmailCampaignScalarWhereWithAggregatesInput | EmailCampaignScalarWhereWithAggregatesInput[]
    OR?: EmailCampaignScalarWhereWithAggregatesInput[]
    NOT?: EmailCampaignScalarWhereWithAggregatesInput | EmailCampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailCampaign"> | string
    name?: StringWithAggregatesFilter<"EmailCampaign"> | string
    description?: StringNullableWithAggregatesFilter<"EmailCampaign"> | string | null
    subject?: StringWithAggregatesFilter<"EmailCampaign"> | string
    from?: StringWithAggregatesFilter<"EmailCampaign"> | string
    replyTo?: StringNullableWithAggregatesFilter<"EmailCampaign"> | string | null
    templateId?: StringNullableWithAggregatesFilter<"EmailCampaign"> | string | null
    content?: StringNullableWithAggregatesFilter<"EmailCampaign"> | string | null
    design?: StringNullableWithAggregatesFilter<"EmailCampaign"> | string | null
    status?: EnumCampaignStatusWithAggregatesFilter<"EmailCampaign"> | $Enums.CampaignStatus
    scheduledFor?: DateTimeNullableWithAggregatesFilter<"EmailCampaign"> | Date | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"EmailCampaign"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailCampaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailCampaign"> | Date | string
    createdById?: StringWithAggregatesFilter<"EmailCampaign"> | string
  }

  export type EmailActivityWhereInput = {
    AND?: EmailActivityWhereInput | EmailActivityWhereInput[]
    OR?: EmailActivityWhereInput[]
    NOT?: EmailActivityWhereInput | EmailActivityWhereInput[]
    id?: StringFilter<"EmailActivity"> | string
    campaignId?: StringFilter<"EmailActivity"> | string
    contactId?: StringFilter<"EmailActivity"> | string
    type?: EnumActivityTypeFilter<"EmailActivity"> | $Enums.ActivityType
    timestamp?: DateTimeFilter<"EmailActivity"> | Date | string
    metadata?: StringNullableFilter<"EmailActivity"> | string | null
    campaign?: XOR<EmailCampaignScalarRelationFilter, EmailCampaignWhereInput>
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
  }

  export type EmailActivityOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrderInput | SortOrder
    campaign?: EmailCampaignOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
  }

  export type EmailActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailActivityWhereInput | EmailActivityWhereInput[]
    OR?: EmailActivityWhereInput[]
    NOT?: EmailActivityWhereInput | EmailActivityWhereInput[]
    campaignId?: StringFilter<"EmailActivity"> | string
    contactId?: StringFilter<"EmailActivity"> | string
    type?: EnumActivityTypeFilter<"EmailActivity"> | $Enums.ActivityType
    timestamp?: DateTimeFilter<"EmailActivity"> | Date | string
    metadata?: StringNullableFilter<"EmailActivity"> | string | null
    campaign?: XOR<EmailCampaignScalarRelationFilter, EmailCampaignWhereInput>
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
  }, "id">

  export type EmailActivityOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: EmailActivityCountOrderByAggregateInput
    _max?: EmailActivityMaxOrderByAggregateInput
    _min?: EmailActivityMinOrderByAggregateInput
  }

  export type EmailActivityScalarWhereWithAggregatesInput = {
    AND?: EmailActivityScalarWhereWithAggregatesInput | EmailActivityScalarWhereWithAggregatesInput[]
    OR?: EmailActivityScalarWhereWithAggregatesInput[]
    NOT?: EmailActivityScalarWhereWithAggregatesInput | EmailActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailActivity"> | string
    campaignId?: StringWithAggregatesFilter<"EmailActivity"> | string
    contactId?: StringWithAggregatesFilter<"EmailActivity"> | string
    type?: EnumActivityTypeWithAggregatesFilter<"EmailActivity"> | $Enums.ActivityType
    timestamp?: DateTimeWithAggregatesFilter<"EmailActivity"> | Date | string
    metadata?: StringNullableWithAggregatesFilter<"EmailActivity"> | string | null
  }

  export type SMSTemplateWhereInput = {
    AND?: SMSTemplateWhereInput | SMSTemplateWhereInput[]
    OR?: SMSTemplateWhereInput[]
    NOT?: SMSTemplateWhereInput | SMSTemplateWhereInput[]
    id?: StringFilter<"SMSTemplate"> | string
    name?: StringFilter<"SMSTemplate"> | string
    content?: StringFilter<"SMSTemplate"> | string
    variables?: StringFilter<"SMSTemplate"> | string
    category?: StringNullableFilter<"SMSTemplate"> | string | null
    createdAt?: DateTimeFilter<"SMSTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"SMSTemplate"> | Date | string
    createdById?: StringFilter<"SMSTemplate"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaigns?: SMSCampaignListRelationFilter
  }

  export type SMSTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    variables?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    campaigns?: SMSCampaignOrderByRelationAggregateInput
  }

  export type SMSTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SMSTemplateWhereInput | SMSTemplateWhereInput[]
    OR?: SMSTemplateWhereInput[]
    NOT?: SMSTemplateWhereInput | SMSTemplateWhereInput[]
    name?: StringFilter<"SMSTemplate"> | string
    content?: StringFilter<"SMSTemplate"> | string
    variables?: StringFilter<"SMSTemplate"> | string
    category?: StringNullableFilter<"SMSTemplate"> | string | null
    createdAt?: DateTimeFilter<"SMSTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"SMSTemplate"> | Date | string
    createdById?: StringFilter<"SMSTemplate"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaigns?: SMSCampaignListRelationFilter
  }, "id">

  export type SMSTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    variables?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: SMSTemplateCountOrderByAggregateInput
    _max?: SMSTemplateMaxOrderByAggregateInput
    _min?: SMSTemplateMinOrderByAggregateInput
  }

  export type SMSTemplateScalarWhereWithAggregatesInput = {
    AND?: SMSTemplateScalarWhereWithAggregatesInput | SMSTemplateScalarWhereWithAggregatesInput[]
    OR?: SMSTemplateScalarWhereWithAggregatesInput[]
    NOT?: SMSTemplateScalarWhereWithAggregatesInput | SMSTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SMSTemplate"> | string
    name?: StringWithAggregatesFilter<"SMSTemplate"> | string
    content?: StringWithAggregatesFilter<"SMSTemplate"> | string
    variables?: StringWithAggregatesFilter<"SMSTemplate"> | string
    category?: StringNullableWithAggregatesFilter<"SMSTemplate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SMSTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SMSTemplate"> | Date | string
    createdById?: StringWithAggregatesFilter<"SMSTemplate"> | string
  }

  export type SMSCampaignWhereInput = {
    AND?: SMSCampaignWhereInput | SMSCampaignWhereInput[]
    OR?: SMSCampaignWhereInput[]
    NOT?: SMSCampaignWhereInput | SMSCampaignWhereInput[]
    id?: StringFilter<"SMSCampaign"> | string
    name?: StringFilter<"SMSCampaign"> | string
    description?: StringNullableFilter<"SMSCampaign"> | string | null
    from?: StringFilter<"SMSCampaign"> | string
    templateId?: StringNullableFilter<"SMSCampaign"> | string | null
    content?: StringNullableFilter<"SMSCampaign"> | string | null
    status?: EnumCampaignStatusFilter<"SMSCampaign"> | $Enums.CampaignStatus
    scheduledFor?: DateTimeNullableFilter<"SMSCampaign"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"SMSCampaign"> | Date | string | null
    createdAt?: DateTimeFilter<"SMSCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"SMSCampaign"> | Date | string
    createdById?: StringFilter<"SMSCampaign"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    template?: XOR<SMSTemplateNullableScalarRelationFilter, SMSTemplateWhereInput> | null
    lists?: ListListRelationFilter
    segments?: SegmentListRelationFilter
    activities?: SMSActivityListRelationFilter
  }

  export type SMSCampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    from?: SortOrder
    templateId?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    template?: SMSTemplateOrderByWithRelationInput
    lists?: ListOrderByRelationAggregateInput
    segments?: SegmentOrderByRelationAggregateInput
    activities?: SMSActivityOrderByRelationAggregateInput
  }

  export type SMSCampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SMSCampaignWhereInput | SMSCampaignWhereInput[]
    OR?: SMSCampaignWhereInput[]
    NOT?: SMSCampaignWhereInput | SMSCampaignWhereInput[]
    name?: StringFilter<"SMSCampaign"> | string
    description?: StringNullableFilter<"SMSCampaign"> | string | null
    from?: StringFilter<"SMSCampaign"> | string
    templateId?: StringNullableFilter<"SMSCampaign"> | string | null
    content?: StringNullableFilter<"SMSCampaign"> | string | null
    status?: EnumCampaignStatusFilter<"SMSCampaign"> | $Enums.CampaignStatus
    scheduledFor?: DateTimeNullableFilter<"SMSCampaign"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"SMSCampaign"> | Date | string | null
    createdAt?: DateTimeFilter<"SMSCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"SMSCampaign"> | Date | string
    createdById?: StringFilter<"SMSCampaign"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    template?: XOR<SMSTemplateNullableScalarRelationFilter, SMSTemplateWhereInput> | null
    lists?: ListListRelationFilter
    segments?: SegmentListRelationFilter
    activities?: SMSActivityListRelationFilter
  }, "id">

  export type SMSCampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    from?: SortOrder
    templateId?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: SMSCampaignCountOrderByAggregateInput
    _max?: SMSCampaignMaxOrderByAggregateInput
    _min?: SMSCampaignMinOrderByAggregateInput
  }

  export type SMSCampaignScalarWhereWithAggregatesInput = {
    AND?: SMSCampaignScalarWhereWithAggregatesInput | SMSCampaignScalarWhereWithAggregatesInput[]
    OR?: SMSCampaignScalarWhereWithAggregatesInput[]
    NOT?: SMSCampaignScalarWhereWithAggregatesInput | SMSCampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SMSCampaign"> | string
    name?: StringWithAggregatesFilter<"SMSCampaign"> | string
    description?: StringNullableWithAggregatesFilter<"SMSCampaign"> | string | null
    from?: StringWithAggregatesFilter<"SMSCampaign"> | string
    templateId?: StringNullableWithAggregatesFilter<"SMSCampaign"> | string | null
    content?: StringNullableWithAggregatesFilter<"SMSCampaign"> | string | null
    status?: EnumCampaignStatusWithAggregatesFilter<"SMSCampaign"> | $Enums.CampaignStatus
    scheduledFor?: DateTimeNullableWithAggregatesFilter<"SMSCampaign"> | Date | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"SMSCampaign"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SMSCampaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SMSCampaign"> | Date | string
    createdById?: StringWithAggregatesFilter<"SMSCampaign"> | string
  }

  export type SMSActivityWhereInput = {
    AND?: SMSActivityWhereInput | SMSActivityWhereInput[]
    OR?: SMSActivityWhereInput[]
    NOT?: SMSActivityWhereInput | SMSActivityWhereInput[]
    id?: StringFilter<"SMSActivity"> | string
    campaignId?: StringFilter<"SMSActivity"> | string
    contactId?: StringFilter<"SMSActivity"> | string
    type?: EnumActivityTypeFilter<"SMSActivity"> | $Enums.ActivityType
    timestamp?: DateTimeFilter<"SMSActivity"> | Date | string
    metadata?: StringNullableFilter<"SMSActivity"> | string | null
    campaign?: XOR<SMSCampaignScalarRelationFilter, SMSCampaignWhereInput>
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
  }

  export type SMSActivityOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrderInput | SortOrder
    campaign?: SMSCampaignOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
  }

  export type SMSActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SMSActivityWhereInput | SMSActivityWhereInput[]
    OR?: SMSActivityWhereInput[]
    NOT?: SMSActivityWhereInput | SMSActivityWhereInput[]
    campaignId?: StringFilter<"SMSActivity"> | string
    contactId?: StringFilter<"SMSActivity"> | string
    type?: EnumActivityTypeFilter<"SMSActivity"> | $Enums.ActivityType
    timestamp?: DateTimeFilter<"SMSActivity"> | Date | string
    metadata?: StringNullableFilter<"SMSActivity"> | string | null
    campaign?: XOR<SMSCampaignScalarRelationFilter, SMSCampaignWhereInput>
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
  }, "id">

  export type SMSActivityOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: SMSActivityCountOrderByAggregateInput
    _max?: SMSActivityMaxOrderByAggregateInput
    _min?: SMSActivityMinOrderByAggregateInput
  }

  export type SMSActivityScalarWhereWithAggregatesInput = {
    AND?: SMSActivityScalarWhereWithAggregatesInput | SMSActivityScalarWhereWithAggregatesInput[]
    OR?: SMSActivityScalarWhereWithAggregatesInput[]
    NOT?: SMSActivityScalarWhereWithAggregatesInput | SMSActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SMSActivity"> | string
    campaignId?: StringWithAggregatesFilter<"SMSActivity"> | string
    contactId?: StringWithAggregatesFilter<"SMSActivity"> | string
    type?: EnumActivityTypeWithAggregatesFilter<"SMSActivity"> | $Enums.ActivityType
    timestamp?: DateTimeWithAggregatesFilter<"SMSActivity"> | Date | string
    metadata?: StringNullableWithAggregatesFilter<"SMSActivity"> | string | null
  }

  export type WhatsAppTemplateWhereInput = {
    AND?: WhatsAppTemplateWhereInput | WhatsAppTemplateWhereInput[]
    OR?: WhatsAppTemplateWhereInput[]
    NOT?: WhatsAppTemplateWhereInput | WhatsAppTemplateWhereInput[]
    id?: StringFilter<"WhatsAppTemplate"> | string
    name?: StringFilter<"WhatsAppTemplate"> | string
    content?: StringFilter<"WhatsAppTemplate"> | string
    variables?: StringFilter<"WhatsAppTemplate"> | string
    category?: StringNullableFilter<"WhatsAppTemplate"> | string | null
    status?: EnumWATemplateStatusFilter<"WhatsAppTemplate"> | $Enums.WATemplateStatus
    createdAt?: DateTimeFilter<"WhatsAppTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppTemplate"> | Date | string
    createdById?: StringFilter<"WhatsAppTemplate"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaigns?: WhatsAppCampaignListRelationFilter
  }

  export type WhatsAppTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    variables?: SortOrder
    category?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    campaigns?: WhatsAppCampaignOrderByRelationAggregateInput
  }

  export type WhatsAppTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WhatsAppTemplateWhereInput | WhatsAppTemplateWhereInput[]
    OR?: WhatsAppTemplateWhereInput[]
    NOT?: WhatsAppTemplateWhereInput | WhatsAppTemplateWhereInput[]
    name?: StringFilter<"WhatsAppTemplate"> | string
    content?: StringFilter<"WhatsAppTemplate"> | string
    variables?: StringFilter<"WhatsAppTemplate"> | string
    category?: StringNullableFilter<"WhatsAppTemplate"> | string | null
    status?: EnumWATemplateStatusFilter<"WhatsAppTemplate"> | $Enums.WATemplateStatus
    createdAt?: DateTimeFilter<"WhatsAppTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppTemplate"> | Date | string
    createdById?: StringFilter<"WhatsAppTemplate"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaigns?: WhatsAppCampaignListRelationFilter
  }, "id">

  export type WhatsAppTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    variables?: SortOrder
    category?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: WhatsAppTemplateCountOrderByAggregateInput
    _max?: WhatsAppTemplateMaxOrderByAggregateInput
    _min?: WhatsAppTemplateMinOrderByAggregateInput
  }

  export type WhatsAppTemplateScalarWhereWithAggregatesInput = {
    AND?: WhatsAppTemplateScalarWhereWithAggregatesInput | WhatsAppTemplateScalarWhereWithAggregatesInput[]
    OR?: WhatsAppTemplateScalarWhereWithAggregatesInput[]
    NOT?: WhatsAppTemplateScalarWhereWithAggregatesInput | WhatsAppTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhatsAppTemplate"> | string
    name?: StringWithAggregatesFilter<"WhatsAppTemplate"> | string
    content?: StringWithAggregatesFilter<"WhatsAppTemplate"> | string
    variables?: StringWithAggregatesFilter<"WhatsAppTemplate"> | string
    category?: StringNullableWithAggregatesFilter<"WhatsAppTemplate"> | string | null
    status?: EnumWATemplateStatusWithAggregatesFilter<"WhatsAppTemplate"> | $Enums.WATemplateStatus
    createdAt?: DateTimeWithAggregatesFilter<"WhatsAppTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WhatsAppTemplate"> | Date | string
    createdById?: StringWithAggregatesFilter<"WhatsAppTemplate"> | string
  }

  export type WhatsAppCampaignWhereInput = {
    AND?: WhatsAppCampaignWhereInput | WhatsAppCampaignWhereInput[]
    OR?: WhatsAppCampaignWhereInput[]
    NOT?: WhatsAppCampaignWhereInput | WhatsAppCampaignWhereInput[]
    id?: StringFilter<"WhatsAppCampaign"> | string
    name?: StringFilter<"WhatsAppCampaign"> | string
    description?: StringNullableFilter<"WhatsAppCampaign"> | string | null
    from?: StringFilter<"WhatsAppCampaign"> | string
    templateId?: StringNullableFilter<"WhatsAppCampaign"> | string | null
    content?: StringNullableFilter<"WhatsAppCampaign"> | string | null
    status?: EnumCampaignStatusFilter<"WhatsAppCampaign"> | $Enums.CampaignStatus
    scheduledFor?: DateTimeNullableFilter<"WhatsAppCampaign"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"WhatsAppCampaign"> | Date | string | null
    createdAt?: DateTimeFilter<"WhatsAppCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppCampaign"> | Date | string
    createdById?: StringFilter<"WhatsAppCampaign"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    template?: XOR<WhatsAppTemplateNullableScalarRelationFilter, WhatsAppTemplateWhereInput> | null
    lists?: ListListRelationFilter
    segments?: SegmentListRelationFilter
    activities?: WhatsAppActivityListRelationFilter
  }

  export type WhatsAppCampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    from?: SortOrder
    templateId?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    template?: WhatsAppTemplateOrderByWithRelationInput
    lists?: ListOrderByRelationAggregateInput
    segments?: SegmentOrderByRelationAggregateInput
    activities?: WhatsAppActivityOrderByRelationAggregateInput
  }

  export type WhatsAppCampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WhatsAppCampaignWhereInput | WhatsAppCampaignWhereInput[]
    OR?: WhatsAppCampaignWhereInput[]
    NOT?: WhatsAppCampaignWhereInput | WhatsAppCampaignWhereInput[]
    name?: StringFilter<"WhatsAppCampaign"> | string
    description?: StringNullableFilter<"WhatsAppCampaign"> | string | null
    from?: StringFilter<"WhatsAppCampaign"> | string
    templateId?: StringNullableFilter<"WhatsAppCampaign"> | string | null
    content?: StringNullableFilter<"WhatsAppCampaign"> | string | null
    status?: EnumCampaignStatusFilter<"WhatsAppCampaign"> | $Enums.CampaignStatus
    scheduledFor?: DateTimeNullableFilter<"WhatsAppCampaign"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"WhatsAppCampaign"> | Date | string | null
    createdAt?: DateTimeFilter<"WhatsAppCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppCampaign"> | Date | string
    createdById?: StringFilter<"WhatsAppCampaign"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    template?: XOR<WhatsAppTemplateNullableScalarRelationFilter, WhatsAppTemplateWhereInput> | null
    lists?: ListListRelationFilter
    segments?: SegmentListRelationFilter
    activities?: WhatsAppActivityListRelationFilter
  }, "id">

  export type WhatsAppCampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    from?: SortOrder
    templateId?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: WhatsAppCampaignCountOrderByAggregateInput
    _max?: WhatsAppCampaignMaxOrderByAggregateInput
    _min?: WhatsAppCampaignMinOrderByAggregateInput
  }

  export type WhatsAppCampaignScalarWhereWithAggregatesInput = {
    AND?: WhatsAppCampaignScalarWhereWithAggregatesInput | WhatsAppCampaignScalarWhereWithAggregatesInput[]
    OR?: WhatsAppCampaignScalarWhereWithAggregatesInput[]
    NOT?: WhatsAppCampaignScalarWhereWithAggregatesInput | WhatsAppCampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhatsAppCampaign"> | string
    name?: StringWithAggregatesFilter<"WhatsAppCampaign"> | string
    description?: StringNullableWithAggregatesFilter<"WhatsAppCampaign"> | string | null
    from?: StringWithAggregatesFilter<"WhatsAppCampaign"> | string
    templateId?: StringNullableWithAggregatesFilter<"WhatsAppCampaign"> | string | null
    content?: StringNullableWithAggregatesFilter<"WhatsAppCampaign"> | string | null
    status?: EnumCampaignStatusWithAggregatesFilter<"WhatsAppCampaign"> | $Enums.CampaignStatus
    scheduledFor?: DateTimeNullableWithAggregatesFilter<"WhatsAppCampaign"> | Date | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"WhatsAppCampaign"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WhatsAppCampaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WhatsAppCampaign"> | Date | string
    createdById?: StringWithAggregatesFilter<"WhatsAppCampaign"> | string
  }

  export type WhatsAppActivityWhereInput = {
    AND?: WhatsAppActivityWhereInput | WhatsAppActivityWhereInput[]
    OR?: WhatsAppActivityWhereInput[]
    NOT?: WhatsAppActivityWhereInput | WhatsAppActivityWhereInput[]
    id?: StringFilter<"WhatsAppActivity"> | string
    campaignId?: StringFilter<"WhatsAppActivity"> | string
    contactId?: StringFilter<"WhatsAppActivity"> | string
    type?: EnumActivityTypeFilter<"WhatsAppActivity"> | $Enums.ActivityType
    timestamp?: DateTimeFilter<"WhatsAppActivity"> | Date | string
    metadata?: StringNullableFilter<"WhatsAppActivity"> | string | null
    campaign?: XOR<WhatsAppCampaignScalarRelationFilter, WhatsAppCampaignWhereInput>
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
  }

  export type WhatsAppActivityOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrderInput | SortOrder
    campaign?: WhatsAppCampaignOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
  }

  export type WhatsAppActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WhatsAppActivityWhereInput | WhatsAppActivityWhereInput[]
    OR?: WhatsAppActivityWhereInput[]
    NOT?: WhatsAppActivityWhereInput | WhatsAppActivityWhereInput[]
    campaignId?: StringFilter<"WhatsAppActivity"> | string
    contactId?: StringFilter<"WhatsAppActivity"> | string
    type?: EnumActivityTypeFilter<"WhatsAppActivity"> | $Enums.ActivityType
    timestamp?: DateTimeFilter<"WhatsAppActivity"> | Date | string
    metadata?: StringNullableFilter<"WhatsAppActivity"> | string | null
    campaign?: XOR<WhatsAppCampaignScalarRelationFilter, WhatsAppCampaignWhereInput>
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
  }, "id">

  export type WhatsAppActivityOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: WhatsAppActivityCountOrderByAggregateInput
    _max?: WhatsAppActivityMaxOrderByAggregateInput
    _min?: WhatsAppActivityMinOrderByAggregateInput
  }

  export type WhatsAppActivityScalarWhereWithAggregatesInput = {
    AND?: WhatsAppActivityScalarWhereWithAggregatesInput | WhatsAppActivityScalarWhereWithAggregatesInput[]
    OR?: WhatsAppActivityScalarWhereWithAggregatesInput[]
    NOT?: WhatsAppActivityScalarWhereWithAggregatesInput | WhatsAppActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhatsAppActivity"> | string
    campaignId?: StringWithAggregatesFilter<"WhatsAppActivity"> | string
    contactId?: StringWithAggregatesFilter<"WhatsAppActivity"> | string
    type?: EnumActivityTypeWithAggregatesFilter<"WhatsAppActivity"> | $Enums.ActivityType
    timestamp?: DateTimeWithAggregatesFilter<"WhatsAppActivity"> | Date | string
    metadata?: StringNullableWithAggregatesFilter<"WhatsAppActivity"> | string | null
  }

  export type WorkflowWhereInput = {
    AND?: WorkflowWhereInput | WorkflowWhereInput[]
    OR?: WorkflowWhereInput[]
    NOT?: WorkflowWhereInput | WorkflowWhereInput[]
    id?: StringFilter<"Workflow"> | string
    name?: StringFilter<"Workflow"> | string
    description?: StringNullableFilter<"Workflow"> | string | null
    status?: EnumWorkflowStatusFilter<"Workflow"> | $Enums.WorkflowStatus
    definition?: StringFilter<"Workflow"> | string
    createdAt?: DateTimeFilter<"Workflow"> | Date | string
    updatedAt?: DateTimeFilter<"Workflow"> | Date | string
    createdById?: StringFilter<"Workflow"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    nodes?: WorkflowNodeListRelationFilter
    triggers?: WorkflowTriggerListRelationFilter
  }

  export type WorkflowOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    definition?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    nodes?: WorkflowNodeOrderByRelationAggregateInput
    triggers?: WorkflowTriggerOrderByRelationAggregateInput
  }

  export type WorkflowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowWhereInput | WorkflowWhereInput[]
    OR?: WorkflowWhereInput[]
    NOT?: WorkflowWhereInput | WorkflowWhereInput[]
    name?: StringFilter<"Workflow"> | string
    description?: StringNullableFilter<"Workflow"> | string | null
    status?: EnumWorkflowStatusFilter<"Workflow"> | $Enums.WorkflowStatus
    definition?: StringFilter<"Workflow"> | string
    createdAt?: DateTimeFilter<"Workflow"> | Date | string
    updatedAt?: DateTimeFilter<"Workflow"> | Date | string
    createdById?: StringFilter<"Workflow"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    nodes?: WorkflowNodeListRelationFilter
    triggers?: WorkflowTriggerListRelationFilter
  }, "id">

  export type WorkflowOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    definition?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: WorkflowCountOrderByAggregateInput
    _max?: WorkflowMaxOrderByAggregateInput
    _min?: WorkflowMinOrderByAggregateInput
  }

  export type WorkflowScalarWhereWithAggregatesInput = {
    AND?: WorkflowScalarWhereWithAggregatesInput | WorkflowScalarWhereWithAggregatesInput[]
    OR?: WorkflowScalarWhereWithAggregatesInput[]
    NOT?: WorkflowScalarWhereWithAggregatesInput | WorkflowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Workflow"> | string
    name?: StringWithAggregatesFilter<"Workflow"> | string
    description?: StringNullableWithAggregatesFilter<"Workflow"> | string | null
    status?: EnumWorkflowStatusWithAggregatesFilter<"Workflow"> | $Enums.WorkflowStatus
    definition?: StringWithAggregatesFilter<"Workflow"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Workflow"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Workflow"> | Date | string
    createdById?: StringWithAggregatesFilter<"Workflow"> | string
  }

  export type WorkflowNodeWhereInput = {
    AND?: WorkflowNodeWhereInput | WorkflowNodeWhereInput[]
    OR?: WorkflowNodeWhereInput[]
    NOT?: WorkflowNodeWhereInput | WorkflowNodeWhereInput[]
    id?: StringFilter<"WorkflowNode"> | string
    workflowId?: StringFilter<"WorkflowNode"> | string
    type?: EnumWorkflowNodeTypeFilter<"WorkflowNode"> | $Enums.WorkflowNodeType
    name?: StringNullableFilter<"WorkflowNode"> | string | null
    config?: StringFilter<"WorkflowNode"> | string
    positionX?: FloatNullableFilter<"WorkflowNode"> | number | null
    positionY?: FloatNullableFilter<"WorkflowNode"> | number | null
    workflow?: XOR<WorkflowScalarRelationFilter, WorkflowWhereInput>
    outgoing?: ConnectionListRelationFilter
    incoming?: ConnectionListRelationFilter
  }

  export type WorkflowNodeOrderByWithRelationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    type?: SortOrder
    name?: SortOrderInput | SortOrder
    config?: SortOrder
    positionX?: SortOrderInput | SortOrder
    positionY?: SortOrderInput | SortOrder
    workflow?: WorkflowOrderByWithRelationInput
    outgoing?: ConnectionOrderByRelationAggregateInput
    incoming?: ConnectionOrderByRelationAggregateInput
  }

  export type WorkflowNodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowNodeWhereInput | WorkflowNodeWhereInput[]
    OR?: WorkflowNodeWhereInput[]
    NOT?: WorkflowNodeWhereInput | WorkflowNodeWhereInput[]
    workflowId?: StringFilter<"WorkflowNode"> | string
    type?: EnumWorkflowNodeTypeFilter<"WorkflowNode"> | $Enums.WorkflowNodeType
    name?: StringNullableFilter<"WorkflowNode"> | string | null
    config?: StringFilter<"WorkflowNode"> | string
    positionX?: FloatNullableFilter<"WorkflowNode"> | number | null
    positionY?: FloatNullableFilter<"WorkflowNode"> | number | null
    workflow?: XOR<WorkflowScalarRelationFilter, WorkflowWhereInput>
    outgoing?: ConnectionListRelationFilter
    incoming?: ConnectionListRelationFilter
  }, "id">

  export type WorkflowNodeOrderByWithAggregationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    type?: SortOrder
    name?: SortOrderInput | SortOrder
    config?: SortOrder
    positionX?: SortOrderInput | SortOrder
    positionY?: SortOrderInput | SortOrder
    _count?: WorkflowNodeCountOrderByAggregateInput
    _avg?: WorkflowNodeAvgOrderByAggregateInput
    _max?: WorkflowNodeMaxOrderByAggregateInput
    _min?: WorkflowNodeMinOrderByAggregateInput
    _sum?: WorkflowNodeSumOrderByAggregateInput
  }

  export type WorkflowNodeScalarWhereWithAggregatesInput = {
    AND?: WorkflowNodeScalarWhereWithAggregatesInput | WorkflowNodeScalarWhereWithAggregatesInput[]
    OR?: WorkflowNodeScalarWhereWithAggregatesInput[]
    NOT?: WorkflowNodeScalarWhereWithAggregatesInput | WorkflowNodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkflowNode"> | string
    workflowId?: StringWithAggregatesFilter<"WorkflowNode"> | string
    type?: EnumWorkflowNodeTypeWithAggregatesFilter<"WorkflowNode"> | $Enums.WorkflowNodeType
    name?: StringNullableWithAggregatesFilter<"WorkflowNode"> | string | null
    config?: StringWithAggregatesFilter<"WorkflowNode"> | string
    positionX?: FloatNullableWithAggregatesFilter<"WorkflowNode"> | number | null
    positionY?: FloatNullableWithAggregatesFilter<"WorkflowNode"> | number | null
  }

  export type ConnectionWhereInput = {
    AND?: ConnectionWhereInput | ConnectionWhereInput[]
    OR?: ConnectionWhereInput[]
    NOT?: ConnectionWhereInput | ConnectionWhereInput[]
    id?: StringFilter<"Connection"> | string
    sourceId?: StringFilter<"Connection"> | string
    targetId?: StringFilter<"Connection"> | string
    condition?: StringNullableFilter<"Connection"> | string | null
    source?: XOR<WorkflowNodeScalarRelationFilter, WorkflowNodeWhereInput>
    target?: XOR<WorkflowNodeScalarRelationFilter, WorkflowNodeWhereInput>
  }

  export type ConnectionOrderByWithRelationInput = {
    id?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    condition?: SortOrderInput | SortOrder
    source?: WorkflowNodeOrderByWithRelationInput
    target?: WorkflowNodeOrderByWithRelationInput
  }

  export type ConnectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sourceId_targetId?: ConnectionSourceIdTargetIdCompoundUniqueInput
    AND?: ConnectionWhereInput | ConnectionWhereInput[]
    OR?: ConnectionWhereInput[]
    NOT?: ConnectionWhereInput | ConnectionWhereInput[]
    sourceId?: StringFilter<"Connection"> | string
    targetId?: StringFilter<"Connection"> | string
    condition?: StringNullableFilter<"Connection"> | string | null
    source?: XOR<WorkflowNodeScalarRelationFilter, WorkflowNodeWhereInput>
    target?: XOR<WorkflowNodeScalarRelationFilter, WorkflowNodeWhereInput>
  }, "id" | "sourceId_targetId">

  export type ConnectionOrderByWithAggregationInput = {
    id?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    condition?: SortOrderInput | SortOrder
    _count?: ConnectionCountOrderByAggregateInput
    _max?: ConnectionMaxOrderByAggregateInput
    _min?: ConnectionMinOrderByAggregateInput
  }

  export type ConnectionScalarWhereWithAggregatesInput = {
    AND?: ConnectionScalarWhereWithAggregatesInput | ConnectionScalarWhereWithAggregatesInput[]
    OR?: ConnectionScalarWhereWithAggregatesInput[]
    NOT?: ConnectionScalarWhereWithAggregatesInput | ConnectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Connection"> | string
    sourceId?: StringWithAggregatesFilter<"Connection"> | string
    targetId?: StringWithAggregatesFilter<"Connection"> | string
    condition?: StringNullableWithAggregatesFilter<"Connection"> | string | null
  }

  export type WorkflowTriggerWhereInput = {
    AND?: WorkflowTriggerWhereInput | WorkflowTriggerWhereInput[]
    OR?: WorkflowTriggerWhereInput[]
    NOT?: WorkflowTriggerWhereInput | WorkflowTriggerWhereInput[]
    id?: StringFilter<"WorkflowTrigger"> | string
    workflowId?: StringFilter<"WorkflowTrigger"> | string
    type?: EnumTriggerTypeFilter<"WorkflowTrigger"> | $Enums.TriggerType
    config?: StringFilter<"WorkflowTrigger"> | string
    workflow?: XOR<WorkflowScalarRelationFilter, WorkflowWhereInput>
  }

  export type WorkflowTriggerOrderByWithRelationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    type?: SortOrder
    config?: SortOrder
    workflow?: WorkflowOrderByWithRelationInput
  }

  export type WorkflowTriggerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowTriggerWhereInput | WorkflowTriggerWhereInput[]
    OR?: WorkflowTriggerWhereInput[]
    NOT?: WorkflowTriggerWhereInput | WorkflowTriggerWhereInput[]
    workflowId?: StringFilter<"WorkflowTrigger"> | string
    type?: EnumTriggerTypeFilter<"WorkflowTrigger"> | $Enums.TriggerType
    config?: StringFilter<"WorkflowTrigger"> | string
    workflow?: XOR<WorkflowScalarRelationFilter, WorkflowWhereInput>
  }, "id">

  export type WorkflowTriggerOrderByWithAggregationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    type?: SortOrder
    config?: SortOrder
    _count?: WorkflowTriggerCountOrderByAggregateInput
    _max?: WorkflowTriggerMaxOrderByAggregateInput
    _min?: WorkflowTriggerMinOrderByAggregateInput
  }

  export type WorkflowTriggerScalarWhereWithAggregatesInput = {
    AND?: WorkflowTriggerScalarWhereWithAggregatesInput | WorkflowTriggerScalarWhereWithAggregatesInput[]
    OR?: WorkflowTriggerScalarWhereWithAggregatesInput[]
    NOT?: WorkflowTriggerScalarWhereWithAggregatesInput | WorkflowTriggerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkflowTrigger"> | string
    workflowId?: StringWithAggregatesFilter<"WorkflowTrigger"> | string
    type?: EnumTriggerTypeWithAggregatesFilter<"WorkflowTrigger"> | $Enums.TriggerType
    config?: StringWithAggregatesFilter<"WorkflowTrigger"> | string
  }

  export type AnalyticsWhereInput = {
    AND?: AnalyticsWhereInput | AnalyticsWhereInput[]
    OR?: AnalyticsWhereInput[]
    NOT?: AnalyticsWhereInput | AnalyticsWhereInput[]
    id?: StringFilter<"Analytics"> | string
    entityType?: EnumEntityTypeFilter<"Analytics"> | $Enums.EntityType
    entityId?: StringFilter<"Analytics"> | string
    period?: EnumAnalyticsPeriodFilter<"Analytics"> | $Enums.AnalyticsPeriod
    metrics?: StringFilter<"Analytics"> | string
    createdAt?: DateTimeFilter<"Analytics"> | Date | string
    updatedAt?: DateTimeFilter<"Analytics"> | Date | string
  }

  export type AnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    period?: SortOrder
    metrics?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    entityType_entityId_period?: AnalyticsEntityTypeEntityIdPeriodCompoundUniqueInput
    AND?: AnalyticsWhereInput | AnalyticsWhereInput[]
    OR?: AnalyticsWhereInput[]
    NOT?: AnalyticsWhereInput | AnalyticsWhereInput[]
    entityType?: EnumEntityTypeFilter<"Analytics"> | $Enums.EntityType
    entityId?: StringFilter<"Analytics"> | string
    period?: EnumAnalyticsPeriodFilter<"Analytics"> | $Enums.AnalyticsPeriod
    metrics?: StringFilter<"Analytics"> | string
    createdAt?: DateTimeFilter<"Analytics"> | Date | string
    updatedAt?: DateTimeFilter<"Analytics"> | Date | string
  }, "id" | "entityType_entityId_period">

  export type AnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    period?: SortOrder
    metrics?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnalyticsCountOrderByAggregateInput
    _max?: AnalyticsMaxOrderByAggregateInput
    _min?: AnalyticsMinOrderByAggregateInput
  }

  export type AnalyticsScalarWhereWithAggregatesInput = {
    AND?: AnalyticsScalarWhereWithAggregatesInput | AnalyticsScalarWhereWithAggregatesInput[]
    OR?: AnalyticsScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsScalarWhereWithAggregatesInput | AnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Analytics"> | string
    entityType?: EnumEntityTypeWithAggregatesFilter<"Analytics"> | $Enums.EntityType
    entityId?: StringWithAggregatesFilter<"Analytics"> | string
    period?: EnumAnalyticsPeriodWithAggregatesFilter<"Analytics"> | $Enums.AnalyticsPeriod
    metrics?: StringWithAggregatesFilter<"Analytics"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Analytics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Analytics"> | Date | string
  }

  export type IntegrationConnectionWhereInput = {
    AND?: IntegrationConnectionWhereInput | IntegrationConnectionWhereInput[]
    OR?: IntegrationConnectionWhereInput[]
    NOT?: IntegrationConnectionWhereInput | IntegrationConnectionWhereInput[]
    id?: StringFilter<"IntegrationConnection"> | string
    name?: StringFilter<"IntegrationConnection"> | string
    type?: EnumIntegrationTypeFilter<"IntegrationConnection"> | $Enums.IntegrationType
    config?: StringFilter<"IntegrationConnection"> | string
    status?: EnumConnectionStatusFilter<"IntegrationConnection"> | $Enums.ConnectionStatus
    createdAt?: DateTimeFilter<"IntegrationConnection"> | Date | string
    updatedAt?: DateTimeFilter<"IntegrationConnection"> | Date | string
  }

  export type IntegrationConnectionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    config?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationConnectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IntegrationConnectionWhereInput | IntegrationConnectionWhereInput[]
    OR?: IntegrationConnectionWhereInput[]
    NOT?: IntegrationConnectionWhereInput | IntegrationConnectionWhereInput[]
    name?: StringFilter<"IntegrationConnection"> | string
    type?: EnumIntegrationTypeFilter<"IntegrationConnection"> | $Enums.IntegrationType
    config?: StringFilter<"IntegrationConnection"> | string
    status?: EnumConnectionStatusFilter<"IntegrationConnection"> | $Enums.ConnectionStatus
    createdAt?: DateTimeFilter<"IntegrationConnection"> | Date | string
    updatedAt?: DateTimeFilter<"IntegrationConnection"> | Date | string
  }, "id">

  export type IntegrationConnectionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    config?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntegrationConnectionCountOrderByAggregateInput
    _max?: IntegrationConnectionMaxOrderByAggregateInput
    _min?: IntegrationConnectionMinOrderByAggregateInput
  }

  export type IntegrationConnectionScalarWhereWithAggregatesInput = {
    AND?: IntegrationConnectionScalarWhereWithAggregatesInput | IntegrationConnectionScalarWhereWithAggregatesInput[]
    OR?: IntegrationConnectionScalarWhereWithAggregatesInput[]
    NOT?: IntegrationConnectionScalarWhereWithAggregatesInput | IntegrationConnectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IntegrationConnection"> | string
    name?: StringWithAggregatesFilter<"IntegrationConnection"> | string
    type?: EnumIntegrationTypeWithAggregatesFilter<"IntegrationConnection"> | $Enums.IntegrationType
    config?: StringWithAggregatesFilter<"IntegrationConnection"> | string
    status?: EnumConnectionStatusWithAggregatesFilter<"IntegrationConnection"> | $Enums.ConnectionStatus
    createdAt?: DateTimeWithAggregatesFilter<"IntegrationConnection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IntegrationConnection"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutCreatedByInput
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutCreatedByInput
    emailTemplates?: EmailTemplateCreateNestedManyWithoutCreatedByInput
    smsCampaigns?: SMSCampaignCreateNestedManyWithoutCreatedByInput
    smsTemplates?: SMSTemplateCreateNestedManyWithoutCreatedByInput
    waCampaigns?: WhatsAppCampaignCreateNestedManyWithoutCreatedByInput
    waTemplates?: WhatsAppTemplateCreateNestedManyWithoutCreatedByInput
    workflows?: WorkflowCreateNestedManyWithoutCreatedByInput
    lists?: ListCreateNestedManyWithoutCreatedByInput
    segments?: SegmentCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCreatedByInput
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    emailTemplates?: EmailTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    smsCampaigns?: SMSCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    smsTemplates?: SMSTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    waCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    waTemplates?: WhatsAppTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutCreatedByInput
    lists?: ListUncheckedCreateNestedManyWithoutCreatedByInput
    segments?: SegmentUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutCreatedByNestedInput
    emailCampaigns?: EmailCampaignUpdateManyWithoutCreatedByNestedInput
    emailTemplates?: EmailTemplateUpdateManyWithoutCreatedByNestedInput
    smsCampaigns?: SMSCampaignUpdateManyWithoutCreatedByNestedInput
    smsTemplates?: SMSTemplateUpdateManyWithoutCreatedByNestedInput
    waCampaigns?: WhatsAppCampaignUpdateManyWithoutCreatedByNestedInput
    waTemplates?: WhatsAppTemplateUpdateManyWithoutCreatedByNestedInput
    workflows?: WorkflowUpdateManyWithoutCreatedByNestedInput
    lists?: ListUpdateManyWithoutCreatedByNestedInput
    segments?: SegmentUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCreatedByNestedInput
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    emailTemplates?: EmailTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    smsCampaigns?: SMSCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    smsTemplates?: SMSTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    waCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    waTemplates?: WhatsAppTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput
    lists?: ListUncheckedUpdateManyWithoutCreatedByNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    jobTitle?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    notes?: string | null
    tagsString?: string | null
    source?: string | null
    status?: $Enums.ContactStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutContactsInput
    listMembers?: ListMemberCreateNestedManyWithoutContactInput
    emailActivities?: EmailActivityCreateNestedManyWithoutContactInput
    smsActivities?: SMSActivityCreateNestedManyWithoutContactInput
    waActivities?: WhatsAppActivityCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    jobTitle?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    notes?: string | null
    tagsString?: string | null
    source?: string | null
    status?: $Enums.ContactStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    listMembers?: ListMemberUncheckedCreateNestedManyWithoutContactInput
    emailActivities?: EmailActivityUncheckedCreateNestedManyWithoutContactInput
    smsActivities?: SMSActivityUncheckedCreateNestedManyWithoutContactInput
    waActivities?: WhatsAppActivityUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tagsString?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutContactsNestedInput
    listMembers?: ListMemberUpdateManyWithoutContactNestedInput
    emailActivities?: EmailActivityUpdateManyWithoutContactNestedInput
    smsActivities?: SMSActivityUpdateManyWithoutContactNestedInput
    waActivities?: WhatsAppActivityUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tagsString?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    listMembers?: ListMemberUncheckedUpdateManyWithoutContactNestedInput
    emailActivities?: EmailActivityUncheckedUpdateManyWithoutContactNestedInput
    smsActivities?: SMSActivityUncheckedUpdateManyWithoutContactNestedInput
    waActivities?: WhatsAppActivityUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateManyInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    jobTitle?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    notes?: string | null
    tagsString?: string | null
    source?: string | null
    status?: $Enums.ContactStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tagsString?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tagsString?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type ListCreateInput = {
    id?: string
    name: string
    description?: string | null
    type?: $Enums.ListType
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutListsInput
    members?: ListMemberCreateNestedManyWithoutListInput
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutListsInput
    smsCampaigns?: SMSCampaignCreateNestedManyWithoutListsInput
    waCampaigns?: WhatsAppCampaignCreateNestedManyWithoutListsInput
  }

  export type ListUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    type?: $Enums.ListType
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    members?: ListMemberUncheckedCreateNestedManyWithoutListInput
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutListsInput
    smsCampaigns?: SMSCampaignUncheckedCreateNestedManyWithoutListsInput
    waCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutListsInput
  }

  export type ListUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutListsNestedInput
    members?: ListMemberUpdateManyWithoutListNestedInput
    emailCampaigns?: EmailCampaignUpdateManyWithoutListsNestedInput
    smsCampaigns?: SMSCampaignUpdateManyWithoutListsNestedInput
    waCampaigns?: WhatsAppCampaignUpdateManyWithoutListsNestedInput
  }

  export type ListUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    members?: ListMemberUncheckedUpdateManyWithoutListNestedInput
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutListsNestedInput
    smsCampaigns?: SMSCampaignUncheckedUpdateManyWithoutListsNestedInput
    waCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutListsNestedInput
  }

  export type ListCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    type?: $Enums.ListType
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type ListUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type ListMemberCreateInput = {
    id?: string
    addedAt?: Date | string
    list: ListCreateNestedOneWithoutMembersInput
    contact: ContactCreateNestedOneWithoutListMembersInput
  }

  export type ListMemberUncheckedCreateInput = {
    id?: string
    listId: string
    contactId: string
    addedAt?: Date | string
  }

  export type ListMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    list?: ListUpdateOneRequiredWithoutMembersNestedInput
    contact?: ContactUpdateOneRequiredWithoutListMembersNestedInput
  }

  export type ListMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    listId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListMemberCreateManyInput = {
    id?: string
    listId: string
    contactId: string
    addedAt?: Date | string
  }

  export type ListMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    listId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SegmentCreateInput = {
    id?: string
    name: string
    description?: string | null
    rules: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutSegmentsInput
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutSegmentsInput
    smsCampaigns?: SMSCampaignCreateNestedManyWithoutSegmentsInput
    waCampaigns?: WhatsAppCampaignCreateNestedManyWithoutSegmentsInput
  }

  export type SegmentUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    rules: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutSegmentsInput
    smsCampaigns?: SMSCampaignUncheckedCreateNestedManyWithoutSegmentsInput
    waCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutSegmentsInput
  }

  export type SegmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutSegmentsNestedInput
    emailCampaigns?: EmailCampaignUpdateManyWithoutSegmentsNestedInput
    smsCampaigns?: SMSCampaignUpdateManyWithoutSegmentsNestedInput
    waCampaigns?: WhatsAppCampaignUpdateManyWithoutSegmentsNestedInput
  }

  export type SegmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutSegmentsNestedInput
    smsCampaigns?: SMSCampaignUncheckedUpdateManyWithoutSegmentsNestedInput
    waCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutSegmentsNestedInput
  }

  export type SegmentCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    rules: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type SegmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SegmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type EmailTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    subject: string
    content: string
    design?: string | null
    previewText?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutEmailTemplatesInput
    campaigns?: EmailCampaignCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    subject: string
    content: string
    design?: string | null
    previewText?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    campaigns?: EmailCampaignUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    design?: NullableStringFieldUpdateOperationsInput | string | null
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutEmailTemplatesNestedInput
    campaigns?: EmailCampaignUpdateManyWithoutTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    design?: NullableStringFieldUpdateOperationsInput | string | null
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    campaigns?: EmailCampaignUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type EmailTemplateCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    subject: string
    content: string
    design?: string | null
    previewText?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type EmailTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    design?: NullableStringFieldUpdateOperationsInput | string | null
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    design?: NullableStringFieldUpdateOperationsInput | string | null
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type EmailCampaignCreateInput = {
    id?: string
    name: string
    description?: string | null
    subject: string
    from: string
    replyTo?: string | null
    content?: string | null
    design?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutEmailCampaignsInput
    template?: EmailTemplateCreateNestedOneWithoutCampaignsInput
    lists?: ListCreateNestedManyWithoutEmailCampaignsInput
    segments?: SegmentCreateNestedManyWithoutEmailCampaignsInput
    activities?: EmailActivityCreateNestedManyWithoutCampaignInput
  }

  export type EmailCampaignUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    subject: string
    from: string
    replyTo?: string | null
    templateId?: string | null
    content?: string | null
    design?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    lists?: ListUncheckedCreateNestedManyWithoutEmailCampaignsInput
    segments?: SegmentUncheckedCreateNestedManyWithoutEmailCampaignsInput
    activities?: EmailActivityUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type EmailCampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutEmailCampaignsNestedInput
    template?: EmailTemplateUpdateOneWithoutCampaignsNestedInput
    lists?: ListUpdateManyWithoutEmailCampaignsNestedInput
    segments?: SegmentUpdateManyWithoutEmailCampaignsNestedInput
    activities?: EmailActivityUpdateManyWithoutCampaignNestedInput
  }

  export type EmailCampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    lists?: ListUncheckedUpdateManyWithoutEmailCampaignsNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutEmailCampaignsNestedInput
    activities?: EmailActivityUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type EmailCampaignCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    subject: string
    from: string
    replyTo?: string | null
    templateId?: string | null
    content?: string | null
    design?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type EmailCampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailCampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type EmailActivityCreateInput = {
    id?: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
    campaign: EmailCampaignCreateNestedOneWithoutActivitiesInput
    contact: ContactCreateNestedOneWithoutEmailActivitiesInput
  }

  export type EmailActivityUncheckedCreateInput = {
    id?: string
    campaignId: string
    contactId: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
  }

  export type EmailActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: EmailCampaignUpdateOneRequiredWithoutActivitiesNestedInput
    contact?: ContactUpdateOneRequiredWithoutEmailActivitiesNestedInput
  }

  export type EmailActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailActivityCreateManyInput = {
    id?: string
    campaignId: string
    contactId: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
  }

  export type EmailActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SMSTemplateCreateInput = {
    id?: string
    name: string
    content: string
    variables: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutSmsTemplatesInput
    campaigns?: SMSCampaignCreateNestedManyWithoutTemplateInput
  }

  export type SMSTemplateUncheckedCreateInput = {
    id?: string
    name: string
    content: string
    variables: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    campaigns?: SMSCampaignUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type SMSTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutSmsTemplatesNestedInput
    campaigns?: SMSCampaignUpdateManyWithoutTemplateNestedInput
  }

  export type SMSTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    campaigns?: SMSCampaignUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type SMSTemplateCreateManyInput = {
    id?: string
    name: string
    content: string
    variables: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type SMSTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SMSTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type SMSCampaignCreateInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutSmsCampaignsInput
    template?: SMSTemplateCreateNestedOneWithoutCampaignsInput
    lists?: ListCreateNestedManyWithoutSmsCampaignsInput
    segments?: SegmentCreateNestedManyWithoutSmsCampaignsInput
    activities?: SMSActivityCreateNestedManyWithoutCampaignInput
  }

  export type SMSCampaignUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    templateId?: string | null
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    lists?: ListUncheckedCreateNestedManyWithoutSmsCampaignsInput
    segments?: SegmentUncheckedCreateNestedManyWithoutSmsCampaignsInput
    activities?: SMSActivityUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type SMSCampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutSmsCampaignsNestedInput
    template?: SMSTemplateUpdateOneWithoutCampaignsNestedInput
    lists?: ListUpdateManyWithoutSmsCampaignsNestedInput
    segments?: SegmentUpdateManyWithoutSmsCampaignsNestedInput
    activities?: SMSActivityUpdateManyWithoutCampaignNestedInput
  }

  export type SMSCampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    lists?: ListUncheckedUpdateManyWithoutSmsCampaignsNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutSmsCampaignsNestedInput
    activities?: SMSActivityUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type SMSCampaignCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    templateId?: string | null
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type SMSCampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SMSCampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type SMSActivityCreateInput = {
    id?: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
    campaign: SMSCampaignCreateNestedOneWithoutActivitiesInput
    contact: ContactCreateNestedOneWithoutSmsActivitiesInput
  }

  export type SMSActivityUncheckedCreateInput = {
    id?: string
    campaignId: string
    contactId: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
  }

  export type SMSActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: SMSCampaignUpdateOneRequiredWithoutActivitiesNestedInput
    contact?: ContactUpdateOneRequiredWithoutSmsActivitiesNestedInput
  }

  export type SMSActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SMSActivityCreateManyInput = {
    id?: string
    campaignId: string
    contactId: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
  }

  export type SMSActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SMSActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WhatsAppTemplateCreateInput = {
    id?: string
    name: string
    content: string
    variables: string
    category?: string | null
    status?: $Enums.WATemplateStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutWaTemplatesInput
    campaigns?: WhatsAppCampaignCreateNestedManyWithoutTemplateInput
  }

  export type WhatsAppTemplateUncheckedCreateInput = {
    id?: string
    name: string
    content: string
    variables: string
    category?: string | null
    status?: $Enums.WATemplateStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    campaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type WhatsAppTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWATemplateStatusFieldUpdateOperationsInput | $Enums.WATemplateStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutWaTemplatesNestedInput
    campaigns?: WhatsAppCampaignUpdateManyWithoutTemplateNestedInput
  }

  export type WhatsAppTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWATemplateStatusFieldUpdateOperationsInput | $Enums.WATemplateStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    campaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type WhatsAppTemplateCreateManyInput = {
    id?: string
    name: string
    content: string
    variables: string
    category?: string | null
    status?: $Enums.WATemplateStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type WhatsAppTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWATemplateStatusFieldUpdateOperationsInput | $Enums.WATemplateStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWATemplateStatusFieldUpdateOperationsInput | $Enums.WATemplateStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type WhatsAppCampaignCreateInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutWaCampaignsInput
    template?: WhatsAppTemplateCreateNestedOneWithoutCampaignsInput
    lists?: ListCreateNestedManyWithoutWaCampaignsInput
    segments?: SegmentCreateNestedManyWithoutWaCampaignsInput
    activities?: WhatsAppActivityCreateNestedManyWithoutCampaignInput
  }

  export type WhatsAppCampaignUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    templateId?: string | null
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    lists?: ListUncheckedCreateNestedManyWithoutWaCampaignsInput
    segments?: SegmentUncheckedCreateNestedManyWithoutWaCampaignsInput
    activities?: WhatsAppActivityUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type WhatsAppCampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutWaCampaignsNestedInput
    template?: WhatsAppTemplateUpdateOneWithoutCampaignsNestedInput
    lists?: ListUpdateManyWithoutWaCampaignsNestedInput
    segments?: SegmentUpdateManyWithoutWaCampaignsNestedInput
    activities?: WhatsAppActivityUpdateManyWithoutCampaignNestedInput
  }

  export type WhatsAppCampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    lists?: ListUncheckedUpdateManyWithoutWaCampaignsNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutWaCampaignsNestedInput
    activities?: WhatsAppActivityUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type WhatsAppCampaignCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    templateId?: string | null
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type WhatsAppCampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppCampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type WhatsAppActivityCreateInput = {
    id?: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
    campaign: WhatsAppCampaignCreateNestedOneWithoutActivitiesInput
    contact: ContactCreateNestedOneWithoutWaActivitiesInput
  }

  export type WhatsAppActivityUncheckedCreateInput = {
    id?: string
    campaignId: string
    contactId: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
  }

  export type WhatsAppActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: WhatsAppCampaignUpdateOneRequiredWithoutActivitiesNestedInput
    contact?: ContactUpdateOneRequiredWithoutWaActivitiesNestedInput
  }

  export type WhatsAppActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WhatsAppActivityCreateManyInput = {
    id?: string
    campaignId: string
    contactId: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
  }

  export type WhatsAppActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WhatsAppActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkflowCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.WorkflowStatus
    definition: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutWorkflowsInput
    nodes?: WorkflowNodeCreateNestedManyWithoutWorkflowInput
    triggers?: WorkflowTriggerCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.WorkflowStatus
    definition: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    nodes?: WorkflowNodeUncheckedCreateNestedManyWithoutWorkflowInput
    triggers?: WorkflowTriggerUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    definition?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutWorkflowsNestedInput
    nodes?: WorkflowNodeUpdateManyWithoutWorkflowNestedInput
    triggers?: WorkflowTriggerUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    definition?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    nodes?: WorkflowNodeUncheckedUpdateManyWithoutWorkflowNestedInput
    triggers?: WorkflowTriggerUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.WorkflowStatus
    definition: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type WorkflowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    definition?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    definition?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type WorkflowNodeCreateInput = {
    id?: string
    type: $Enums.WorkflowNodeType
    name?: string | null
    config: string
    positionX?: number | null
    positionY?: number | null
    workflow: WorkflowCreateNestedOneWithoutNodesInput
    outgoing?: ConnectionCreateNestedManyWithoutSourceInput
    incoming?: ConnectionCreateNestedManyWithoutTargetInput
  }

  export type WorkflowNodeUncheckedCreateInput = {
    id?: string
    workflowId: string
    type: $Enums.WorkflowNodeType
    name?: string | null
    config: string
    positionX?: number | null
    positionY?: number | null
    outgoing?: ConnectionUncheckedCreateNestedManyWithoutSourceInput
    incoming?: ConnectionUncheckedCreateNestedManyWithoutTargetInput
  }

  export type WorkflowNodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowNodeTypeFieldUpdateOperationsInput | $Enums.WorkflowNodeType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    workflow?: WorkflowUpdateOneRequiredWithoutNodesNestedInput
    outgoing?: ConnectionUpdateManyWithoutSourceNestedInput
    incoming?: ConnectionUpdateManyWithoutTargetNestedInput
  }

  export type WorkflowNodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowNodeTypeFieldUpdateOperationsInput | $Enums.WorkflowNodeType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    outgoing?: ConnectionUncheckedUpdateManyWithoutSourceNestedInput
    incoming?: ConnectionUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type WorkflowNodeCreateManyInput = {
    id?: string
    workflowId: string
    type: $Enums.WorkflowNodeType
    name?: string | null
    config: string
    positionX?: number | null
    positionY?: number | null
  }

  export type WorkflowNodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowNodeTypeFieldUpdateOperationsInput | $Enums.WorkflowNodeType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type WorkflowNodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowNodeTypeFieldUpdateOperationsInput | $Enums.WorkflowNodeType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ConnectionCreateInput = {
    id?: string
    condition?: string | null
    source: WorkflowNodeCreateNestedOneWithoutOutgoingInput
    target: WorkflowNodeCreateNestedOneWithoutIncomingInput
  }

  export type ConnectionUncheckedCreateInput = {
    id?: string
    sourceId: string
    targetId: string
    condition?: string | null
  }

  export type ConnectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    source?: WorkflowNodeUpdateOneRequiredWithoutOutgoingNestedInput
    target?: WorkflowNodeUpdateOneRequiredWithoutIncomingNestedInput
  }

  export type ConnectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    condition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConnectionCreateManyInput = {
    id?: string
    sourceId: string
    targetId: string
    condition?: string | null
  }

  export type ConnectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    condition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConnectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    condition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkflowTriggerCreateInput = {
    id?: string
    type: $Enums.TriggerType
    config: string
    workflow: WorkflowCreateNestedOneWithoutTriggersInput
  }

  export type WorkflowTriggerUncheckedCreateInput = {
    id?: string
    workflowId: string
    type: $Enums.TriggerType
    config: string
  }

  export type WorkflowTriggerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType
    config?: StringFieldUpdateOperationsInput | string
    workflow?: WorkflowUpdateOneRequiredWithoutTriggersNestedInput
  }

  export type WorkflowTriggerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType
    config?: StringFieldUpdateOperationsInput | string
  }

  export type WorkflowTriggerCreateManyInput = {
    id?: string
    workflowId: string
    type: $Enums.TriggerType
    config: string
  }

  export type WorkflowTriggerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType
    config?: StringFieldUpdateOperationsInput | string
  }

  export type WorkflowTriggerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType
    config?: StringFieldUpdateOperationsInput | string
  }

  export type AnalyticsCreateInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    period: $Enums.AnalyticsPeriod
    metrics: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsUncheckedCreateInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    period: $Enums.AnalyticsPeriod
    metrics: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    period?: EnumAnalyticsPeriodFieldUpdateOperationsInput | $Enums.AnalyticsPeriod
    metrics?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    period?: EnumAnalyticsPeriodFieldUpdateOperationsInput | $Enums.AnalyticsPeriod
    metrics?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsCreateManyInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    period: $Enums.AnalyticsPeriod
    metrics: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    period?: EnumAnalyticsPeriodFieldUpdateOperationsInput | $Enums.AnalyticsPeriod
    metrics?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    period?: EnumAnalyticsPeriodFieldUpdateOperationsInput | $Enums.AnalyticsPeriod
    metrics?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationConnectionCreateInput = {
    id?: string
    name: string
    type: $Enums.IntegrationType
    config: string
    status?: $Enums.ConnectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationConnectionUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.IntegrationType
    config: string
    status?: $Enums.ConnectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationConnectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    config?: StringFieldUpdateOperationsInput | string
    status?: EnumConnectionStatusFieldUpdateOperationsInput | $Enums.ConnectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationConnectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    config?: StringFieldUpdateOperationsInput | string
    status?: EnumConnectionStatusFieldUpdateOperationsInput | $Enums.ConnectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationConnectionCreateManyInput = {
    id?: string
    name: string
    type: $Enums.IntegrationType
    config: string
    status?: $Enums.ConnectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationConnectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    config?: StringFieldUpdateOperationsInput | string
    status?: EnumConnectionStatusFieldUpdateOperationsInput | $Enums.ConnectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationConnectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    config?: StringFieldUpdateOperationsInput | string
    status?: EnumConnectionStatusFieldUpdateOperationsInput | $Enums.ConnectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type EmailCampaignListRelationFilter = {
    every?: EmailCampaignWhereInput
    some?: EmailCampaignWhereInput
    none?: EmailCampaignWhereInput
  }

  export type EmailTemplateListRelationFilter = {
    every?: EmailTemplateWhereInput
    some?: EmailTemplateWhereInput
    none?: EmailTemplateWhereInput
  }

  export type SMSCampaignListRelationFilter = {
    every?: SMSCampaignWhereInput
    some?: SMSCampaignWhereInput
    none?: SMSCampaignWhereInput
  }

  export type SMSTemplateListRelationFilter = {
    every?: SMSTemplateWhereInput
    some?: SMSTemplateWhereInput
    none?: SMSTemplateWhereInput
  }

  export type WhatsAppCampaignListRelationFilter = {
    every?: WhatsAppCampaignWhereInput
    some?: WhatsAppCampaignWhereInput
    none?: WhatsAppCampaignWhereInput
  }

  export type WhatsAppTemplateListRelationFilter = {
    every?: WhatsAppTemplateWhereInput
    some?: WhatsAppTemplateWhereInput
    none?: WhatsAppTemplateWhereInput
  }

  export type WorkflowListRelationFilter = {
    every?: WorkflowWhereInput
    some?: WorkflowWhereInput
    none?: WorkflowWhereInput
  }

  export type ListListRelationFilter = {
    every?: ListWhereInput
    some?: ListWhereInput
    none?: ListWhereInput
  }

  export type SegmentListRelationFilter = {
    every?: SegmentWhereInput
    some?: SegmentWhereInput
    none?: SegmentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailCampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SMSCampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SMSTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsAppCampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsAppTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SegmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
    isActive?: SortOrder
    role?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
    isActive?: SortOrder
    role?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
    isActive?: SortOrder
    role?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type EnumContactStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactStatus | EnumContactStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContactStatusFilter<$PrismaModel> | $Enums.ContactStatus
  }

  export type ListMemberListRelationFilter = {
    every?: ListMemberWhereInput
    some?: ListMemberWhereInput
    none?: ListMemberWhereInput
  }

  export type EmailActivityListRelationFilter = {
    every?: EmailActivityWhereInput
    some?: EmailActivityWhereInput
    none?: EmailActivityWhereInput
  }

  export type SMSActivityListRelationFilter = {
    every?: SMSActivityWhereInput
    some?: SMSActivityWhereInput
    none?: SMSActivityWhereInput
  }

  export type WhatsAppActivityListRelationFilter = {
    every?: WhatsAppActivityWhereInput
    some?: WhatsAppActivityWhereInput
    none?: WhatsAppActivityWhereInput
  }

  export type ListMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SMSActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsAppActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    company?: SortOrder
    jobTitle?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    notes?: SortOrder
    tagsString?: SortOrder
    source?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    company?: SortOrder
    jobTitle?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    notes?: SortOrder
    tagsString?: SortOrder
    source?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    company?: SortOrder
    jobTitle?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    notes?: SortOrder
    tagsString?: SortOrder
    source?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type EnumContactStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactStatus | EnumContactStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContactStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContactStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactStatusFilter<$PrismaModel>
    _max?: NestedEnumContactStatusFilter<$PrismaModel>
  }

  export type EnumListTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ListType | EnumListTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ListType[] | ListEnumListTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListType[] | ListEnumListTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumListTypeFilter<$PrismaModel> | $Enums.ListType
  }

  export type ListCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type ListMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type ListMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type EnumListTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListType | EnumListTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ListType[] | ListEnumListTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListType[] | ListEnumListTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumListTypeWithAggregatesFilter<$PrismaModel> | $Enums.ListType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumListTypeFilter<$PrismaModel>
    _max?: NestedEnumListTypeFilter<$PrismaModel>
  }

  export type ListScalarRelationFilter = {
    is?: ListWhereInput
    isNot?: ListWhereInput
  }

  export type ContactScalarRelationFilter = {
    is?: ContactWhereInput
    isNot?: ContactWhereInput
  }

  export type ListMemberListIdContactIdCompoundUniqueInput = {
    listId: string
    contactId: string
  }

  export type ListMemberCountOrderByAggregateInput = {
    id?: SortOrder
    listId?: SortOrder
    contactId?: SortOrder
    addedAt?: SortOrder
  }

  export type ListMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    listId?: SortOrder
    contactId?: SortOrder
    addedAt?: SortOrder
  }

  export type ListMemberMinOrderByAggregateInput = {
    id?: SortOrder
    listId?: SortOrder
    contactId?: SortOrder
    addedAt?: SortOrder
  }

  export type SegmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rules?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type SegmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rules?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type SegmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rules?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type EmailTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    design?: SortOrder
    previewText?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type EmailTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    design?: SortOrder
    previewText?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type EmailTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    design?: SortOrder
    previewText?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type EnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type EmailTemplateNullableScalarRelationFilter = {
    is?: EmailTemplateWhereInput | null
    isNot?: EmailTemplateWhereInput | null
  }

  export type EmailCampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    subject?: SortOrder
    from?: SortOrder
    replyTo?: SortOrder
    templateId?: SortOrder
    content?: SortOrder
    design?: SortOrder
    status?: SortOrder
    scheduledFor?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type EmailCampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    subject?: SortOrder
    from?: SortOrder
    replyTo?: SortOrder
    templateId?: SortOrder
    content?: SortOrder
    design?: SortOrder
    status?: SortOrder
    scheduledFor?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type EmailCampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    subject?: SortOrder
    from?: SortOrder
    replyTo?: SortOrder
    templateId?: SortOrder
    content?: SortOrder
    design?: SortOrder
    status?: SortOrder
    scheduledFor?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type EnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type EnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type EmailCampaignScalarRelationFilter = {
    is?: EmailCampaignWhereInput
    isNot?: EmailCampaignWhereInput
  }

  export type EmailActivityCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
  }

  export type EmailActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
  }

  export type EmailActivityMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
  }

  export type EnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type SMSTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    variables?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type SMSTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    variables?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type SMSTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    variables?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type SMSTemplateNullableScalarRelationFilter = {
    is?: SMSTemplateWhereInput | null
    isNot?: SMSTemplateWhereInput | null
  }

  export type SMSCampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    from?: SortOrder
    templateId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    scheduledFor?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type SMSCampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    from?: SortOrder
    templateId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    scheduledFor?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type SMSCampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    from?: SortOrder
    templateId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    scheduledFor?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type SMSCampaignScalarRelationFilter = {
    is?: SMSCampaignWhereInput
    isNot?: SMSCampaignWhereInput
  }

  export type SMSActivityCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
  }

  export type SMSActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
  }

  export type SMSActivityMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
  }

  export type EnumWATemplateStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WATemplateStatus | EnumWATemplateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WATemplateStatus[] | ListEnumWATemplateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WATemplateStatus[] | ListEnumWATemplateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWATemplateStatusFilter<$PrismaModel> | $Enums.WATemplateStatus
  }

  export type WhatsAppTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    variables?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type WhatsAppTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    variables?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type WhatsAppTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    variables?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type EnumWATemplateStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WATemplateStatus | EnumWATemplateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WATemplateStatus[] | ListEnumWATemplateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WATemplateStatus[] | ListEnumWATemplateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWATemplateStatusWithAggregatesFilter<$PrismaModel> | $Enums.WATemplateStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWATemplateStatusFilter<$PrismaModel>
    _max?: NestedEnumWATemplateStatusFilter<$PrismaModel>
  }

  export type WhatsAppTemplateNullableScalarRelationFilter = {
    is?: WhatsAppTemplateWhereInput | null
    isNot?: WhatsAppTemplateWhereInput | null
  }

  export type WhatsAppCampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    from?: SortOrder
    templateId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    scheduledFor?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type WhatsAppCampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    from?: SortOrder
    templateId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    scheduledFor?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type WhatsAppCampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    from?: SortOrder
    templateId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    scheduledFor?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type WhatsAppCampaignScalarRelationFilter = {
    is?: WhatsAppCampaignWhereInput
    isNot?: WhatsAppCampaignWhereInput
  }

  export type WhatsAppActivityCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
  }

  export type WhatsAppActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
  }

  export type WhatsAppActivityMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
  }

  export type EnumWorkflowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusFilter<$PrismaModel> | $Enums.WorkflowStatus
  }

  export type WorkflowNodeListRelationFilter = {
    every?: WorkflowNodeWhereInput
    some?: WorkflowNodeWhereInput
    none?: WorkflowNodeWhereInput
  }

  export type WorkflowTriggerListRelationFilter = {
    every?: WorkflowTriggerWhereInput
    some?: WorkflowTriggerWhereInput
    none?: WorkflowTriggerWhereInput
  }

  export type WorkflowNodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowTriggerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    definition?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type WorkflowMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    definition?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type WorkflowMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    definition?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type EnumWorkflowStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkflowStatusFilter<$PrismaModel>
  }

  export type EnumWorkflowNodeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowNodeType | EnumWorkflowNodeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowNodeType[] | ListEnumWorkflowNodeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowNodeType[] | ListEnumWorkflowNodeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowNodeTypeFilter<$PrismaModel> | $Enums.WorkflowNodeType
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type WorkflowScalarRelationFilter = {
    is?: WorkflowWhereInput
    isNot?: WorkflowWhereInput
  }

  export type ConnectionListRelationFilter = {
    every?: ConnectionWhereInput
    some?: ConnectionWhereInput
    none?: ConnectionWhereInput
  }

  export type ConnectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowNodeCountOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    config?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
  }

  export type WorkflowNodeAvgOrderByAggregateInput = {
    positionX?: SortOrder
    positionY?: SortOrder
  }

  export type WorkflowNodeMaxOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    config?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
  }

  export type WorkflowNodeMinOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    config?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
  }

  export type WorkflowNodeSumOrderByAggregateInput = {
    positionX?: SortOrder
    positionY?: SortOrder
  }

  export type EnumWorkflowNodeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowNodeType | EnumWorkflowNodeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowNodeType[] | ListEnumWorkflowNodeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowNodeType[] | ListEnumWorkflowNodeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowNodeTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowNodeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowNodeTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkflowNodeTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type WorkflowNodeScalarRelationFilter = {
    is?: WorkflowNodeWhereInput
    isNot?: WorkflowNodeWhereInput
  }

  export type ConnectionSourceIdTargetIdCompoundUniqueInput = {
    sourceId: string
    targetId: string
  }

  export type ConnectionCountOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    condition?: SortOrder
  }

  export type ConnectionMaxOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    condition?: SortOrder
  }

  export type ConnectionMinOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    condition?: SortOrder
  }

  export type EnumTriggerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerType | EnumTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TriggerType[] | ListEnumTriggerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TriggerType[] | ListEnumTriggerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTriggerTypeFilter<$PrismaModel> | $Enums.TriggerType
  }

  export type WorkflowTriggerCountOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    type?: SortOrder
    config?: SortOrder
  }

  export type WorkflowTriggerMaxOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    type?: SortOrder
    config?: SortOrder
  }

  export type WorkflowTriggerMinOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    type?: SortOrder
    config?: SortOrder
  }

  export type EnumTriggerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerType | EnumTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TriggerType[] | ListEnumTriggerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TriggerType[] | ListEnumTriggerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTriggerTypeWithAggregatesFilter<$PrismaModel> | $Enums.TriggerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTriggerTypeFilter<$PrismaModel>
    _max?: NestedEnumTriggerTypeFilter<$PrismaModel>
  }

  export type EnumEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEntityTypeFilter<$PrismaModel> | $Enums.EntityType
  }

  export type EnumAnalyticsPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalyticsPeriod | EnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.AnalyticsPeriod[] | ListEnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalyticsPeriod[] | ListEnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalyticsPeriodFilter<$PrismaModel> | $Enums.AnalyticsPeriod
  }

  export type AnalyticsEntityTypeEntityIdPeriodCompoundUniqueInput = {
    entityType: $Enums.EntityType
    entityId: string
    period: $Enums.AnalyticsPeriod
  }

  export type AnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    period?: SortOrder
    metrics?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    period?: SortOrder
    metrics?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    period?: SortOrder
    metrics?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.EntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumEntityTypeFilter<$PrismaModel>
  }

  export type EnumAnalyticsPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalyticsPeriod | EnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.AnalyticsPeriod[] | ListEnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalyticsPeriod[] | ListEnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalyticsPeriodWithAggregatesFilter<$PrismaModel> | $Enums.AnalyticsPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnalyticsPeriodFilter<$PrismaModel>
    _max?: NestedEnumAnalyticsPeriodFilter<$PrismaModel>
  }

  export type EnumIntegrationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationType | EnumIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationTypeFilter<$PrismaModel> | $Enums.IntegrationType
  }

  export type EnumConnectionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConnectionStatus | EnumConnectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConnectionStatus[] | ListEnumConnectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConnectionStatus[] | ListEnumConnectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConnectionStatusFilter<$PrismaModel> | $Enums.ConnectionStatus
  }

  export type IntegrationConnectionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    config?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationConnectionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    config?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationConnectionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    config?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumIntegrationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationType | EnumIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationTypeWithAggregatesFilter<$PrismaModel> | $Enums.IntegrationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIntegrationTypeFilter<$PrismaModel>
    _max?: NestedEnumIntegrationTypeFilter<$PrismaModel>
  }

  export type EnumConnectionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConnectionStatus | EnumConnectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConnectionStatus[] | ListEnumConnectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConnectionStatus[] | ListEnumConnectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConnectionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConnectionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConnectionStatusFilter<$PrismaModel>
    _max?: NestedEnumConnectionStatusFilter<$PrismaModel>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ContactCreateWithoutCreatedByInput, ContactUncheckedCreateWithoutCreatedByInput> | ContactCreateWithoutCreatedByInput[] | ContactUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCreatedByInput | ContactCreateOrConnectWithoutCreatedByInput[]
    createMany?: ContactCreateManyCreatedByInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type EmailCampaignCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<EmailCampaignCreateWithoutCreatedByInput, EmailCampaignUncheckedCreateWithoutCreatedByInput> | EmailCampaignCreateWithoutCreatedByInput[] | EmailCampaignUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutCreatedByInput | EmailCampaignCreateOrConnectWithoutCreatedByInput[]
    createMany?: EmailCampaignCreateManyCreatedByInputEnvelope
    connect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
  }

  export type EmailTemplateCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<EmailTemplateCreateWithoutCreatedByInput, EmailTemplateUncheckedCreateWithoutCreatedByInput> | EmailTemplateCreateWithoutCreatedByInput[] | EmailTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutCreatedByInput | EmailTemplateCreateOrConnectWithoutCreatedByInput[]
    createMany?: EmailTemplateCreateManyCreatedByInputEnvelope
    connect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
  }

  export type SMSCampaignCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SMSCampaignCreateWithoutCreatedByInput, SMSCampaignUncheckedCreateWithoutCreatedByInput> | SMSCampaignCreateWithoutCreatedByInput[] | SMSCampaignUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SMSCampaignCreateOrConnectWithoutCreatedByInput | SMSCampaignCreateOrConnectWithoutCreatedByInput[]
    createMany?: SMSCampaignCreateManyCreatedByInputEnvelope
    connect?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
  }

  export type SMSTemplateCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SMSTemplateCreateWithoutCreatedByInput, SMSTemplateUncheckedCreateWithoutCreatedByInput> | SMSTemplateCreateWithoutCreatedByInput[] | SMSTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SMSTemplateCreateOrConnectWithoutCreatedByInput | SMSTemplateCreateOrConnectWithoutCreatedByInput[]
    createMany?: SMSTemplateCreateManyCreatedByInputEnvelope
    connect?: SMSTemplateWhereUniqueInput | SMSTemplateWhereUniqueInput[]
  }

  export type WhatsAppCampaignCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<WhatsAppCampaignCreateWithoutCreatedByInput, WhatsAppCampaignUncheckedCreateWithoutCreatedByInput> | WhatsAppCampaignCreateWithoutCreatedByInput[] | WhatsAppCampaignUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WhatsAppCampaignCreateOrConnectWithoutCreatedByInput | WhatsAppCampaignCreateOrConnectWithoutCreatedByInput[]
    createMany?: WhatsAppCampaignCreateManyCreatedByInputEnvelope
    connect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
  }

  export type WhatsAppTemplateCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<WhatsAppTemplateCreateWithoutCreatedByInput, WhatsAppTemplateUncheckedCreateWithoutCreatedByInput> | WhatsAppTemplateCreateWithoutCreatedByInput[] | WhatsAppTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WhatsAppTemplateCreateOrConnectWithoutCreatedByInput | WhatsAppTemplateCreateOrConnectWithoutCreatedByInput[]
    createMany?: WhatsAppTemplateCreateManyCreatedByInputEnvelope
    connect?: WhatsAppTemplateWhereUniqueInput | WhatsAppTemplateWhereUniqueInput[]
  }

  export type WorkflowCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<WorkflowCreateWithoutCreatedByInput, WorkflowUncheckedCreateWithoutCreatedByInput> | WorkflowCreateWithoutCreatedByInput[] | WorkflowUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutCreatedByInput | WorkflowCreateOrConnectWithoutCreatedByInput[]
    createMany?: WorkflowCreateManyCreatedByInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type ListCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ListCreateWithoutCreatedByInput, ListUncheckedCreateWithoutCreatedByInput> | ListCreateWithoutCreatedByInput[] | ListUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ListCreateOrConnectWithoutCreatedByInput | ListCreateOrConnectWithoutCreatedByInput[]
    createMany?: ListCreateManyCreatedByInputEnvelope
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
  }

  export type SegmentCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SegmentCreateWithoutCreatedByInput, SegmentUncheckedCreateWithoutCreatedByInput> | SegmentCreateWithoutCreatedByInput[] | SegmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SegmentCreateOrConnectWithoutCreatedByInput | SegmentCreateOrConnectWithoutCreatedByInput[]
    createMany?: SegmentCreateManyCreatedByInputEnvelope
    connect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ContactCreateWithoutCreatedByInput, ContactUncheckedCreateWithoutCreatedByInput> | ContactCreateWithoutCreatedByInput[] | ContactUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCreatedByInput | ContactCreateOrConnectWithoutCreatedByInput[]
    createMany?: ContactCreateManyCreatedByInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type EmailCampaignUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<EmailCampaignCreateWithoutCreatedByInput, EmailCampaignUncheckedCreateWithoutCreatedByInput> | EmailCampaignCreateWithoutCreatedByInput[] | EmailCampaignUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutCreatedByInput | EmailCampaignCreateOrConnectWithoutCreatedByInput[]
    createMany?: EmailCampaignCreateManyCreatedByInputEnvelope
    connect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
  }

  export type EmailTemplateUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<EmailTemplateCreateWithoutCreatedByInput, EmailTemplateUncheckedCreateWithoutCreatedByInput> | EmailTemplateCreateWithoutCreatedByInput[] | EmailTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutCreatedByInput | EmailTemplateCreateOrConnectWithoutCreatedByInput[]
    createMany?: EmailTemplateCreateManyCreatedByInputEnvelope
    connect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
  }

  export type SMSCampaignUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SMSCampaignCreateWithoutCreatedByInput, SMSCampaignUncheckedCreateWithoutCreatedByInput> | SMSCampaignCreateWithoutCreatedByInput[] | SMSCampaignUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SMSCampaignCreateOrConnectWithoutCreatedByInput | SMSCampaignCreateOrConnectWithoutCreatedByInput[]
    createMany?: SMSCampaignCreateManyCreatedByInputEnvelope
    connect?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
  }

  export type SMSTemplateUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SMSTemplateCreateWithoutCreatedByInput, SMSTemplateUncheckedCreateWithoutCreatedByInput> | SMSTemplateCreateWithoutCreatedByInput[] | SMSTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SMSTemplateCreateOrConnectWithoutCreatedByInput | SMSTemplateCreateOrConnectWithoutCreatedByInput[]
    createMany?: SMSTemplateCreateManyCreatedByInputEnvelope
    connect?: SMSTemplateWhereUniqueInput | SMSTemplateWhereUniqueInput[]
  }

  export type WhatsAppCampaignUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<WhatsAppCampaignCreateWithoutCreatedByInput, WhatsAppCampaignUncheckedCreateWithoutCreatedByInput> | WhatsAppCampaignCreateWithoutCreatedByInput[] | WhatsAppCampaignUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WhatsAppCampaignCreateOrConnectWithoutCreatedByInput | WhatsAppCampaignCreateOrConnectWithoutCreatedByInput[]
    createMany?: WhatsAppCampaignCreateManyCreatedByInputEnvelope
    connect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
  }

  export type WhatsAppTemplateUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<WhatsAppTemplateCreateWithoutCreatedByInput, WhatsAppTemplateUncheckedCreateWithoutCreatedByInput> | WhatsAppTemplateCreateWithoutCreatedByInput[] | WhatsAppTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WhatsAppTemplateCreateOrConnectWithoutCreatedByInput | WhatsAppTemplateCreateOrConnectWithoutCreatedByInput[]
    createMany?: WhatsAppTemplateCreateManyCreatedByInputEnvelope
    connect?: WhatsAppTemplateWhereUniqueInput | WhatsAppTemplateWhereUniqueInput[]
  }

  export type WorkflowUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<WorkflowCreateWithoutCreatedByInput, WorkflowUncheckedCreateWithoutCreatedByInput> | WorkflowCreateWithoutCreatedByInput[] | WorkflowUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutCreatedByInput | WorkflowCreateOrConnectWithoutCreatedByInput[]
    createMany?: WorkflowCreateManyCreatedByInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type ListUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ListCreateWithoutCreatedByInput, ListUncheckedCreateWithoutCreatedByInput> | ListCreateWithoutCreatedByInput[] | ListUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ListCreateOrConnectWithoutCreatedByInput | ListCreateOrConnectWithoutCreatedByInput[]
    createMany?: ListCreateManyCreatedByInputEnvelope
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
  }

  export type SegmentUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SegmentCreateWithoutCreatedByInput, SegmentUncheckedCreateWithoutCreatedByInput> | SegmentCreateWithoutCreatedByInput[] | SegmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SegmentCreateOrConnectWithoutCreatedByInput | SegmentCreateOrConnectWithoutCreatedByInput[]
    createMany?: SegmentCreateManyCreatedByInputEnvelope
    connect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ContactCreateWithoutCreatedByInput, ContactUncheckedCreateWithoutCreatedByInput> | ContactCreateWithoutCreatedByInput[] | ContactUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCreatedByInput | ContactCreateOrConnectWithoutCreatedByInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutCreatedByInput | ContactUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ContactCreateManyCreatedByInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutCreatedByInput | ContactUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutCreatedByInput | ContactUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type EmailCampaignUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<EmailCampaignCreateWithoutCreatedByInput, EmailCampaignUncheckedCreateWithoutCreatedByInput> | EmailCampaignCreateWithoutCreatedByInput[] | EmailCampaignUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutCreatedByInput | EmailCampaignCreateOrConnectWithoutCreatedByInput[]
    upsert?: EmailCampaignUpsertWithWhereUniqueWithoutCreatedByInput | EmailCampaignUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: EmailCampaignCreateManyCreatedByInputEnvelope
    set?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    disconnect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    delete?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    connect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    update?: EmailCampaignUpdateWithWhereUniqueWithoutCreatedByInput | EmailCampaignUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: EmailCampaignUpdateManyWithWhereWithoutCreatedByInput | EmailCampaignUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: EmailCampaignScalarWhereInput | EmailCampaignScalarWhereInput[]
  }

  export type EmailTemplateUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutCreatedByInput, EmailTemplateUncheckedCreateWithoutCreatedByInput> | EmailTemplateCreateWithoutCreatedByInput[] | EmailTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutCreatedByInput | EmailTemplateCreateOrConnectWithoutCreatedByInput[]
    upsert?: EmailTemplateUpsertWithWhereUniqueWithoutCreatedByInput | EmailTemplateUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: EmailTemplateCreateManyCreatedByInputEnvelope
    set?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    disconnect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    delete?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    connect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    update?: EmailTemplateUpdateWithWhereUniqueWithoutCreatedByInput | EmailTemplateUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: EmailTemplateUpdateManyWithWhereWithoutCreatedByInput | EmailTemplateUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: EmailTemplateScalarWhereInput | EmailTemplateScalarWhereInput[]
  }

  export type SMSCampaignUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SMSCampaignCreateWithoutCreatedByInput, SMSCampaignUncheckedCreateWithoutCreatedByInput> | SMSCampaignCreateWithoutCreatedByInput[] | SMSCampaignUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SMSCampaignCreateOrConnectWithoutCreatedByInput | SMSCampaignCreateOrConnectWithoutCreatedByInput[]
    upsert?: SMSCampaignUpsertWithWhereUniqueWithoutCreatedByInput | SMSCampaignUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SMSCampaignCreateManyCreatedByInputEnvelope
    set?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    disconnect?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    delete?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    connect?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    update?: SMSCampaignUpdateWithWhereUniqueWithoutCreatedByInput | SMSCampaignUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SMSCampaignUpdateManyWithWhereWithoutCreatedByInput | SMSCampaignUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SMSCampaignScalarWhereInput | SMSCampaignScalarWhereInput[]
  }

  export type SMSTemplateUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SMSTemplateCreateWithoutCreatedByInput, SMSTemplateUncheckedCreateWithoutCreatedByInput> | SMSTemplateCreateWithoutCreatedByInput[] | SMSTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SMSTemplateCreateOrConnectWithoutCreatedByInput | SMSTemplateCreateOrConnectWithoutCreatedByInput[]
    upsert?: SMSTemplateUpsertWithWhereUniqueWithoutCreatedByInput | SMSTemplateUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SMSTemplateCreateManyCreatedByInputEnvelope
    set?: SMSTemplateWhereUniqueInput | SMSTemplateWhereUniqueInput[]
    disconnect?: SMSTemplateWhereUniqueInput | SMSTemplateWhereUniqueInput[]
    delete?: SMSTemplateWhereUniqueInput | SMSTemplateWhereUniqueInput[]
    connect?: SMSTemplateWhereUniqueInput | SMSTemplateWhereUniqueInput[]
    update?: SMSTemplateUpdateWithWhereUniqueWithoutCreatedByInput | SMSTemplateUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SMSTemplateUpdateManyWithWhereWithoutCreatedByInput | SMSTemplateUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SMSTemplateScalarWhereInput | SMSTemplateScalarWhereInput[]
  }

  export type WhatsAppCampaignUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<WhatsAppCampaignCreateWithoutCreatedByInput, WhatsAppCampaignUncheckedCreateWithoutCreatedByInput> | WhatsAppCampaignCreateWithoutCreatedByInput[] | WhatsAppCampaignUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WhatsAppCampaignCreateOrConnectWithoutCreatedByInput | WhatsAppCampaignCreateOrConnectWithoutCreatedByInput[]
    upsert?: WhatsAppCampaignUpsertWithWhereUniqueWithoutCreatedByInput | WhatsAppCampaignUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: WhatsAppCampaignCreateManyCreatedByInputEnvelope
    set?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    disconnect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    delete?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    connect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    update?: WhatsAppCampaignUpdateWithWhereUniqueWithoutCreatedByInput | WhatsAppCampaignUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: WhatsAppCampaignUpdateManyWithWhereWithoutCreatedByInput | WhatsAppCampaignUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: WhatsAppCampaignScalarWhereInput | WhatsAppCampaignScalarWhereInput[]
  }

  export type WhatsAppTemplateUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<WhatsAppTemplateCreateWithoutCreatedByInput, WhatsAppTemplateUncheckedCreateWithoutCreatedByInput> | WhatsAppTemplateCreateWithoutCreatedByInput[] | WhatsAppTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WhatsAppTemplateCreateOrConnectWithoutCreatedByInput | WhatsAppTemplateCreateOrConnectWithoutCreatedByInput[]
    upsert?: WhatsAppTemplateUpsertWithWhereUniqueWithoutCreatedByInput | WhatsAppTemplateUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: WhatsAppTemplateCreateManyCreatedByInputEnvelope
    set?: WhatsAppTemplateWhereUniqueInput | WhatsAppTemplateWhereUniqueInput[]
    disconnect?: WhatsAppTemplateWhereUniqueInput | WhatsAppTemplateWhereUniqueInput[]
    delete?: WhatsAppTemplateWhereUniqueInput | WhatsAppTemplateWhereUniqueInput[]
    connect?: WhatsAppTemplateWhereUniqueInput | WhatsAppTemplateWhereUniqueInput[]
    update?: WhatsAppTemplateUpdateWithWhereUniqueWithoutCreatedByInput | WhatsAppTemplateUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: WhatsAppTemplateUpdateManyWithWhereWithoutCreatedByInput | WhatsAppTemplateUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: WhatsAppTemplateScalarWhereInput | WhatsAppTemplateScalarWhereInput[]
  }

  export type WorkflowUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<WorkflowCreateWithoutCreatedByInput, WorkflowUncheckedCreateWithoutCreatedByInput> | WorkflowCreateWithoutCreatedByInput[] | WorkflowUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutCreatedByInput | WorkflowCreateOrConnectWithoutCreatedByInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutCreatedByInput | WorkflowUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: WorkflowCreateManyCreatedByInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutCreatedByInput | WorkflowUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutCreatedByInput | WorkflowUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type ListUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ListCreateWithoutCreatedByInput, ListUncheckedCreateWithoutCreatedByInput> | ListCreateWithoutCreatedByInput[] | ListUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ListCreateOrConnectWithoutCreatedByInput | ListCreateOrConnectWithoutCreatedByInput[]
    upsert?: ListUpsertWithWhereUniqueWithoutCreatedByInput | ListUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ListCreateManyCreatedByInputEnvelope
    set?: ListWhereUniqueInput | ListWhereUniqueInput[]
    disconnect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    delete?: ListWhereUniqueInput | ListWhereUniqueInput[]
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    update?: ListUpdateWithWhereUniqueWithoutCreatedByInput | ListUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ListUpdateManyWithWhereWithoutCreatedByInput | ListUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ListScalarWhereInput | ListScalarWhereInput[]
  }

  export type SegmentUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SegmentCreateWithoutCreatedByInput, SegmentUncheckedCreateWithoutCreatedByInput> | SegmentCreateWithoutCreatedByInput[] | SegmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SegmentCreateOrConnectWithoutCreatedByInput | SegmentCreateOrConnectWithoutCreatedByInput[]
    upsert?: SegmentUpsertWithWhereUniqueWithoutCreatedByInput | SegmentUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SegmentCreateManyCreatedByInputEnvelope
    set?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    disconnect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    delete?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    connect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    update?: SegmentUpdateWithWhereUniqueWithoutCreatedByInput | SegmentUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SegmentUpdateManyWithWhereWithoutCreatedByInput | SegmentUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SegmentScalarWhereInput | SegmentScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ContactCreateWithoutCreatedByInput, ContactUncheckedCreateWithoutCreatedByInput> | ContactCreateWithoutCreatedByInput[] | ContactUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCreatedByInput | ContactCreateOrConnectWithoutCreatedByInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutCreatedByInput | ContactUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ContactCreateManyCreatedByInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutCreatedByInput | ContactUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutCreatedByInput | ContactUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type EmailCampaignUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<EmailCampaignCreateWithoutCreatedByInput, EmailCampaignUncheckedCreateWithoutCreatedByInput> | EmailCampaignCreateWithoutCreatedByInput[] | EmailCampaignUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutCreatedByInput | EmailCampaignCreateOrConnectWithoutCreatedByInput[]
    upsert?: EmailCampaignUpsertWithWhereUniqueWithoutCreatedByInput | EmailCampaignUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: EmailCampaignCreateManyCreatedByInputEnvelope
    set?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    disconnect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    delete?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    connect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    update?: EmailCampaignUpdateWithWhereUniqueWithoutCreatedByInput | EmailCampaignUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: EmailCampaignUpdateManyWithWhereWithoutCreatedByInput | EmailCampaignUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: EmailCampaignScalarWhereInput | EmailCampaignScalarWhereInput[]
  }

  export type EmailTemplateUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutCreatedByInput, EmailTemplateUncheckedCreateWithoutCreatedByInput> | EmailTemplateCreateWithoutCreatedByInput[] | EmailTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutCreatedByInput | EmailTemplateCreateOrConnectWithoutCreatedByInput[]
    upsert?: EmailTemplateUpsertWithWhereUniqueWithoutCreatedByInput | EmailTemplateUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: EmailTemplateCreateManyCreatedByInputEnvelope
    set?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    disconnect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    delete?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    connect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    update?: EmailTemplateUpdateWithWhereUniqueWithoutCreatedByInput | EmailTemplateUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: EmailTemplateUpdateManyWithWhereWithoutCreatedByInput | EmailTemplateUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: EmailTemplateScalarWhereInput | EmailTemplateScalarWhereInput[]
  }

  export type SMSCampaignUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SMSCampaignCreateWithoutCreatedByInput, SMSCampaignUncheckedCreateWithoutCreatedByInput> | SMSCampaignCreateWithoutCreatedByInput[] | SMSCampaignUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SMSCampaignCreateOrConnectWithoutCreatedByInput | SMSCampaignCreateOrConnectWithoutCreatedByInput[]
    upsert?: SMSCampaignUpsertWithWhereUniqueWithoutCreatedByInput | SMSCampaignUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SMSCampaignCreateManyCreatedByInputEnvelope
    set?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    disconnect?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    delete?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    connect?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    update?: SMSCampaignUpdateWithWhereUniqueWithoutCreatedByInput | SMSCampaignUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SMSCampaignUpdateManyWithWhereWithoutCreatedByInput | SMSCampaignUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SMSCampaignScalarWhereInput | SMSCampaignScalarWhereInput[]
  }

  export type SMSTemplateUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SMSTemplateCreateWithoutCreatedByInput, SMSTemplateUncheckedCreateWithoutCreatedByInput> | SMSTemplateCreateWithoutCreatedByInput[] | SMSTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SMSTemplateCreateOrConnectWithoutCreatedByInput | SMSTemplateCreateOrConnectWithoutCreatedByInput[]
    upsert?: SMSTemplateUpsertWithWhereUniqueWithoutCreatedByInput | SMSTemplateUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SMSTemplateCreateManyCreatedByInputEnvelope
    set?: SMSTemplateWhereUniqueInput | SMSTemplateWhereUniqueInput[]
    disconnect?: SMSTemplateWhereUniqueInput | SMSTemplateWhereUniqueInput[]
    delete?: SMSTemplateWhereUniqueInput | SMSTemplateWhereUniqueInput[]
    connect?: SMSTemplateWhereUniqueInput | SMSTemplateWhereUniqueInput[]
    update?: SMSTemplateUpdateWithWhereUniqueWithoutCreatedByInput | SMSTemplateUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SMSTemplateUpdateManyWithWhereWithoutCreatedByInput | SMSTemplateUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SMSTemplateScalarWhereInput | SMSTemplateScalarWhereInput[]
  }

  export type WhatsAppCampaignUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<WhatsAppCampaignCreateWithoutCreatedByInput, WhatsAppCampaignUncheckedCreateWithoutCreatedByInput> | WhatsAppCampaignCreateWithoutCreatedByInput[] | WhatsAppCampaignUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WhatsAppCampaignCreateOrConnectWithoutCreatedByInput | WhatsAppCampaignCreateOrConnectWithoutCreatedByInput[]
    upsert?: WhatsAppCampaignUpsertWithWhereUniqueWithoutCreatedByInput | WhatsAppCampaignUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: WhatsAppCampaignCreateManyCreatedByInputEnvelope
    set?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    disconnect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    delete?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    connect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    update?: WhatsAppCampaignUpdateWithWhereUniqueWithoutCreatedByInput | WhatsAppCampaignUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: WhatsAppCampaignUpdateManyWithWhereWithoutCreatedByInput | WhatsAppCampaignUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: WhatsAppCampaignScalarWhereInput | WhatsAppCampaignScalarWhereInput[]
  }

  export type WhatsAppTemplateUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<WhatsAppTemplateCreateWithoutCreatedByInput, WhatsAppTemplateUncheckedCreateWithoutCreatedByInput> | WhatsAppTemplateCreateWithoutCreatedByInput[] | WhatsAppTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WhatsAppTemplateCreateOrConnectWithoutCreatedByInput | WhatsAppTemplateCreateOrConnectWithoutCreatedByInput[]
    upsert?: WhatsAppTemplateUpsertWithWhereUniqueWithoutCreatedByInput | WhatsAppTemplateUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: WhatsAppTemplateCreateManyCreatedByInputEnvelope
    set?: WhatsAppTemplateWhereUniqueInput | WhatsAppTemplateWhereUniqueInput[]
    disconnect?: WhatsAppTemplateWhereUniqueInput | WhatsAppTemplateWhereUniqueInput[]
    delete?: WhatsAppTemplateWhereUniqueInput | WhatsAppTemplateWhereUniqueInput[]
    connect?: WhatsAppTemplateWhereUniqueInput | WhatsAppTemplateWhereUniqueInput[]
    update?: WhatsAppTemplateUpdateWithWhereUniqueWithoutCreatedByInput | WhatsAppTemplateUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: WhatsAppTemplateUpdateManyWithWhereWithoutCreatedByInput | WhatsAppTemplateUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: WhatsAppTemplateScalarWhereInput | WhatsAppTemplateScalarWhereInput[]
  }

  export type WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<WorkflowCreateWithoutCreatedByInput, WorkflowUncheckedCreateWithoutCreatedByInput> | WorkflowCreateWithoutCreatedByInput[] | WorkflowUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutCreatedByInput | WorkflowCreateOrConnectWithoutCreatedByInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutCreatedByInput | WorkflowUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: WorkflowCreateManyCreatedByInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutCreatedByInput | WorkflowUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutCreatedByInput | WorkflowUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type ListUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ListCreateWithoutCreatedByInput, ListUncheckedCreateWithoutCreatedByInput> | ListCreateWithoutCreatedByInput[] | ListUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ListCreateOrConnectWithoutCreatedByInput | ListCreateOrConnectWithoutCreatedByInput[]
    upsert?: ListUpsertWithWhereUniqueWithoutCreatedByInput | ListUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ListCreateManyCreatedByInputEnvelope
    set?: ListWhereUniqueInput | ListWhereUniqueInput[]
    disconnect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    delete?: ListWhereUniqueInput | ListWhereUniqueInput[]
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    update?: ListUpdateWithWhereUniqueWithoutCreatedByInput | ListUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ListUpdateManyWithWhereWithoutCreatedByInput | ListUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ListScalarWhereInput | ListScalarWhereInput[]
  }

  export type SegmentUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SegmentCreateWithoutCreatedByInput, SegmentUncheckedCreateWithoutCreatedByInput> | SegmentCreateWithoutCreatedByInput[] | SegmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SegmentCreateOrConnectWithoutCreatedByInput | SegmentCreateOrConnectWithoutCreatedByInput[]
    upsert?: SegmentUpsertWithWhereUniqueWithoutCreatedByInput | SegmentUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SegmentCreateManyCreatedByInputEnvelope
    set?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    disconnect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    delete?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    connect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    update?: SegmentUpdateWithWhereUniqueWithoutCreatedByInput | SegmentUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SegmentUpdateManyWithWhereWithoutCreatedByInput | SegmentUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SegmentScalarWhereInput | SegmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutContactsInput = {
    create?: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactsInput
    connect?: UserWhereUniqueInput
  }

  export type ListMemberCreateNestedManyWithoutContactInput = {
    create?: XOR<ListMemberCreateWithoutContactInput, ListMemberUncheckedCreateWithoutContactInput> | ListMemberCreateWithoutContactInput[] | ListMemberUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ListMemberCreateOrConnectWithoutContactInput | ListMemberCreateOrConnectWithoutContactInput[]
    createMany?: ListMemberCreateManyContactInputEnvelope
    connect?: ListMemberWhereUniqueInput | ListMemberWhereUniqueInput[]
  }

  export type EmailActivityCreateNestedManyWithoutContactInput = {
    create?: XOR<EmailActivityCreateWithoutContactInput, EmailActivityUncheckedCreateWithoutContactInput> | EmailActivityCreateWithoutContactInput[] | EmailActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: EmailActivityCreateOrConnectWithoutContactInput | EmailActivityCreateOrConnectWithoutContactInput[]
    createMany?: EmailActivityCreateManyContactInputEnvelope
    connect?: EmailActivityWhereUniqueInput | EmailActivityWhereUniqueInput[]
  }

  export type SMSActivityCreateNestedManyWithoutContactInput = {
    create?: XOR<SMSActivityCreateWithoutContactInput, SMSActivityUncheckedCreateWithoutContactInput> | SMSActivityCreateWithoutContactInput[] | SMSActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: SMSActivityCreateOrConnectWithoutContactInput | SMSActivityCreateOrConnectWithoutContactInput[]
    createMany?: SMSActivityCreateManyContactInputEnvelope
    connect?: SMSActivityWhereUniqueInput | SMSActivityWhereUniqueInput[]
  }

  export type WhatsAppActivityCreateNestedManyWithoutContactInput = {
    create?: XOR<WhatsAppActivityCreateWithoutContactInput, WhatsAppActivityUncheckedCreateWithoutContactInput> | WhatsAppActivityCreateWithoutContactInput[] | WhatsAppActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: WhatsAppActivityCreateOrConnectWithoutContactInput | WhatsAppActivityCreateOrConnectWithoutContactInput[]
    createMany?: WhatsAppActivityCreateManyContactInputEnvelope
    connect?: WhatsAppActivityWhereUniqueInput | WhatsAppActivityWhereUniqueInput[]
  }

  export type ListMemberUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ListMemberCreateWithoutContactInput, ListMemberUncheckedCreateWithoutContactInput> | ListMemberCreateWithoutContactInput[] | ListMemberUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ListMemberCreateOrConnectWithoutContactInput | ListMemberCreateOrConnectWithoutContactInput[]
    createMany?: ListMemberCreateManyContactInputEnvelope
    connect?: ListMemberWhereUniqueInput | ListMemberWhereUniqueInput[]
  }

  export type EmailActivityUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<EmailActivityCreateWithoutContactInput, EmailActivityUncheckedCreateWithoutContactInput> | EmailActivityCreateWithoutContactInput[] | EmailActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: EmailActivityCreateOrConnectWithoutContactInput | EmailActivityCreateOrConnectWithoutContactInput[]
    createMany?: EmailActivityCreateManyContactInputEnvelope
    connect?: EmailActivityWhereUniqueInput | EmailActivityWhereUniqueInput[]
  }

  export type SMSActivityUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<SMSActivityCreateWithoutContactInput, SMSActivityUncheckedCreateWithoutContactInput> | SMSActivityCreateWithoutContactInput[] | SMSActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: SMSActivityCreateOrConnectWithoutContactInput | SMSActivityCreateOrConnectWithoutContactInput[]
    createMany?: SMSActivityCreateManyContactInputEnvelope
    connect?: SMSActivityWhereUniqueInput | SMSActivityWhereUniqueInput[]
  }

  export type WhatsAppActivityUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<WhatsAppActivityCreateWithoutContactInput, WhatsAppActivityUncheckedCreateWithoutContactInput> | WhatsAppActivityCreateWithoutContactInput[] | WhatsAppActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: WhatsAppActivityCreateOrConnectWithoutContactInput | WhatsAppActivityCreateOrConnectWithoutContactInput[]
    createMany?: WhatsAppActivityCreateManyContactInputEnvelope
    connect?: WhatsAppActivityWhereUniqueInput | WhatsAppActivityWhereUniqueInput[]
  }

  export type EnumContactStatusFieldUpdateOperationsInput = {
    set?: $Enums.ContactStatus
  }

  export type UserUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactsInput
    upsert?: UserUpsertWithoutContactsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContactsInput, UserUpdateWithoutContactsInput>, UserUncheckedUpdateWithoutContactsInput>
  }

  export type ListMemberUpdateManyWithoutContactNestedInput = {
    create?: XOR<ListMemberCreateWithoutContactInput, ListMemberUncheckedCreateWithoutContactInput> | ListMemberCreateWithoutContactInput[] | ListMemberUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ListMemberCreateOrConnectWithoutContactInput | ListMemberCreateOrConnectWithoutContactInput[]
    upsert?: ListMemberUpsertWithWhereUniqueWithoutContactInput | ListMemberUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ListMemberCreateManyContactInputEnvelope
    set?: ListMemberWhereUniqueInput | ListMemberWhereUniqueInput[]
    disconnect?: ListMemberWhereUniqueInput | ListMemberWhereUniqueInput[]
    delete?: ListMemberWhereUniqueInput | ListMemberWhereUniqueInput[]
    connect?: ListMemberWhereUniqueInput | ListMemberWhereUniqueInput[]
    update?: ListMemberUpdateWithWhereUniqueWithoutContactInput | ListMemberUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ListMemberUpdateManyWithWhereWithoutContactInput | ListMemberUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ListMemberScalarWhereInput | ListMemberScalarWhereInput[]
  }

  export type EmailActivityUpdateManyWithoutContactNestedInput = {
    create?: XOR<EmailActivityCreateWithoutContactInput, EmailActivityUncheckedCreateWithoutContactInput> | EmailActivityCreateWithoutContactInput[] | EmailActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: EmailActivityCreateOrConnectWithoutContactInput | EmailActivityCreateOrConnectWithoutContactInput[]
    upsert?: EmailActivityUpsertWithWhereUniqueWithoutContactInput | EmailActivityUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: EmailActivityCreateManyContactInputEnvelope
    set?: EmailActivityWhereUniqueInput | EmailActivityWhereUniqueInput[]
    disconnect?: EmailActivityWhereUniqueInput | EmailActivityWhereUniqueInput[]
    delete?: EmailActivityWhereUniqueInput | EmailActivityWhereUniqueInput[]
    connect?: EmailActivityWhereUniqueInput | EmailActivityWhereUniqueInput[]
    update?: EmailActivityUpdateWithWhereUniqueWithoutContactInput | EmailActivityUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: EmailActivityUpdateManyWithWhereWithoutContactInput | EmailActivityUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: EmailActivityScalarWhereInput | EmailActivityScalarWhereInput[]
  }

  export type SMSActivityUpdateManyWithoutContactNestedInput = {
    create?: XOR<SMSActivityCreateWithoutContactInput, SMSActivityUncheckedCreateWithoutContactInput> | SMSActivityCreateWithoutContactInput[] | SMSActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: SMSActivityCreateOrConnectWithoutContactInput | SMSActivityCreateOrConnectWithoutContactInput[]
    upsert?: SMSActivityUpsertWithWhereUniqueWithoutContactInput | SMSActivityUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: SMSActivityCreateManyContactInputEnvelope
    set?: SMSActivityWhereUniqueInput | SMSActivityWhereUniqueInput[]
    disconnect?: SMSActivityWhereUniqueInput | SMSActivityWhereUniqueInput[]
    delete?: SMSActivityWhereUniqueInput | SMSActivityWhereUniqueInput[]
    connect?: SMSActivityWhereUniqueInput | SMSActivityWhereUniqueInput[]
    update?: SMSActivityUpdateWithWhereUniqueWithoutContactInput | SMSActivityUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: SMSActivityUpdateManyWithWhereWithoutContactInput | SMSActivityUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: SMSActivityScalarWhereInput | SMSActivityScalarWhereInput[]
  }

  export type WhatsAppActivityUpdateManyWithoutContactNestedInput = {
    create?: XOR<WhatsAppActivityCreateWithoutContactInput, WhatsAppActivityUncheckedCreateWithoutContactInput> | WhatsAppActivityCreateWithoutContactInput[] | WhatsAppActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: WhatsAppActivityCreateOrConnectWithoutContactInput | WhatsAppActivityCreateOrConnectWithoutContactInput[]
    upsert?: WhatsAppActivityUpsertWithWhereUniqueWithoutContactInput | WhatsAppActivityUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: WhatsAppActivityCreateManyContactInputEnvelope
    set?: WhatsAppActivityWhereUniqueInput | WhatsAppActivityWhereUniqueInput[]
    disconnect?: WhatsAppActivityWhereUniqueInput | WhatsAppActivityWhereUniqueInput[]
    delete?: WhatsAppActivityWhereUniqueInput | WhatsAppActivityWhereUniqueInput[]
    connect?: WhatsAppActivityWhereUniqueInput | WhatsAppActivityWhereUniqueInput[]
    update?: WhatsAppActivityUpdateWithWhereUniqueWithoutContactInput | WhatsAppActivityUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: WhatsAppActivityUpdateManyWithWhereWithoutContactInput | WhatsAppActivityUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: WhatsAppActivityScalarWhereInput | WhatsAppActivityScalarWhereInput[]
  }

  export type ListMemberUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ListMemberCreateWithoutContactInput, ListMemberUncheckedCreateWithoutContactInput> | ListMemberCreateWithoutContactInput[] | ListMemberUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ListMemberCreateOrConnectWithoutContactInput | ListMemberCreateOrConnectWithoutContactInput[]
    upsert?: ListMemberUpsertWithWhereUniqueWithoutContactInput | ListMemberUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ListMemberCreateManyContactInputEnvelope
    set?: ListMemberWhereUniqueInput | ListMemberWhereUniqueInput[]
    disconnect?: ListMemberWhereUniqueInput | ListMemberWhereUniqueInput[]
    delete?: ListMemberWhereUniqueInput | ListMemberWhereUniqueInput[]
    connect?: ListMemberWhereUniqueInput | ListMemberWhereUniqueInput[]
    update?: ListMemberUpdateWithWhereUniqueWithoutContactInput | ListMemberUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ListMemberUpdateManyWithWhereWithoutContactInput | ListMemberUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ListMemberScalarWhereInput | ListMemberScalarWhereInput[]
  }

  export type EmailActivityUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<EmailActivityCreateWithoutContactInput, EmailActivityUncheckedCreateWithoutContactInput> | EmailActivityCreateWithoutContactInput[] | EmailActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: EmailActivityCreateOrConnectWithoutContactInput | EmailActivityCreateOrConnectWithoutContactInput[]
    upsert?: EmailActivityUpsertWithWhereUniqueWithoutContactInput | EmailActivityUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: EmailActivityCreateManyContactInputEnvelope
    set?: EmailActivityWhereUniqueInput | EmailActivityWhereUniqueInput[]
    disconnect?: EmailActivityWhereUniqueInput | EmailActivityWhereUniqueInput[]
    delete?: EmailActivityWhereUniqueInput | EmailActivityWhereUniqueInput[]
    connect?: EmailActivityWhereUniqueInput | EmailActivityWhereUniqueInput[]
    update?: EmailActivityUpdateWithWhereUniqueWithoutContactInput | EmailActivityUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: EmailActivityUpdateManyWithWhereWithoutContactInput | EmailActivityUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: EmailActivityScalarWhereInput | EmailActivityScalarWhereInput[]
  }

  export type SMSActivityUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<SMSActivityCreateWithoutContactInput, SMSActivityUncheckedCreateWithoutContactInput> | SMSActivityCreateWithoutContactInput[] | SMSActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: SMSActivityCreateOrConnectWithoutContactInput | SMSActivityCreateOrConnectWithoutContactInput[]
    upsert?: SMSActivityUpsertWithWhereUniqueWithoutContactInput | SMSActivityUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: SMSActivityCreateManyContactInputEnvelope
    set?: SMSActivityWhereUniqueInput | SMSActivityWhereUniqueInput[]
    disconnect?: SMSActivityWhereUniqueInput | SMSActivityWhereUniqueInput[]
    delete?: SMSActivityWhereUniqueInput | SMSActivityWhereUniqueInput[]
    connect?: SMSActivityWhereUniqueInput | SMSActivityWhereUniqueInput[]
    update?: SMSActivityUpdateWithWhereUniqueWithoutContactInput | SMSActivityUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: SMSActivityUpdateManyWithWhereWithoutContactInput | SMSActivityUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: SMSActivityScalarWhereInput | SMSActivityScalarWhereInput[]
  }

  export type WhatsAppActivityUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<WhatsAppActivityCreateWithoutContactInput, WhatsAppActivityUncheckedCreateWithoutContactInput> | WhatsAppActivityCreateWithoutContactInput[] | WhatsAppActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: WhatsAppActivityCreateOrConnectWithoutContactInput | WhatsAppActivityCreateOrConnectWithoutContactInput[]
    upsert?: WhatsAppActivityUpsertWithWhereUniqueWithoutContactInput | WhatsAppActivityUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: WhatsAppActivityCreateManyContactInputEnvelope
    set?: WhatsAppActivityWhereUniqueInput | WhatsAppActivityWhereUniqueInput[]
    disconnect?: WhatsAppActivityWhereUniqueInput | WhatsAppActivityWhereUniqueInput[]
    delete?: WhatsAppActivityWhereUniqueInput | WhatsAppActivityWhereUniqueInput[]
    connect?: WhatsAppActivityWhereUniqueInput | WhatsAppActivityWhereUniqueInput[]
    update?: WhatsAppActivityUpdateWithWhereUniqueWithoutContactInput | WhatsAppActivityUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: WhatsAppActivityUpdateManyWithWhereWithoutContactInput | WhatsAppActivityUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: WhatsAppActivityScalarWhereInput | WhatsAppActivityScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutListsInput = {
    create?: XOR<UserCreateWithoutListsInput, UserUncheckedCreateWithoutListsInput>
    connectOrCreate?: UserCreateOrConnectWithoutListsInput
    connect?: UserWhereUniqueInput
  }

  export type ListMemberCreateNestedManyWithoutListInput = {
    create?: XOR<ListMemberCreateWithoutListInput, ListMemberUncheckedCreateWithoutListInput> | ListMemberCreateWithoutListInput[] | ListMemberUncheckedCreateWithoutListInput[]
    connectOrCreate?: ListMemberCreateOrConnectWithoutListInput | ListMemberCreateOrConnectWithoutListInput[]
    createMany?: ListMemberCreateManyListInputEnvelope
    connect?: ListMemberWhereUniqueInput | ListMemberWhereUniqueInput[]
  }

  export type EmailCampaignCreateNestedManyWithoutListsInput = {
    create?: XOR<EmailCampaignCreateWithoutListsInput, EmailCampaignUncheckedCreateWithoutListsInput> | EmailCampaignCreateWithoutListsInput[] | EmailCampaignUncheckedCreateWithoutListsInput[]
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutListsInput | EmailCampaignCreateOrConnectWithoutListsInput[]
    connect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
  }

  export type SMSCampaignCreateNestedManyWithoutListsInput = {
    create?: XOR<SMSCampaignCreateWithoutListsInput, SMSCampaignUncheckedCreateWithoutListsInput> | SMSCampaignCreateWithoutListsInput[] | SMSCampaignUncheckedCreateWithoutListsInput[]
    connectOrCreate?: SMSCampaignCreateOrConnectWithoutListsInput | SMSCampaignCreateOrConnectWithoutListsInput[]
    connect?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
  }

  export type WhatsAppCampaignCreateNestedManyWithoutListsInput = {
    create?: XOR<WhatsAppCampaignCreateWithoutListsInput, WhatsAppCampaignUncheckedCreateWithoutListsInput> | WhatsAppCampaignCreateWithoutListsInput[] | WhatsAppCampaignUncheckedCreateWithoutListsInput[]
    connectOrCreate?: WhatsAppCampaignCreateOrConnectWithoutListsInput | WhatsAppCampaignCreateOrConnectWithoutListsInput[]
    connect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
  }

  export type ListMemberUncheckedCreateNestedManyWithoutListInput = {
    create?: XOR<ListMemberCreateWithoutListInput, ListMemberUncheckedCreateWithoutListInput> | ListMemberCreateWithoutListInput[] | ListMemberUncheckedCreateWithoutListInput[]
    connectOrCreate?: ListMemberCreateOrConnectWithoutListInput | ListMemberCreateOrConnectWithoutListInput[]
    createMany?: ListMemberCreateManyListInputEnvelope
    connect?: ListMemberWhereUniqueInput | ListMemberWhereUniqueInput[]
  }

  export type EmailCampaignUncheckedCreateNestedManyWithoutListsInput = {
    create?: XOR<EmailCampaignCreateWithoutListsInput, EmailCampaignUncheckedCreateWithoutListsInput> | EmailCampaignCreateWithoutListsInput[] | EmailCampaignUncheckedCreateWithoutListsInput[]
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutListsInput | EmailCampaignCreateOrConnectWithoutListsInput[]
    connect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
  }

  export type SMSCampaignUncheckedCreateNestedManyWithoutListsInput = {
    create?: XOR<SMSCampaignCreateWithoutListsInput, SMSCampaignUncheckedCreateWithoutListsInput> | SMSCampaignCreateWithoutListsInput[] | SMSCampaignUncheckedCreateWithoutListsInput[]
    connectOrCreate?: SMSCampaignCreateOrConnectWithoutListsInput | SMSCampaignCreateOrConnectWithoutListsInput[]
    connect?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
  }

  export type WhatsAppCampaignUncheckedCreateNestedManyWithoutListsInput = {
    create?: XOR<WhatsAppCampaignCreateWithoutListsInput, WhatsAppCampaignUncheckedCreateWithoutListsInput> | WhatsAppCampaignCreateWithoutListsInput[] | WhatsAppCampaignUncheckedCreateWithoutListsInput[]
    connectOrCreate?: WhatsAppCampaignCreateOrConnectWithoutListsInput | WhatsAppCampaignCreateOrConnectWithoutListsInput[]
    connect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
  }

  export type EnumListTypeFieldUpdateOperationsInput = {
    set?: $Enums.ListType
  }

  export type UserUpdateOneRequiredWithoutListsNestedInput = {
    create?: XOR<UserCreateWithoutListsInput, UserUncheckedCreateWithoutListsInput>
    connectOrCreate?: UserCreateOrConnectWithoutListsInput
    upsert?: UserUpsertWithoutListsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutListsInput, UserUpdateWithoutListsInput>, UserUncheckedUpdateWithoutListsInput>
  }

  export type ListMemberUpdateManyWithoutListNestedInput = {
    create?: XOR<ListMemberCreateWithoutListInput, ListMemberUncheckedCreateWithoutListInput> | ListMemberCreateWithoutListInput[] | ListMemberUncheckedCreateWithoutListInput[]
    connectOrCreate?: ListMemberCreateOrConnectWithoutListInput | ListMemberCreateOrConnectWithoutListInput[]
    upsert?: ListMemberUpsertWithWhereUniqueWithoutListInput | ListMemberUpsertWithWhereUniqueWithoutListInput[]
    createMany?: ListMemberCreateManyListInputEnvelope
    set?: ListMemberWhereUniqueInput | ListMemberWhereUniqueInput[]
    disconnect?: ListMemberWhereUniqueInput | ListMemberWhereUniqueInput[]
    delete?: ListMemberWhereUniqueInput | ListMemberWhereUniqueInput[]
    connect?: ListMemberWhereUniqueInput | ListMemberWhereUniqueInput[]
    update?: ListMemberUpdateWithWhereUniqueWithoutListInput | ListMemberUpdateWithWhereUniqueWithoutListInput[]
    updateMany?: ListMemberUpdateManyWithWhereWithoutListInput | ListMemberUpdateManyWithWhereWithoutListInput[]
    deleteMany?: ListMemberScalarWhereInput | ListMemberScalarWhereInput[]
  }

  export type EmailCampaignUpdateManyWithoutListsNestedInput = {
    create?: XOR<EmailCampaignCreateWithoutListsInput, EmailCampaignUncheckedCreateWithoutListsInput> | EmailCampaignCreateWithoutListsInput[] | EmailCampaignUncheckedCreateWithoutListsInput[]
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutListsInput | EmailCampaignCreateOrConnectWithoutListsInput[]
    upsert?: EmailCampaignUpsertWithWhereUniqueWithoutListsInput | EmailCampaignUpsertWithWhereUniqueWithoutListsInput[]
    set?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    disconnect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    delete?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    connect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    update?: EmailCampaignUpdateWithWhereUniqueWithoutListsInput | EmailCampaignUpdateWithWhereUniqueWithoutListsInput[]
    updateMany?: EmailCampaignUpdateManyWithWhereWithoutListsInput | EmailCampaignUpdateManyWithWhereWithoutListsInput[]
    deleteMany?: EmailCampaignScalarWhereInput | EmailCampaignScalarWhereInput[]
  }

  export type SMSCampaignUpdateManyWithoutListsNestedInput = {
    create?: XOR<SMSCampaignCreateWithoutListsInput, SMSCampaignUncheckedCreateWithoutListsInput> | SMSCampaignCreateWithoutListsInput[] | SMSCampaignUncheckedCreateWithoutListsInput[]
    connectOrCreate?: SMSCampaignCreateOrConnectWithoutListsInput | SMSCampaignCreateOrConnectWithoutListsInput[]
    upsert?: SMSCampaignUpsertWithWhereUniqueWithoutListsInput | SMSCampaignUpsertWithWhereUniqueWithoutListsInput[]
    set?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    disconnect?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    delete?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    connect?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    update?: SMSCampaignUpdateWithWhereUniqueWithoutListsInput | SMSCampaignUpdateWithWhereUniqueWithoutListsInput[]
    updateMany?: SMSCampaignUpdateManyWithWhereWithoutListsInput | SMSCampaignUpdateManyWithWhereWithoutListsInput[]
    deleteMany?: SMSCampaignScalarWhereInput | SMSCampaignScalarWhereInput[]
  }

  export type WhatsAppCampaignUpdateManyWithoutListsNestedInput = {
    create?: XOR<WhatsAppCampaignCreateWithoutListsInput, WhatsAppCampaignUncheckedCreateWithoutListsInput> | WhatsAppCampaignCreateWithoutListsInput[] | WhatsAppCampaignUncheckedCreateWithoutListsInput[]
    connectOrCreate?: WhatsAppCampaignCreateOrConnectWithoutListsInput | WhatsAppCampaignCreateOrConnectWithoutListsInput[]
    upsert?: WhatsAppCampaignUpsertWithWhereUniqueWithoutListsInput | WhatsAppCampaignUpsertWithWhereUniqueWithoutListsInput[]
    set?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    disconnect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    delete?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    connect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    update?: WhatsAppCampaignUpdateWithWhereUniqueWithoutListsInput | WhatsAppCampaignUpdateWithWhereUniqueWithoutListsInput[]
    updateMany?: WhatsAppCampaignUpdateManyWithWhereWithoutListsInput | WhatsAppCampaignUpdateManyWithWhereWithoutListsInput[]
    deleteMany?: WhatsAppCampaignScalarWhereInput | WhatsAppCampaignScalarWhereInput[]
  }

  export type ListMemberUncheckedUpdateManyWithoutListNestedInput = {
    create?: XOR<ListMemberCreateWithoutListInput, ListMemberUncheckedCreateWithoutListInput> | ListMemberCreateWithoutListInput[] | ListMemberUncheckedCreateWithoutListInput[]
    connectOrCreate?: ListMemberCreateOrConnectWithoutListInput | ListMemberCreateOrConnectWithoutListInput[]
    upsert?: ListMemberUpsertWithWhereUniqueWithoutListInput | ListMemberUpsertWithWhereUniqueWithoutListInput[]
    createMany?: ListMemberCreateManyListInputEnvelope
    set?: ListMemberWhereUniqueInput | ListMemberWhereUniqueInput[]
    disconnect?: ListMemberWhereUniqueInput | ListMemberWhereUniqueInput[]
    delete?: ListMemberWhereUniqueInput | ListMemberWhereUniqueInput[]
    connect?: ListMemberWhereUniqueInput | ListMemberWhereUniqueInput[]
    update?: ListMemberUpdateWithWhereUniqueWithoutListInput | ListMemberUpdateWithWhereUniqueWithoutListInput[]
    updateMany?: ListMemberUpdateManyWithWhereWithoutListInput | ListMemberUpdateManyWithWhereWithoutListInput[]
    deleteMany?: ListMemberScalarWhereInput | ListMemberScalarWhereInput[]
  }

  export type EmailCampaignUncheckedUpdateManyWithoutListsNestedInput = {
    create?: XOR<EmailCampaignCreateWithoutListsInput, EmailCampaignUncheckedCreateWithoutListsInput> | EmailCampaignCreateWithoutListsInput[] | EmailCampaignUncheckedCreateWithoutListsInput[]
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutListsInput | EmailCampaignCreateOrConnectWithoutListsInput[]
    upsert?: EmailCampaignUpsertWithWhereUniqueWithoutListsInput | EmailCampaignUpsertWithWhereUniqueWithoutListsInput[]
    set?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    disconnect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    delete?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    connect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    update?: EmailCampaignUpdateWithWhereUniqueWithoutListsInput | EmailCampaignUpdateWithWhereUniqueWithoutListsInput[]
    updateMany?: EmailCampaignUpdateManyWithWhereWithoutListsInput | EmailCampaignUpdateManyWithWhereWithoutListsInput[]
    deleteMany?: EmailCampaignScalarWhereInput | EmailCampaignScalarWhereInput[]
  }

  export type SMSCampaignUncheckedUpdateManyWithoutListsNestedInput = {
    create?: XOR<SMSCampaignCreateWithoutListsInput, SMSCampaignUncheckedCreateWithoutListsInput> | SMSCampaignCreateWithoutListsInput[] | SMSCampaignUncheckedCreateWithoutListsInput[]
    connectOrCreate?: SMSCampaignCreateOrConnectWithoutListsInput | SMSCampaignCreateOrConnectWithoutListsInput[]
    upsert?: SMSCampaignUpsertWithWhereUniqueWithoutListsInput | SMSCampaignUpsertWithWhereUniqueWithoutListsInput[]
    set?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    disconnect?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    delete?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    connect?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    update?: SMSCampaignUpdateWithWhereUniqueWithoutListsInput | SMSCampaignUpdateWithWhereUniqueWithoutListsInput[]
    updateMany?: SMSCampaignUpdateManyWithWhereWithoutListsInput | SMSCampaignUpdateManyWithWhereWithoutListsInput[]
    deleteMany?: SMSCampaignScalarWhereInput | SMSCampaignScalarWhereInput[]
  }

  export type WhatsAppCampaignUncheckedUpdateManyWithoutListsNestedInput = {
    create?: XOR<WhatsAppCampaignCreateWithoutListsInput, WhatsAppCampaignUncheckedCreateWithoutListsInput> | WhatsAppCampaignCreateWithoutListsInput[] | WhatsAppCampaignUncheckedCreateWithoutListsInput[]
    connectOrCreate?: WhatsAppCampaignCreateOrConnectWithoutListsInput | WhatsAppCampaignCreateOrConnectWithoutListsInput[]
    upsert?: WhatsAppCampaignUpsertWithWhereUniqueWithoutListsInput | WhatsAppCampaignUpsertWithWhereUniqueWithoutListsInput[]
    set?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    disconnect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    delete?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    connect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    update?: WhatsAppCampaignUpdateWithWhereUniqueWithoutListsInput | WhatsAppCampaignUpdateWithWhereUniqueWithoutListsInput[]
    updateMany?: WhatsAppCampaignUpdateManyWithWhereWithoutListsInput | WhatsAppCampaignUpdateManyWithWhereWithoutListsInput[]
    deleteMany?: WhatsAppCampaignScalarWhereInput | WhatsAppCampaignScalarWhereInput[]
  }

  export type ListCreateNestedOneWithoutMembersInput = {
    create?: XOR<ListCreateWithoutMembersInput, ListUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ListCreateOrConnectWithoutMembersInput
    connect?: ListWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutListMembersInput = {
    create?: XOR<ContactCreateWithoutListMembersInput, ContactUncheckedCreateWithoutListMembersInput>
    connectOrCreate?: ContactCreateOrConnectWithoutListMembersInput
    connect?: ContactWhereUniqueInput
  }

  export type ListUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ListCreateWithoutMembersInput, ListUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ListCreateOrConnectWithoutMembersInput
    upsert?: ListUpsertWithoutMembersInput
    connect?: ListWhereUniqueInput
    update?: XOR<XOR<ListUpdateToOneWithWhereWithoutMembersInput, ListUpdateWithoutMembersInput>, ListUncheckedUpdateWithoutMembersInput>
  }

  export type ContactUpdateOneRequiredWithoutListMembersNestedInput = {
    create?: XOR<ContactCreateWithoutListMembersInput, ContactUncheckedCreateWithoutListMembersInput>
    connectOrCreate?: ContactCreateOrConnectWithoutListMembersInput
    upsert?: ContactUpsertWithoutListMembersInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutListMembersInput, ContactUpdateWithoutListMembersInput>, ContactUncheckedUpdateWithoutListMembersInput>
  }

  export type UserCreateNestedOneWithoutSegmentsInput = {
    create?: XOR<UserCreateWithoutSegmentsInput, UserUncheckedCreateWithoutSegmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSegmentsInput
    connect?: UserWhereUniqueInput
  }

  export type EmailCampaignCreateNestedManyWithoutSegmentsInput = {
    create?: XOR<EmailCampaignCreateWithoutSegmentsInput, EmailCampaignUncheckedCreateWithoutSegmentsInput> | EmailCampaignCreateWithoutSegmentsInput[] | EmailCampaignUncheckedCreateWithoutSegmentsInput[]
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutSegmentsInput | EmailCampaignCreateOrConnectWithoutSegmentsInput[]
    connect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
  }

  export type SMSCampaignCreateNestedManyWithoutSegmentsInput = {
    create?: XOR<SMSCampaignCreateWithoutSegmentsInput, SMSCampaignUncheckedCreateWithoutSegmentsInput> | SMSCampaignCreateWithoutSegmentsInput[] | SMSCampaignUncheckedCreateWithoutSegmentsInput[]
    connectOrCreate?: SMSCampaignCreateOrConnectWithoutSegmentsInput | SMSCampaignCreateOrConnectWithoutSegmentsInput[]
    connect?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
  }

  export type WhatsAppCampaignCreateNestedManyWithoutSegmentsInput = {
    create?: XOR<WhatsAppCampaignCreateWithoutSegmentsInput, WhatsAppCampaignUncheckedCreateWithoutSegmentsInput> | WhatsAppCampaignCreateWithoutSegmentsInput[] | WhatsAppCampaignUncheckedCreateWithoutSegmentsInput[]
    connectOrCreate?: WhatsAppCampaignCreateOrConnectWithoutSegmentsInput | WhatsAppCampaignCreateOrConnectWithoutSegmentsInput[]
    connect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
  }

  export type EmailCampaignUncheckedCreateNestedManyWithoutSegmentsInput = {
    create?: XOR<EmailCampaignCreateWithoutSegmentsInput, EmailCampaignUncheckedCreateWithoutSegmentsInput> | EmailCampaignCreateWithoutSegmentsInput[] | EmailCampaignUncheckedCreateWithoutSegmentsInput[]
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutSegmentsInput | EmailCampaignCreateOrConnectWithoutSegmentsInput[]
    connect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
  }

  export type SMSCampaignUncheckedCreateNestedManyWithoutSegmentsInput = {
    create?: XOR<SMSCampaignCreateWithoutSegmentsInput, SMSCampaignUncheckedCreateWithoutSegmentsInput> | SMSCampaignCreateWithoutSegmentsInput[] | SMSCampaignUncheckedCreateWithoutSegmentsInput[]
    connectOrCreate?: SMSCampaignCreateOrConnectWithoutSegmentsInput | SMSCampaignCreateOrConnectWithoutSegmentsInput[]
    connect?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
  }

  export type WhatsAppCampaignUncheckedCreateNestedManyWithoutSegmentsInput = {
    create?: XOR<WhatsAppCampaignCreateWithoutSegmentsInput, WhatsAppCampaignUncheckedCreateWithoutSegmentsInput> | WhatsAppCampaignCreateWithoutSegmentsInput[] | WhatsAppCampaignUncheckedCreateWithoutSegmentsInput[]
    connectOrCreate?: WhatsAppCampaignCreateOrConnectWithoutSegmentsInput | WhatsAppCampaignCreateOrConnectWithoutSegmentsInput[]
    connect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSegmentsNestedInput = {
    create?: XOR<UserCreateWithoutSegmentsInput, UserUncheckedCreateWithoutSegmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSegmentsInput
    upsert?: UserUpsertWithoutSegmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSegmentsInput, UserUpdateWithoutSegmentsInput>, UserUncheckedUpdateWithoutSegmentsInput>
  }

  export type EmailCampaignUpdateManyWithoutSegmentsNestedInput = {
    create?: XOR<EmailCampaignCreateWithoutSegmentsInput, EmailCampaignUncheckedCreateWithoutSegmentsInput> | EmailCampaignCreateWithoutSegmentsInput[] | EmailCampaignUncheckedCreateWithoutSegmentsInput[]
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutSegmentsInput | EmailCampaignCreateOrConnectWithoutSegmentsInput[]
    upsert?: EmailCampaignUpsertWithWhereUniqueWithoutSegmentsInput | EmailCampaignUpsertWithWhereUniqueWithoutSegmentsInput[]
    set?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    disconnect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    delete?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    connect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    update?: EmailCampaignUpdateWithWhereUniqueWithoutSegmentsInput | EmailCampaignUpdateWithWhereUniqueWithoutSegmentsInput[]
    updateMany?: EmailCampaignUpdateManyWithWhereWithoutSegmentsInput | EmailCampaignUpdateManyWithWhereWithoutSegmentsInput[]
    deleteMany?: EmailCampaignScalarWhereInput | EmailCampaignScalarWhereInput[]
  }

  export type SMSCampaignUpdateManyWithoutSegmentsNestedInput = {
    create?: XOR<SMSCampaignCreateWithoutSegmentsInput, SMSCampaignUncheckedCreateWithoutSegmentsInput> | SMSCampaignCreateWithoutSegmentsInput[] | SMSCampaignUncheckedCreateWithoutSegmentsInput[]
    connectOrCreate?: SMSCampaignCreateOrConnectWithoutSegmentsInput | SMSCampaignCreateOrConnectWithoutSegmentsInput[]
    upsert?: SMSCampaignUpsertWithWhereUniqueWithoutSegmentsInput | SMSCampaignUpsertWithWhereUniqueWithoutSegmentsInput[]
    set?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    disconnect?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    delete?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    connect?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    update?: SMSCampaignUpdateWithWhereUniqueWithoutSegmentsInput | SMSCampaignUpdateWithWhereUniqueWithoutSegmentsInput[]
    updateMany?: SMSCampaignUpdateManyWithWhereWithoutSegmentsInput | SMSCampaignUpdateManyWithWhereWithoutSegmentsInput[]
    deleteMany?: SMSCampaignScalarWhereInput | SMSCampaignScalarWhereInput[]
  }

  export type WhatsAppCampaignUpdateManyWithoutSegmentsNestedInput = {
    create?: XOR<WhatsAppCampaignCreateWithoutSegmentsInput, WhatsAppCampaignUncheckedCreateWithoutSegmentsInput> | WhatsAppCampaignCreateWithoutSegmentsInput[] | WhatsAppCampaignUncheckedCreateWithoutSegmentsInput[]
    connectOrCreate?: WhatsAppCampaignCreateOrConnectWithoutSegmentsInput | WhatsAppCampaignCreateOrConnectWithoutSegmentsInput[]
    upsert?: WhatsAppCampaignUpsertWithWhereUniqueWithoutSegmentsInput | WhatsAppCampaignUpsertWithWhereUniqueWithoutSegmentsInput[]
    set?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    disconnect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    delete?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    connect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    update?: WhatsAppCampaignUpdateWithWhereUniqueWithoutSegmentsInput | WhatsAppCampaignUpdateWithWhereUniqueWithoutSegmentsInput[]
    updateMany?: WhatsAppCampaignUpdateManyWithWhereWithoutSegmentsInput | WhatsAppCampaignUpdateManyWithWhereWithoutSegmentsInput[]
    deleteMany?: WhatsAppCampaignScalarWhereInput | WhatsAppCampaignScalarWhereInput[]
  }

  export type EmailCampaignUncheckedUpdateManyWithoutSegmentsNestedInput = {
    create?: XOR<EmailCampaignCreateWithoutSegmentsInput, EmailCampaignUncheckedCreateWithoutSegmentsInput> | EmailCampaignCreateWithoutSegmentsInput[] | EmailCampaignUncheckedCreateWithoutSegmentsInput[]
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutSegmentsInput | EmailCampaignCreateOrConnectWithoutSegmentsInput[]
    upsert?: EmailCampaignUpsertWithWhereUniqueWithoutSegmentsInput | EmailCampaignUpsertWithWhereUniqueWithoutSegmentsInput[]
    set?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    disconnect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    delete?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    connect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    update?: EmailCampaignUpdateWithWhereUniqueWithoutSegmentsInput | EmailCampaignUpdateWithWhereUniqueWithoutSegmentsInput[]
    updateMany?: EmailCampaignUpdateManyWithWhereWithoutSegmentsInput | EmailCampaignUpdateManyWithWhereWithoutSegmentsInput[]
    deleteMany?: EmailCampaignScalarWhereInput | EmailCampaignScalarWhereInput[]
  }

  export type SMSCampaignUncheckedUpdateManyWithoutSegmentsNestedInput = {
    create?: XOR<SMSCampaignCreateWithoutSegmentsInput, SMSCampaignUncheckedCreateWithoutSegmentsInput> | SMSCampaignCreateWithoutSegmentsInput[] | SMSCampaignUncheckedCreateWithoutSegmentsInput[]
    connectOrCreate?: SMSCampaignCreateOrConnectWithoutSegmentsInput | SMSCampaignCreateOrConnectWithoutSegmentsInput[]
    upsert?: SMSCampaignUpsertWithWhereUniqueWithoutSegmentsInput | SMSCampaignUpsertWithWhereUniqueWithoutSegmentsInput[]
    set?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    disconnect?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    delete?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    connect?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    update?: SMSCampaignUpdateWithWhereUniqueWithoutSegmentsInput | SMSCampaignUpdateWithWhereUniqueWithoutSegmentsInput[]
    updateMany?: SMSCampaignUpdateManyWithWhereWithoutSegmentsInput | SMSCampaignUpdateManyWithWhereWithoutSegmentsInput[]
    deleteMany?: SMSCampaignScalarWhereInput | SMSCampaignScalarWhereInput[]
  }

  export type WhatsAppCampaignUncheckedUpdateManyWithoutSegmentsNestedInput = {
    create?: XOR<WhatsAppCampaignCreateWithoutSegmentsInput, WhatsAppCampaignUncheckedCreateWithoutSegmentsInput> | WhatsAppCampaignCreateWithoutSegmentsInput[] | WhatsAppCampaignUncheckedCreateWithoutSegmentsInput[]
    connectOrCreate?: WhatsAppCampaignCreateOrConnectWithoutSegmentsInput | WhatsAppCampaignCreateOrConnectWithoutSegmentsInput[]
    upsert?: WhatsAppCampaignUpsertWithWhereUniqueWithoutSegmentsInput | WhatsAppCampaignUpsertWithWhereUniqueWithoutSegmentsInput[]
    set?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    disconnect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    delete?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    connect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    update?: WhatsAppCampaignUpdateWithWhereUniqueWithoutSegmentsInput | WhatsAppCampaignUpdateWithWhereUniqueWithoutSegmentsInput[]
    updateMany?: WhatsAppCampaignUpdateManyWithWhereWithoutSegmentsInput | WhatsAppCampaignUpdateManyWithWhereWithoutSegmentsInput[]
    deleteMany?: WhatsAppCampaignScalarWhereInput | WhatsAppCampaignScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEmailTemplatesInput = {
    create?: XOR<UserCreateWithoutEmailTemplatesInput, UserUncheckedCreateWithoutEmailTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailTemplatesInput
    connect?: UserWhereUniqueInput
  }

  export type EmailCampaignCreateNestedManyWithoutTemplateInput = {
    create?: XOR<EmailCampaignCreateWithoutTemplateInput, EmailCampaignUncheckedCreateWithoutTemplateInput> | EmailCampaignCreateWithoutTemplateInput[] | EmailCampaignUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutTemplateInput | EmailCampaignCreateOrConnectWithoutTemplateInput[]
    createMany?: EmailCampaignCreateManyTemplateInputEnvelope
    connect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
  }

  export type EmailCampaignUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<EmailCampaignCreateWithoutTemplateInput, EmailCampaignUncheckedCreateWithoutTemplateInput> | EmailCampaignCreateWithoutTemplateInput[] | EmailCampaignUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutTemplateInput | EmailCampaignCreateOrConnectWithoutTemplateInput[]
    createMany?: EmailCampaignCreateManyTemplateInputEnvelope
    connect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutEmailTemplatesNestedInput = {
    create?: XOR<UserCreateWithoutEmailTemplatesInput, UserUncheckedCreateWithoutEmailTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailTemplatesInput
    upsert?: UserUpsertWithoutEmailTemplatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailTemplatesInput, UserUpdateWithoutEmailTemplatesInput>, UserUncheckedUpdateWithoutEmailTemplatesInput>
  }

  export type EmailCampaignUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<EmailCampaignCreateWithoutTemplateInput, EmailCampaignUncheckedCreateWithoutTemplateInput> | EmailCampaignCreateWithoutTemplateInput[] | EmailCampaignUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutTemplateInput | EmailCampaignCreateOrConnectWithoutTemplateInput[]
    upsert?: EmailCampaignUpsertWithWhereUniqueWithoutTemplateInput | EmailCampaignUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: EmailCampaignCreateManyTemplateInputEnvelope
    set?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    disconnect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    delete?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    connect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    update?: EmailCampaignUpdateWithWhereUniqueWithoutTemplateInput | EmailCampaignUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: EmailCampaignUpdateManyWithWhereWithoutTemplateInput | EmailCampaignUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: EmailCampaignScalarWhereInput | EmailCampaignScalarWhereInput[]
  }

  export type EmailCampaignUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<EmailCampaignCreateWithoutTemplateInput, EmailCampaignUncheckedCreateWithoutTemplateInput> | EmailCampaignCreateWithoutTemplateInput[] | EmailCampaignUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutTemplateInput | EmailCampaignCreateOrConnectWithoutTemplateInput[]
    upsert?: EmailCampaignUpsertWithWhereUniqueWithoutTemplateInput | EmailCampaignUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: EmailCampaignCreateManyTemplateInputEnvelope
    set?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    disconnect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    delete?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    connect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    update?: EmailCampaignUpdateWithWhereUniqueWithoutTemplateInput | EmailCampaignUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: EmailCampaignUpdateManyWithWhereWithoutTemplateInput | EmailCampaignUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: EmailCampaignScalarWhereInput | EmailCampaignScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEmailCampaignsInput = {
    create?: XOR<UserCreateWithoutEmailCampaignsInput, UserUncheckedCreateWithoutEmailCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailCampaignsInput
    connect?: UserWhereUniqueInput
  }

  export type EmailTemplateCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<EmailTemplateCreateWithoutCampaignsInput, EmailTemplateUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutCampaignsInput
    connect?: EmailTemplateWhereUniqueInput
  }

  export type ListCreateNestedManyWithoutEmailCampaignsInput = {
    create?: XOR<ListCreateWithoutEmailCampaignsInput, ListUncheckedCreateWithoutEmailCampaignsInput> | ListCreateWithoutEmailCampaignsInput[] | ListUncheckedCreateWithoutEmailCampaignsInput[]
    connectOrCreate?: ListCreateOrConnectWithoutEmailCampaignsInput | ListCreateOrConnectWithoutEmailCampaignsInput[]
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
  }

  export type SegmentCreateNestedManyWithoutEmailCampaignsInput = {
    create?: XOR<SegmentCreateWithoutEmailCampaignsInput, SegmentUncheckedCreateWithoutEmailCampaignsInput> | SegmentCreateWithoutEmailCampaignsInput[] | SegmentUncheckedCreateWithoutEmailCampaignsInput[]
    connectOrCreate?: SegmentCreateOrConnectWithoutEmailCampaignsInput | SegmentCreateOrConnectWithoutEmailCampaignsInput[]
    connect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
  }

  export type EmailActivityCreateNestedManyWithoutCampaignInput = {
    create?: XOR<EmailActivityCreateWithoutCampaignInput, EmailActivityUncheckedCreateWithoutCampaignInput> | EmailActivityCreateWithoutCampaignInput[] | EmailActivityUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EmailActivityCreateOrConnectWithoutCampaignInput | EmailActivityCreateOrConnectWithoutCampaignInput[]
    createMany?: EmailActivityCreateManyCampaignInputEnvelope
    connect?: EmailActivityWhereUniqueInput | EmailActivityWhereUniqueInput[]
  }

  export type ListUncheckedCreateNestedManyWithoutEmailCampaignsInput = {
    create?: XOR<ListCreateWithoutEmailCampaignsInput, ListUncheckedCreateWithoutEmailCampaignsInput> | ListCreateWithoutEmailCampaignsInput[] | ListUncheckedCreateWithoutEmailCampaignsInput[]
    connectOrCreate?: ListCreateOrConnectWithoutEmailCampaignsInput | ListCreateOrConnectWithoutEmailCampaignsInput[]
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
  }

  export type SegmentUncheckedCreateNestedManyWithoutEmailCampaignsInput = {
    create?: XOR<SegmentCreateWithoutEmailCampaignsInput, SegmentUncheckedCreateWithoutEmailCampaignsInput> | SegmentCreateWithoutEmailCampaignsInput[] | SegmentUncheckedCreateWithoutEmailCampaignsInput[]
    connectOrCreate?: SegmentCreateOrConnectWithoutEmailCampaignsInput | SegmentCreateOrConnectWithoutEmailCampaignsInput[]
    connect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
  }

  export type EmailActivityUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<EmailActivityCreateWithoutCampaignInput, EmailActivityUncheckedCreateWithoutCampaignInput> | EmailActivityCreateWithoutCampaignInput[] | EmailActivityUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EmailActivityCreateOrConnectWithoutCampaignInput | EmailActivityCreateOrConnectWithoutCampaignInput[]
    createMany?: EmailActivityCreateManyCampaignInputEnvelope
    connect?: EmailActivityWhereUniqueInput | EmailActivityWhereUniqueInput[]
  }

  export type EnumCampaignStatusFieldUpdateOperationsInput = {
    set?: $Enums.CampaignStatus
  }

  export type UserUpdateOneRequiredWithoutEmailCampaignsNestedInput = {
    create?: XOR<UserCreateWithoutEmailCampaignsInput, UserUncheckedCreateWithoutEmailCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailCampaignsInput
    upsert?: UserUpsertWithoutEmailCampaignsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailCampaignsInput, UserUpdateWithoutEmailCampaignsInput>, UserUncheckedUpdateWithoutEmailCampaignsInput>
  }

  export type EmailTemplateUpdateOneWithoutCampaignsNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutCampaignsInput, EmailTemplateUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutCampaignsInput
    upsert?: EmailTemplateUpsertWithoutCampaignsInput
    disconnect?: EmailTemplateWhereInput | boolean
    delete?: EmailTemplateWhereInput | boolean
    connect?: EmailTemplateWhereUniqueInput
    update?: XOR<XOR<EmailTemplateUpdateToOneWithWhereWithoutCampaignsInput, EmailTemplateUpdateWithoutCampaignsInput>, EmailTemplateUncheckedUpdateWithoutCampaignsInput>
  }

  export type ListUpdateManyWithoutEmailCampaignsNestedInput = {
    create?: XOR<ListCreateWithoutEmailCampaignsInput, ListUncheckedCreateWithoutEmailCampaignsInput> | ListCreateWithoutEmailCampaignsInput[] | ListUncheckedCreateWithoutEmailCampaignsInput[]
    connectOrCreate?: ListCreateOrConnectWithoutEmailCampaignsInput | ListCreateOrConnectWithoutEmailCampaignsInput[]
    upsert?: ListUpsertWithWhereUniqueWithoutEmailCampaignsInput | ListUpsertWithWhereUniqueWithoutEmailCampaignsInput[]
    set?: ListWhereUniqueInput | ListWhereUniqueInput[]
    disconnect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    delete?: ListWhereUniqueInput | ListWhereUniqueInput[]
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    update?: ListUpdateWithWhereUniqueWithoutEmailCampaignsInput | ListUpdateWithWhereUniqueWithoutEmailCampaignsInput[]
    updateMany?: ListUpdateManyWithWhereWithoutEmailCampaignsInput | ListUpdateManyWithWhereWithoutEmailCampaignsInput[]
    deleteMany?: ListScalarWhereInput | ListScalarWhereInput[]
  }

  export type SegmentUpdateManyWithoutEmailCampaignsNestedInput = {
    create?: XOR<SegmentCreateWithoutEmailCampaignsInput, SegmentUncheckedCreateWithoutEmailCampaignsInput> | SegmentCreateWithoutEmailCampaignsInput[] | SegmentUncheckedCreateWithoutEmailCampaignsInput[]
    connectOrCreate?: SegmentCreateOrConnectWithoutEmailCampaignsInput | SegmentCreateOrConnectWithoutEmailCampaignsInput[]
    upsert?: SegmentUpsertWithWhereUniqueWithoutEmailCampaignsInput | SegmentUpsertWithWhereUniqueWithoutEmailCampaignsInput[]
    set?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    disconnect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    delete?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    connect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    update?: SegmentUpdateWithWhereUniqueWithoutEmailCampaignsInput | SegmentUpdateWithWhereUniqueWithoutEmailCampaignsInput[]
    updateMany?: SegmentUpdateManyWithWhereWithoutEmailCampaignsInput | SegmentUpdateManyWithWhereWithoutEmailCampaignsInput[]
    deleteMany?: SegmentScalarWhereInput | SegmentScalarWhereInput[]
  }

  export type EmailActivityUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<EmailActivityCreateWithoutCampaignInput, EmailActivityUncheckedCreateWithoutCampaignInput> | EmailActivityCreateWithoutCampaignInput[] | EmailActivityUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EmailActivityCreateOrConnectWithoutCampaignInput | EmailActivityCreateOrConnectWithoutCampaignInput[]
    upsert?: EmailActivityUpsertWithWhereUniqueWithoutCampaignInput | EmailActivityUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: EmailActivityCreateManyCampaignInputEnvelope
    set?: EmailActivityWhereUniqueInput | EmailActivityWhereUniqueInput[]
    disconnect?: EmailActivityWhereUniqueInput | EmailActivityWhereUniqueInput[]
    delete?: EmailActivityWhereUniqueInput | EmailActivityWhereUniqueInput[]
    connect?: EmailActivityWhereUniqueInput | EmailActivityWhereUniqueInput[]
    update?: EmailActivityUpdateWithWhereUniqueWithoutCampaignInput | EmailActivityUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: EmailActivityUpdateManyWithWhereWithoutCampaignInput | EmailActivityUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: EmailActivityScalarWhereInput | EmailActivityScalarWhereInput[]
  }

  export type ListUncheckedUpdateManyWithoutEmailCampaignsNestedInput = {
    create?: XOR<ListCreateWithoutEmailCampaignsInput, ListUncheckedCreateWithoutEmailCampaignsInput> | ListCreateWithoutEmailCampaignsInput[] | ListUncheckedCreateWithoutEmailCampaignsInput[]
    connectOrCreate?: ListCreateOrConnectWithoutEmailCampaignsInput | ListCreateOrConnectWithoutEmailCampaignsInput[]
    upsert?: ListUpsertWithWhereUniqueWithoutEmailCampaignsInput | ListUpsertWithWhereUniqueWithoutEmailCampaignsInput[]
    set?: ListWhereUniqueInput | ListWhereUniqueInput[]
    disconnect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    delete?: ListWhereUniqueInput | ListWhereUniqueInput[]
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    update?: ListUpdateWithWhereUniqueWithoutEmailCampaignsInput | ListUpdateWithWhereUniqueWithoutEmailCampaignsInput[]
    updateMany?: ListUpdateManyWithWhereWithoutEmailCampaignsInput | ListUpdateManyWithWhereWithoutEmailCampaignsInput[]
    deleteMany?: ListScalarWhereInput | ListScalarWhereInput[]
  }

  export type SegmentUncheckedUpdateManyWithoutEmailCampaignsNestedInput = {
    create?: XOR<SegmentCreateWithoutEmailCampaignsInput, SegmentUncheckedCreateWithoutEmailCampaignsInput> | SegmentCreateWithoutEmailCampaignsInput[] | SegmentUncheckedCreateWithoutEmailCampaignsInput[]
    connectOrCreate?: SegmentCreateOrConnectWithoutEmailCampaignsInput | SegmentCreateOrConnectWithoutEmailCampaignsInput[]
    upsert?: SegmentUpsertWithWhereUniqueWithoutEmailCampaignsInput | SegmentUpsertWithWhereUniqueWithoutEmailCampaignsInput[]
    set?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    disconnect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    delete?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    connect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    update?: SegmentUpdateWithWhereUniqueWithoutEmailCampaignsInput | SegmentUpdateWithWhereUniqueWithoutEmailCampaignsInput[]
    updateMany?: SegmentUpdateManyWithWhereWithoutEmailCampaignsInput | SegmentUpdateManyWithWhereWithoutEmailCampaignsInput[]
    deleteMany?: SegmentScalarWhereInput | SegmentScalarWhereInput[]
  }

  export type EmailActivityUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<EmailActivityCreateWithoutCampaignInput, EmailActivityUncheckedCreateWithoutCampaignInput> | EmailActivityCreateWithoutCampaignInput[] | EmailActivityUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EmailActivityCreateOrConnectWithoutCampaignInput | EmailActivityCreateOrConnectWithoutCampaignInput[]
    upsert?: EmailActivityUpsertWithWhereUniqueWithoutCampaignInput | EmailActivityUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: EmailActivityCreateManyCampaignInputEnvelope
    set?: EmailActivityWhereUniqueInput | EmailActivityWhereUniqueInput[]
    disconnect?: EmailActivityWhereUniqueInput | EmailActivityWhereUniqueInput[]
    delete?: EmailActivityWhereUniqueInput | EmailActivityWhereUniqueInput[]
    connect?: EmailActivityWhereUniqueInput | EmailActivityWhereUniqueInput[]
    update?: EmailActivityUpdateWithWhereUniqueWithoutCampaignInput | EmailActivityUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: EmailActivityUpdateManyWithWhereWithoutCampaignInput | EmailActivityUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: EmailActivityScalarWhereInput | EmailActivityScalarWhereInput[]
  }

  export type EmailCampaignCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<EmailCampaignCreateWithoutActivitiesInput, EmailCampaignUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutActivitiesInput
    connect?: EmailCampaignWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutEmailActivitiesInput = {
    create?: XOR<ContactCreateWithoutEmailActivitiesInput, ContactUncheckedCreateWithoutEmailActivitiesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutEmailActivitiesInput
    connect?: ContactWhereUniqueInput
  }

  export type EnumActivityTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActivityType
  }

  export type EmailCampaignUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<EmailCampaignCreateWithoutActivitiesInput, EmailCampaignUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutActivitiesInput
    upsert?: EmailCampaignUpsertWithoutActivitiesInput
    connect?: EmailCampaignWhereUniqueInput
    update?: XOR<XOR<EmailCampaignUpdateToOneWithWhereWithoutActivitiesInput, EmailCampaignUpdateWithoutActivitiesInput>, EmailCampaignUncheckedUpdateWithoutActivitiesInput>
  }

  export type ContactUpdateOneRequiredWithoutEmailActivitiesNestedInput = {
    create?: XOR<ContactCreateWithoutEmailActivitiesInput, ContactUncheckedCreateWithoutEmailActivitiesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutEmailActivitiesInput
    upsert?: ContactUpsertWithoutEmailActivitiesInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutEmailActivitiesInput, ContactUpdateWithoutEmailActivitiesInput>, ContactUncheckedUpdateWithoutEmailActivitiesInput>
  }

  export type UserCreateNestedOneWithoutSmsTemplatesInput = {
    create?: XOR<UserCreateWithoutSmsTemplatesInput, UserUncheckedCreateWithoutSmsTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSmsTemplatesInput
    connect?: UserWhereUniqueInput
  }

  export type SMSCampaignCreateNestedManyWithoutTemplateInput = {
    create?: XOR<SMSCampaignCreateWithoutTemplateInput, SMSCampaignUncheckedCreateWithoutTemplateInput> | SMSCampaignCreateWithoutTemplateInput[] | SMSCampaignUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: SMSCampaignCreateOrConnectWithoutTemplateInput | SMSCampaignCreateOrConnectWithoutTemplateInput[]
    createMany?: SMSCampaignCreateManyTemplateInputEnvelope
    connect?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
  }

  export type SMSCampaignUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<SMSCampaignCreateWithoutTemplateInput, SMSCampaignUncheckedCreateWithoutTemplateInput> | SMSCampaignCreateWithoutTemplateInput[] | SMSCampaignUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: SMSCampaignCreateOrConnectWithoutTemplateInput | SMSCampaignCreateOrConnectWithoutTemplateInput[]
    createMany?: SMSCampaignCreateManyTemplateInputEnvelope
    connect?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSmsTemplatesNestedInput = {
    create?: XOR<UserCreateWithoutSmsTemplatesInput, UserUncheckedCreateWithoutSmsTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSmsTemplatesInput
    upsert?: UserUpsertWithoutSmsTemplatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSmsTemplatesInput, UserUpdateWithoutSmsTemplatesInput>, UserUncheckedUpdateWithoutSmsTemplatesInput>
  }

  export type SMSCampaignUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<SMSCampaignCreateWithoutTemplateInput, SMSCampaignUncheckedCreateWithoutTemplateInput> | SMSCampaignCreateWithoutTemplateInput[] | SMSCampaignUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: SMSCampaignCreateOrConnectWithoutTemplateInput | SMSCampaignCreateOrConnectWithoutTemplateInput[]
    upsert?: SMSCampaignUpsertWithWhereUniqueWithoutTemplateInput | SMSCampaignUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: SMSCampaignCreateManyTemplateInputEnvelope
    set?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    disconnect?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    delete?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    connect?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    update?: SMSCampaignUpdateWithWhereUniqueWithoutTemplateInput | SMSCampaignUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: SMSCampaignUpdateManyWithWhereWithoutTemplateInput | SMSCampaignUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: SMSCampaignScalarWhereInput | SMSCampaignScalarWhereInput[]
  }

  export type SMSCampaignUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<SMSCampaignCreateWithoutTemplateInput, SMSCampaignUncheckedCreateWithoutTemplateInput> | SMSCampaignCreateWithoutTemplateInput[] | SMSCampaignUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: SMSCampaignCreateOrConnectWithoutTemplateInput | SMSCampaignCreateOrConnectWithoutTemplateInput[]
    upsert?: SMSCampaignUpsertWithWhereUniqueWithoutTemplateInput | SMSCampaignUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: SMSCampaignCreateManyTemplateInputEnvelope
    set?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    disconnect?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    delete?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    connect?: SMSCampaignWhereUniqueInput | SMSCampaignWhereUniqueInput[]
    update?: SMSCampaignUpdateWithWhereUniqueWithoutTemplateInput | SMSCampaignUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: SMSCampaignUpdateManyWithWhereWithoutTemplateInput | SMSCampaignUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: SMSCampaignScalarWhereInput | SMSCampaignScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSmsCampaignsInput = {
    create?: XOR<UserCreateWithoutSmsCampaignsInput, UserUncheckedCreateWithoutSmsCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSmsCampaignsInput
    connect?: UserWhereUniqueInput
  }

  export type SMSTemplateCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<SMSTemplateCreateWithoutCampaignsInput, SMSTemplateUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: SMSTemplateCreateOrConnectWithoutCampaignsInput
    connect?: SMSTemplateWhereUniqueInput
  }

  export type ListCreateNestedManyWithoutSmsCampaignsInput = {
    create?: XOR<ListCreateWithoutSmsCampaignsInput, ListUncheckedCreateWithoutSmsCampaignsInput> | ListCreateWithoutSmsCampaignsInput[] | ListUncheckedCreateWithoutSmsCampaignsInput[]
    connectOrCreate?: ListCreateOrConnectWithoutSmsCampaignsInput | ListCreateOrConnectWithoutSmsCampaignsInput[]
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
  }

  export type SegmentCreateNestedManyWithoutSmsCampaignsInput = {
    create?: XOR<SegmentCreateWithoutSmsCampaignsInput, SegmentUncheckedCreateWithoutSmsCampaignsInput> | SegmentCreateWithoutSmsCampaignsInput[] | SegmentUncheckedCreateWithoutSmsCampaignsInput[]
    connectOrCreate?: SegmentCreateOrConnectWithoutSmsCampaignsInput | SegmentCreateOrConnectWithoutSmsCampaignsInput[]
    connect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
  }

  export type SMSActivityCreateNestedManyWithoutCampaignInput = {
    create?: XOR<SMSActivityCreateWithoutCampaignInput, SMSActivityUncheckedCreateWithoutCampaignInput> | SMSActivityCreateWithoutCampaignInput[] | SMSActivityUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SMSActivityCreateOrConnectWithoutCampaignInput | SMSActivityCreateOrConnectWithoutCampaignInput[]
    createMany?: SMSActivityCreateManyCampaignInputEnvelope
    connect?: SMSActivityWhereUniqueInput | SMSActivityWhereUniqueInput[]
  }

  export type ListUncheckedCreateNestedManyWithoutSmsCampaignsInput = {
    create?: XOR<ListCreateWithoutSmsCampaignsInput, ListUncheckedCreateWithoutSmsCampaignsInput> | ListCreateWithoutSmsCampaignsInput[] | ListUncheckedCreateWithoutSmsCampaignsInput[]
    connectOrCreate?: ListCreateOrConnectWithoutSmsCampaignsInput | ListCreateOrConnectWithoutSmsCampaignsInput[]
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
  }

  export type SegmentUncheckedCreateNestedManyWithoutSmsCampaignsInput = {
    create?: XOR<SegmentCreateWithoutSmsCampaignsInput, SegmentUncheckedCreateWithoutSmsCampaignsInput> | SegmentCreateWithoutSmsCampaignsInput[] | SegmentUncheckedCreateWithoutSmsCampaignsInput[]
    connectOrCreate?: SegmentCreateOrConnectWithoutSmsCampaignsInput | SegmentCreateOrConnectWithoutSmsCampaignsInput[]
    connect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
  }

  export type SMSActivityUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<SMSActivityCreateWithoutCampaignInput, SMSActivityUncheckedCreateWithoutCampaignInput> | SMSActivityCreateWithoutCampaignInput[] | SMSActivityUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SMSActivityCreateOrConnectWithoutCampaignInput | SMSActivityCreateOrConnectWithoutCampaignInput[]
    createMany?: SMSActivityCreateManyCampaignInputEnvelope
    connect?: SMSActivityWhereUniqueInput | SMSActivityWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSmsCampaignsNestedInput = {
    create?: XOR<UserCreateWithoutSmsCampaignsInput, UserUncheckedCreateWithoutSmsCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSmsCampaignsInput
    upsert?: UserUpsertWithoutSmsCampaignsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSmsCampaignsInput, UserUpdateWithoutSmsCampaignsInput>, UserUncheckedUpdateWithoutSmsCampaignsInput>
  }

  export type SMSTemplateUpdateOneWithoutCampaignsNestedInput = {
    create?: XOR<SMSTemplateCreateWithoutCampaignsInput, SMSTemplateUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: SMSTemplateCreateOrConnectWithoutCampaignsInput
    upsert?: SMSTemplateUpsertWithoutCampaignsInput
    disconnect?: SMSTemplateWhereInput | boolean
    delete?: SMSTemplateWhereInput | boolean
    connect?: SMSTemplateWhereUniqueInput
    update?: XOR<XOR<SMSTemplateUpdateToOneWithWhereWithoutCampaignsInput, SMSTemplateUpdateWithoutCampaignsInput>, SMSTemplateUncheckedUpdateWithoutCampaignsInput>
  }

  export type ListUpdateManyWithoutSmsCampaignsNestedInput = {
    create?: XOR<ListCreateWithoutSmsCampaignsInput, ListUncheckedCreateWithoutSmsCampaignsInput> | ListCreateWithoutSmsCampaignsInput[] | ListUncheckedCreateWithoutSmsCampaignsInput[]
    connectOrCreate?: ListCreateOrConnectWithoutSmsCampaignsInput | ListCreateOrConnectWithoutSmsCampaignsInput[]
    upsert?: ListUpsertWithWhereUniqueWithoutSmsCampaignsInput | ListUpsertWithWhereUniqueWithoutSmsCampaignsInput[]
    set?: ListWhereUniqueInput | ListWhereUniqueInput[]
    disconnect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    delete?: ListWhereUniqueInput | ListWhereUniqueInput[]
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    update?: ListUpdateWithWhereUniqueWithoutSmsCampaignsInput | ListUpdateWithWhereUniqueWithoutSmsCampaignsInput[]
    updateMany?: ListUpdateManyWithWhereWithoutSmsCampaignsInput | ListUpdateManyWithWhereWithoutSmsCampaignsInput[]
    deleteMany?: ListScalarWhereInput | ListScalarWhereInput[]
  }

  export type SegmentUpdateManyWithoutSmsCampaignsNestedInput = {
    create?: XOR<SegmentCreateWithoutSmsCampaignsInput, SegmentUncheckedCreateWithoutSmsCampaignsInput> | SegmentCreateWithoutSmsCampaignsInput[] | SegmentUncheckedCreateWithoutSmsCampaignsInput[]
    connectOrCreate?: SegmentCreateOrConnectWithoutSmsCampaignsInput | SegmentCreateOrConnectWithoutSmsCampaignsInput[]
    upsert?: SegmentUpsertWithWhereUniqueWithoutSmsCampaignsInput | SegmentUpsertWithWhereUniqueWithoutSmsCampaignsInput[]
    set?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    disconnect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    delete?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    connect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    update?: SegmentUpdateWithWhereUniqueWithoutSmsCampaignsInput | SegmentUpdateWithWhereUniqueWithoutSmsCampaignsInput[]
    updateMany?: SegmentUpdateManyWithWhereWithoutSmsCampaignsInput | SegmentUpdateManyWithWhereWithoutSmsCampaignsInput[]
    deleteMany?: SegmentScalarWhereInput | SegmentScalarWhereInput[]
  }

  export type SMSActivityUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<SMSActivityCreateWithoutCampaignInput, SMSActivityUncheckedCreateWithoutCampaignInput> | SMSActivityCreateWithoutCampaignInput[] | SMSActivityUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SMSActivityCreateOrConnectWithoutCampaignInput | SMSActivityCreateOrConnectWithoutCampaignInput[]
    upsert?: SMSActivityUpsertWithWhereUniqueWithoutCampaignInput | SMSActivityUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: SMSActivityCreateManyCampaignInputEnvelope
    set?: SMSActivityWhereUniqueInput | SMSActivityWhereUniqueInput[]
    disconnect?: SMSActivityWhereUniqueInput | SMSActivityWhereUniqueInput[]
    delete?: SMSActivityWhereUniqueInput | SMSActivityWhereUniqueInput[]
    connect?: SMSActivityWhereUniqueInput | SMSActivityWhereUniqueInput[]
    update?: SMSActivityUpdateWithWhereUniqueWithoutCampaignInput | SMSActivityUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: SMSActivityUpdateManyWithWhereWithoutCampaignInput | SMSActivityUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: SMSActivityScalarWhereInput | SMSActivityScalarWhereInput[]
  }

  export type ListUncheckedUpdateManyWithoutSmsCampaignsNestedInput = {
    create?: XOR<ListCreateWithoutSmsCampaignsInput, ListUncheckedCreateWithoutSmsCampaignsInput> | ListCreateWithoutSmsCampaignsInput[] | ListUncheckedCreateWithoutSmsCampaignsInput[]
    connectOrCreate?: ListCreateOrConnectWithoutSmsCampaignsInput | ListCreateOrConnectWithoutSmsCampaignsInput[]
    upsert?: ListUpsertWithWhereUniqueWithoutSmsCampaignsInput | ListUpsertWithWhereUniqueWithoutSmsCampaignsInput[]
    set?: ListWhereUniqueInput | ListWhereUniqueInput[]
    disconnect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    delete?: ListWhereUniqueInput | ListWhereUniqueInput[]
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    update?: ListUpdateWithWhereUniqueWithoutSmsCampaignsInput | ListUpdateWithWhereUniqueWithoutSmsCampaignsInput[]
    updateMany?: ListUpdateManyWithWhereWithoutSmsCampaignsInput | ListUpdateManyWithWhereWithoutSmsCampaignsInput[]
    deleteMany?: ListScalarWhereInput | ListScalarWhereInput[]
  }

  export type SegmentUncheckedUpdateManyWithoutSmsCampaignsNestedInput = {
    create?: XOR<SegmentCreateWithoutSmsCampaignsInput, SegmentUncheckedCreateWithoutSmsCampaignsInput> | SegmentCreateWithoutSmsCampaignsInput[] | SegmentUncheckedCreateWithoutSmsCampaignsInput[]
    connectOrCreate?: SegmentCreateOrConnectWithoutSmsCampaignsInput | SegmentCreateOrConnectWithoutSmsCampaignsInput[]
    upsert?: SegmentUpsertWithWhereUniqueWithoutSmsCampaignsInput | SegmentUpsertWithWhereUniqueWithoutSmsCampaignsInput[]
    set?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    disconnect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    delete?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    connect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    update?: SegmentUpdateWithWhereUniqueWithoutSmsCampaignsInput | SegmentUpdateWithWhereUniqueWithoutSmsCampaignsInput[]
    updateMany?: SegmentUpdateManyWithWhereWithoutSmsCampaignsInput | SegmentUpdateManyWithWhereWithoutSmsCampaignsInput[]
    deleteMany?: SegmentScalarWhereInput | SegmentScalarWhereInput[]
  }

  export type SMSActivityUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<SMSActivityCreateWithoutCampaignInput, SMSActivityUncheckedCreateWithoutCampaignInput> | SMSActivityCreateWithoutCampaignInput[] | SMSActivityUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SMSActivityCreateOrConnectWithoutCampaignInput | SMSActivityCreateOrConnectWithoutCampaignInput[]
    upsert?: SMSActivityUpsertWithWhereUniqueWithoutCampaignInput | SMSActivityUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: SMSActivityCreateManyCampaignInputEnvelope
    set?: SMSActivityWhereUniqueInput | SMSActivityWhereUniqueInput[]
    disconnect?: SMSActivityWhereUniqueInput | SMSActivityWhereUniqueInput[]
    delete?: SMSActivityWhereUniqueInput | SMSActivityWhereUniqueInput[]
    connect?: SMSActivityWhereUniqueInput | SMSActivityWhereUniqueInput[]
    update?: SMSActivityUpdateWithWhereUniqueWithoutCampaignInput | SMSActivityUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: SMSActivityUpdateManyWithWhereWithoutCampaignInput | SMSActivityUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: SMSActivityScalarWhereInput | SMSActivityScalarWhereInput[]
  }

  export type SMSCampaignCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<SMSCampaignCreateWithoutActivitiesInput, SMSCampaignUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: SMSCampaignCreateOrConnectWithoutActivitiesInput
    connect?: SMSCampaignWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutSmsActivitiesInput = {
    create?: XOR<ContactCreateWithoutSmsActivitiesInput, ContactUncheckedCreateWithoutSmsActivitiesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutSmsActivitiesInput
    connect?: ContactWhereUniqueInput
  }

  export type SMSCampaignUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<SMSCampaignCreateWithoutActivitiesInput, SMSCampaignUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: SMSCampaignCreateOrConnectWithoutActivitiesInput
    upsert?: SMSCampaignUpsertWithoutActivitiesInput
    connect?: SMSCampaignWhereUniqueInput
    update?: XOR<XOR<SMSCampaignUpdateToOneWithWhereWithoutActivitiesInput, SMSCampaignUpdateWithoutActivitiesInput>, SMSCampaignUncheckedUpdateWithoutActivitiesInput>
  }

  export type ContactUpdateOneRequiredWithoutSmsActivitiesNestedInput = {
    create?: XOR<ContactCreateWithoutSmsActivitiesInput, ContactUncheckedCreateWithoutSmsActivitiesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutSmsActivitiesInput
    upsert?: ContactUpsertWithoutSmsActivitiesInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutSmsActivitiesInput, ContactUpdateWithoutSmsActivitiesInput>, ContactUncheckedUpdateWithoutSmsActivitiesInput>
  }

  export type UserCreateNestedOneWithoutWaTemplatesInput = {
    create?: XOR<UserCreateWithoutWaTemplatesInput, UserUncheckedCreateWithoutWaTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWaTemplatesInput
    connect?: UserWhereUniqueInput
  }

  export type WhatsAppCampaignCreateNestedManyWithoutTemplateInput = {
    create?: XOR<WhatsAppCampaignCreateWithoutTemplateInput, WhatsAppCampaignUncheckedCreateWithoutTemplateInput> | WhatsAppCampaignCreateWithoutTemplateInput[] | WhatsAppCampaignUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: WhatsAppCampaignCreateOrConnectWithoutTemplateInput | WhatsAppCampaignCreateOrConnectWithoutTemplateInput[]
    createMany?: WhatsAppCampaignCreateManyTemplateInputEnvelope
    connect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
  }

  export type WhatsAppCampaignUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<WhatsAppCampaignCreateWithoutTemplateInput, WhatsAppCampaignUncheckedCreateWithoutTemplateInput> | WhatsAppCampaignCreateWithoutTemplateInput[] | WhatsAppCampaignUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: WhatsAppCampaignCreateOrConnectWithoutTemplateInput | WhatsAppCampaignCreateOrConnectWithoutTemplateInput[]
    createMany?: WhatsAppCampaignCreateManyTemplateInputEnvelope
    connect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
  }

  export type EnumWATemplateStatusFieldUpdateOperationsInput = {
    set?: $Enums.WATemplateStatus
  }

  export type UserUpdateOneRequiredWithoutWaTemplatesNestedInput = {
    create?: XOR<UserCreateWithoutWaTemplatesInput, UserUncheckedCreateWithoutWaTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWaTemplatesInput
    upsert?: UserUpsertWithoutWaTemplatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWaTemplatesInput, UserUpdateWithoutWaTemplatesInput>, UserUncheckedUpdateWithoutWaTemplatesInput>
  }

  export type WhatsAppCampaignUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<WhatsAppCampaignCreateWithoutTemplateInput, WhatsAppCampaignUncheckedCreateWithoutTemplateInput> | WhatsAppCampaignCreateWithoutTemplateInput[] | WhatsAppCampaignUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: WhatsAppCampaignCreateOrConnectWithoutTemplateInput | WhatsAppCampaignCreateOrConnectWithoutTemplateInput[]
    upsert?: WhatsAppCampaignUpsertWithWhereUniqueWithoutTemplateInput | WhatsAppCampaignUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: WhatsAppCampaignCreateManyTemplateInputEnvelope
    set?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    disconnect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    delete?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    connect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    update?: WhatsAppCampaignUpdateWithWhereUniqueWithoutTemplateInput | WhatsAppCampaignUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: WhatsAppCampaignUpdateManyWithWhereWithoutTemplateInput | WhatsAppCampaignUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: WhatsAppCampaignScalarWhereInput | WhatsAppCampaignScalarWhereInput[]
  }

  export type WhatsAppCampaignUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<WhatsAppCampaignCreateWithoutTemplateInput, WhatsAppCampaignUncheckedCreateWithoutTemplateInput> | WhatsAppCampaignCreateWithoutTemplateInput[] | WhatsAppCampaignUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: WhatsAppCampaignCreateOrConnectWithoutTemplateInput | WhatsAppCampaignCreateOrConnectWithoutTemplateInput[]
    upsert?: WhatsAppCampaignUpsertWithWhereUniqueWithoutTemplateInput | WhatsAppCampaignUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: WhatsAppCampaignCreateManyTemplateInputEnvelope
    set?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    disconnect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    delete?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    connect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    update?: WhatsAppCampaignUpdateWithWhereUniqueWithoutTemplateInput | WhatsAppCampaignUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: WhatsAppCampaignUpdateManyWithWhereWithoutTemplateInput | WhatsAppCampaignUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: WhatsAppCampaignScalarWhereInput | WhatsAppCampaignScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutWaCampaignsInput = {
    create?: XOR<UserCreateWithoutWaCampaignsInput, UserUncheckedCreateWithoutWaCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWaCampaignsInput
    connect?: UserWhereUniqueInput
  }

  export type WhatsAppTemplateCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<WhatsAppTemplateCreateWithoutCampaignsInput, WhatsAppTemplateUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: WhatsAppTemplateCreateOrConnectWithoutCampaignsInput
    connect?: WhatsAppTemplateWhereUniqueInput
  }

  export type ListCreateNestedManyWithoutWaCampaignsInput = {
    create?: XOR<ListCreateWithoutWaCampaignsInput, ListUncheckedCreateWithoutWaCampaignsInput> | ListCreateWithoutWaCampaignsInput[] | ListUncheckedCreateWithoutWaCampaignsInput[]
    connectOrCreate?: ListCreateOrConnectWithoutWaCampaignsInput | ListCreateOrConnectWithoutWaCampaignsInput[]
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
  }

  export type SegmentCreateNestedManyWithoutWaCampaignsInput = {
    create?: XOR<SegmentCreateWithoutWaCampaignsInput, SegmentUncheckedCreateWithoutWaCampaignsInput> | SegmentCreateWithoutWaCampaignsInput[] | SegmentUncheckedCreateWithoutWaCampaignsInput[]
    connectOrCreate?: SegmentCreateOrConnectWithoutWaCampaignsInput | SegmentCreateOrConnectWithoutWaCampaignsInput[]
    connect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
  }

  export type WhatsAppActivityCreateNestedManyWithoutCampaignInput = {
    create?: XOR<WhatsAppActivityCreateWithoutCampaignInput, WhatsAppActivityUncheckedCreateWithoutCampaignInput> | WhatsAppActivityCreateWithoutCampaignInput[] | WhatsAppActivityUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: WhatsAppActivityCreateOrConnectWithoutCampaignInput | WhatsAppActivityCreateOrConnectWithoutCampaignInput[]
    createMany?: WhatsAppActivityCreateManyCampaignInputEnvelope
    connect?: WhatsAppActivityWhereUniqueInput | WhatsAppActivityWhereUniqueInput[]
  }

  export type ListUncheckedCreateNestedManyWithoutWaCampaignsInput = {
    create?: XOR<ListCreateWithoutWaCampaignsInput, ListUncheckedCreateWithoutWaCampaignsInput> | ListCreateWithoutWaCampaignsInput[] | ListUncheckedCreateWithoutWaCampaignsInput[]
    connectOrCreate?: ListCreateOrConnectWithoutWaCampaignsInput | ListCreateOrConnectWithoutWaCampaignsInput[]
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
  }

  export type SegmentUncheckedCreateNestedManyWithoutWaCampaignsInput = {
    create?: XOR<SegmentCreateWithoutWaCampaignsInput, SegmentUncheckedCreateWithoutWaCampaignsInput> | SegmentCreateWithoutWaCampaignsInput[] | SegmentUncheckedCreateWithoutWaCampaignsInput[]
    connectOrCreate?: SegmentCreateOrConnectWithoutWaCampaignsInput | SegmentCreateOrConnectWithoutWaCampaignsInput[]
    connect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
  }

  export type WhatsAppActivityUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<WhatsAppActivityCreateWithoutCampaignInput, WhatsAppActivityUncheckedCreateWithoutCampaignInput> | WhatsAppActivityCreateWithoutCampaignInput[] | WhatsAppActivityUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: WhatsAppActivityCreateOrConnectWithoutCampaignInput | WhatsAppActivityCreateOrConnectWithoutCampaignInput[]
    createMany?: WhatsAppActivityCreateManyCampaignInputEnvelope
    connect?: WhatsAppActivityWhereUniqueInput | WhatsAppActivityWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutWaCampaignsNestedInput = {
    create?: XOR<UserCreateWithoutWaCampaignsInput, UserUncheckedCreateWithoutWaCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWaCampaignsInput
    upsert?: UserUpsertWithoutWaCampaignsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWaCampaignsInput, UserUpdateWithoutWaCampaignsInput>, UserUncheckedUpdateWithoutWaCampaignsInput>
  }

  export type WhatsAppTemplateUpdateOneWithoutCampaignsNestedInput = {
    create?: XOR<WhatsAppTemplateCreateWithoutCampaignsInput, WhatsAppTemplateUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: WhatsAppTemplateCreateOrConnectWithoutCampaignsInput
    upsert?: WhatsAppTemplateUpsertWithoutCampaignsInput
    disconnect?: WhatsAppTemplateWhereInput | boolean
    delete?: WhatsAppTemplateWhereInput | boolean
    connect?: WhatsAppTemplateWhereUniqueInput
    update?: XOR<XOR<WhatsAppTemplateUpdateToOneWithWhereWithoutCampaignsInput, WhatsAppTemplateUpdateWithoutCampaignsInput>, WhatsAppTemplateUncheckedUpdateWithoutCampaignsInput>
  }

  export type ListUpdateManyWithoutWaCampaignsNestedInput = {
    create?: XOR<ListCreateWithoutWaCampaignsInput, ListUncheckedCreateWithoutWaCampaignsInput> | ListCreateWithoutWaCampaignsInput[] | ListUncheckedCreateWithoutWaCampaignsInput[]
    connectOrCreate?: ListCreateOrConnectWithoutWaCampaignsInput | ListCreateOrConnectWithoutWaCampaignsInput[]
    upsert?: ListUpsertWithWhereUniqueWithoutWaCampaignsInput | ListUpsertWithWhereUniqueWithoutWaCampaignsInput[]
    set?: ListWhereUniqueInput | ListWhereUniqueInput[]
    disconnect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    delete?: ListWhereUniqueInput | ListWhereUniqueInput[]
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    update?: ListUpdateWithWhereUniqueWithoutWaCampaignsInput | ListUpdateWithWhereUniqueWithoutWaCampaignsInput[]
    updateMany?: ListUpdateManyWithWhereWithoutWaCampaignsInput | ListUpdateManyWithWhereWithoutWaCampaignsInput[]
    deleteMany?: ListScalarWhereInput | ListScalarWhereInput[]
  }

  export type SegmentUpdateManyWithoutWaCampaignsNestedInput = {
    create?: XOR<SegmentCreateWithoutWaCampaignsInput, SegmentUncheckedCreateWithoutWaCampaignsInput> | SegmentCreateWithoutWaCampaignsInput[] | SegmentUncheckedCreateWithoutWaCampaignsInput[]
    connectOrCreate?: SegmentCreateOrConnectWithoutWaCampaignsInput | SegmentCreateOrConnectWithoutWaCampaignsInput[]
    upsert?: SegmentUpsertWithWhereUniqueWithoutWaCampaignsInput | SegmentUpsertWithWhereUniqueWithoutWaCampaignsInput[]
    set?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    disconnect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    delete?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    connect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    update?: SegmentUpdateWithWhereUniqueWithoutWaCampaignsInput | SegmentUpdateWithWhereUniqueWithoutWaCampaignsInput[]
    updateMany?: SegmentUpdateManyWithWhereWithoutWaCampaignsInput | SegmentUpdateManyWithWhereWithoutWaCampaignsInput[]
    deleteMany?: SegmentScalarWhereInput | SegmentScalarWhereInput[]
  }

  export type WhatsAppActivityUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<WhatsAppActivityCreateWithoutCampaignInput, WhatsAppActivityUncheckedCreateWithoutCampaignInput> | WhatsAppActivityCreateWithoutCampaignInput[] | WhatsAppActivityUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: WhatsAppActivityCreateOrConnectWithoutCampaignInput | WhatsAppActivityCreateOrConnectWithoutCampaignInput[]
    upsert?: WhatsAppActivityUpsertWithWhereUniqueWithoutCampaignInput | WhatsAppActivityUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: WhatsAppActivityCreateManyCampaignInputEnvelope
    set?: WhatsAppActivityWhereUniqueInput | WhatsAppActivityWhereUniqueInput[]
    disconnect?: WhatsAppActivityWhereUniqueInput | WhatsAppActivityWhereUniqueInput[]
    delete?: WhatsAppActivityWhereUniqueInput | WhatsAppActivityWhereUniqueInput[]
    connect?: WhatsAppActivityWhereUniqueInput | WhatsAppActivityWhereUniqueInput[]
    update?: WhatsAppActivityUpdateWithWhereUniqueWithoutCampaignInput | WhatsAppActivityUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: WhatsAppActivityUpdateManyWithWhereWithoutCampaignInput | WhatsAppActivityUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: WhatsAppActivityScalarWhereInput | WhatsAppActivityScalarWhereInput[]
  }

  export type ListUncheckedUpdateManyWithoutWaCampaignsNestedInput = {
    create?: XOR<ListCreateWithoutWaCampaignsInput, ListUncheckedCreateWithoutWaCampaignsInput> | ListCreateWithoutWaCampaignsInput[] | ListUncheckedCreateWithoutWaCampaignsInput[]
    connectOrCreate?: ListCreateOrConnectWithoutWaCampaignsInput | ListCreateOrConnectWithoutWaCampaignsInput[]
    upsert?: ListUpsertWithWhereUniqueWithoutWaCampaignsInput | ListUpsertWithWhereUniqueWithoutWaCampaignsInput[]
    set?: ListWhereUniqueInput | ListWhereUniqueInput[]
    disconnect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    delete?: ListWhereUniqueInput | ListWhereUniqueInput[]
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    update?: ListUpdateWithWhereUniqueWithoutWaCampaignsInput | ListUpdateWithWhereUniqueWithoutWaCampaignsInput[]
    updateMany?: ListUpdateManyWithWhereWithoutWaCampaignsInput | ListUpdateManyWithWhereWithoutWaCampaignsInput[]
    deleteMany?: ListScalarWhereInput | ListScalarWhereInput[]
  }

  export type SegmentUncheckedUpdateManyWithoutWaCampaignsNestedInput = {
    create?: XOR<SegmentCreateWithoutWaCampaignsInput, SegmentUncheckedCreateWithoutWaCampaignsInput> | SegmentCreateWithoutWaCampaignsInput[] | SegmentUncheckedCreateWithoutWaCampaignsInput[]
    connectOrCreate?: SegmentCreateOrConnectWithoutWaCampaignsInput | SegmentCreateOrConnectWithoutWaCampaignsInput[]
    upsert?: SegmentUpsertWithWhereUniqueWithoutWaCampaignsInput | SegmentUpsertWithWhereUniqueWithoutWaCampaignsInput[]
    set?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    disconnect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    delete?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    connect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    update?: SegmentUpdateWithWhereUniqueWithoutWaCampaignsInput | SegmentUpdateWithWhereUniqueWithoutWaCampaignsInput[]
    updateMany?: SegmentUpdateManyWithWhereWithoutWaCampaignsInput | SegmentUpdateManyWithWhereWithoutWaCampaignsInput[]
    deleteMany?: SegmentScalarWhereInput | SegmentScalarWhereInput[]
  }

  export type WhatsAppActivityUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<WhatsAppActivityCreateWithoutCampaignInput, WhatsAppActivityUncheckedCreateWithoutCampaignInput> | WhatsAppActivityCreateWithoutCampaignInput[] | WhatsAppActivityUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: WhatsAppActivityCreateOrConnectWithoutCampaignInput | WhatsAppActivityCreateOrConnectWithoutCampaignInput[]
    upsert?: WhatsAppActivityUpsertWithWhereUniqueWithoutCampaignInput | WhatsAppActivityUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: WhatsAppActivityCreateManyCampaignInputEnvelope
    set?: WhatsAppActivityWhereUniqueInput | WhatsAppActivityWhereUniqueInput[]
    disconnect?: WhatsAppActivityWhereUniqueInput | WhatsAppActivityWhereUniqueInput[]
    delete?: WhatsAppActivityWhereUniqueInput | WhatsAppActivityWhereUniqueInput[]
    connect?: WhatsAppActivityWhereUniqueInput | WhatsAppActivityWhereUniqueInput[]
    update?: WhatsAppActivityUpdateWithWhereUniqueWithoutCampaignInput | WhatsAppActivityUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: WhatsAppActivityUpdateManyWithWhereWithoutCampaignInput | WhatsAppActivityUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: WhatsAppActivityScalarWhereInput | WhatsAppActivityScalarWhereInput[]
  }

  export type WhatsAppCampaignCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<WhatsAppCampaignCreateWithoutActivitiesInput, WhatsAppCampaignUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: WhatsAppCampaignCreateOrConnectWithoutActivitiesInput
    connect?: WhatsAppCampaignWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutWaActivitiesInput = {
    create?: XOR<ContactCreateWithoutWaActivitiesInput, ContactUncheckedCreateWithoutWaActivitiesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutWaActivitiesInput
    connect?: ContactWhereUniqueInput
  }

  export type WhatsAppCampaignUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<WhatsAppCampaignCreateWithoutActivitiesInput, WhatsAppCampaignUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: WhatsAppCampaignCreateOrConnectWithoutActivitiesInput
    upsert?: WhatsAppCampaignUpsertWithoutActivitiesInput
    connect?: WhatsAppCampaignWhereUniqueInput
    update?: XOR<XOR<WhatsAppCampaignUpdateToOneWithWhereWithoutActivitiesInput, WhatsAppCampaignUpdateWithoutActivitiesInput>, WhatsAppCampaignUncheckedUpdateWithoutActivitiesInput>
  }

  export type ContactUpdateOneRequiredWithoutWaActivitiesNestedInput = {
    create?: XOR<ContactCreateWithoutWaActivitiesInput, ContactUncheckedCreateWithoutWaActivitiesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutWaActivitiesInput
    upsert?: ContactUpsertWithoutWaActivitiesInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutWaActivitiesInput, ContactUpdateWithoutWaActivitiesInput>, ContactUncheckedUpdateWithoutWaActivitiesInput>
  }

  export type UserCreateNestedOneWithoutWorkflowsInput = {
    create?: XOR<UserCreateWithoutWorkflowsInput, UserUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkflowsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkflowNodeCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<WorkflowNodeCreateWithoutWorkflowInput, WorkflowNodeUncheckedCreateWithoutWorkflowInput> | WorkflowNodeCreateWithoutWorkflowInput[] | WorkflowNodeUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowNodeCreateOrConnectWithoutWorkflowInput | WorkflowNodeCreateOrConnectWithoutWorkflowInput[]
    createMany?: WorkflowNodeCreateManyWorkflowInputEnvelope
    connect?: WorkflowNodeWhereUniqueInput | WorkflowNodeWhereUniqueInput[]
  }

  export type WorkflowTriggerCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<WorkflowTriggerCreateWithoutWorkflowInput, WorkflowTriggerUncheckedCreateWithoutWorkflowInput> | WorkflowTriggerCreateWithoutWorkflowInput[] | WorkflowTriggerUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowTriggerCreateOrConnectWithoutWorkflowInput | WorkflowTriggerCreateOrConnectWithoutWorkflowInput[]
    createMany?: WorkflowTriggerCreateManyWorkflowInputEnvelope
    connect?: WorkflowTriggerWhereUniqueInput | WorkflowTriggerWhereUniqueInput[]
  }

  export type WorkflowNodeUncheckedCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<WorkflowNodeCreateWithoutWorkflowInput, WorkflowNodeUncheckedCreateWithoutWorkflowInput> | WorkflowNodeCreateWithoutWorkflowInput[] | WorkflowNodeUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowNodeCreateOrConnectWithoutWorkflowInput | WorkflowNodeCreateOrConnectWithoutWorkflowInput[]
    createMany?: WorkflowNodeCreateManyWorkflowInputEnvelope
    connect?: WorkflowNodeWhereUniqueInput | WorkflowNodeWhereUniqueInput[]
  }

  export type WorkflowTriggerUncheckedCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<WorkflowTriggerCreateWithoutWorkflowInput, WorkflowTriggerUncheckedCreateWithoutWorkflowInput> | WorkflowTriggerCreateWithoutWorkflowInput[] | WorkflowTriggerUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowTriggerCreateOrConnectWithoutWorkflowInput | WorkflowTriggerCreateOrConnectWithoutWorkflowInput[]
    createMany?: WorkflowTriggerCreateManyWorkflowInputEnvelope
    connect?: WorkflowTriggerWhereUniqueInput | WorkflowTriggerWhereUniqueInput[]
  }

  export type EnumWorkflowStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkflowStatus
  }

  export type UserUpdateOneRequiredWithoutWorkflowsNestedInput = {
    create?: XOR<UserCreateWithoutWorkflowsInput, UserUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkflowsInput
    upsert?: UserUpsertWithoutWorkflowsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkflowsInput, UserUpdateWithoutWorkflowsInput>, UserUncheckedUpdateWithoutWorkflowsInput>
  }

  export type WorkflowNodeUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<WorkflowNodeCreateWithoutWorkflowInput, WorkflowNodeUncheckedCreateWithoutWorkflowInput> | WorkflowNodeCreateWithoutWorkflowInput[] | WorkflowNodeUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowNodeCreateOrConnectWithoutWorkflowInput | WorkflowNodeCreateOrConnectWithoutWorkflowInput[]
    upsert?: WorkflowNodeUpsertWithWhereUniqueWithoutWorkflowInput | WorkflowNodeUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: WorkflowNodeCreateManyWorkflowInputEnvelope
    set?: WorkflowNodeWhereUniqueInput | WorkflowNodeWhereUniqueInput[]
    disconnect?: WorkflowNodeWhereUniqueInput | WorkflowNodeWhereUniqueInput[]
    delete?: WorkflowNodeWhereUniqueInput | WorkflowNodeWhereUniqueInput[]
    connect?: WorkflowNodeWhereUniqueInput | WorkflowNodeWhereUniqueInput[]
    update?: WorkflowNodeUpdateWithWhereUniqueWithoutWorkflowInput | WorkflowNodeUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: WorkflowNodeUpdateManyWithWhereWithoutWorkflowInput | WorkflowNodeUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: WorkflowNodeScalarWhereInput | WorkflowNodeScalarWhereInput[]
  }

  export type WorkflowTriggerUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<WorkflowTriggerCreateWithoutWorkflowInput, WorkflowTriggerUncheckedCreateWithoutWorkflowInput> | WorkflowTriggerCreateWithoutWorkflowInput[] | WorkflowTriggerUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowTriggerCreateOrConnectWithoutWorkflowInput | WorkflowTriggerCreateOrConnectWithoutWorkflowInput[]
    upsert?: WorkflowTriggerUpsertWithWhereUniqueWithoutWorkflowInput | WorkflowTriggerUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: WorkflowTriggerCreateManyWorkflowInputEnvelope
    set?: WorkflowTriggerWhereUniqueInput | WorkflowTriggerWhereUniqueInput[]
    disconnect?: WorkflowTriggerWhereUniqueInput | WorkflowTriggerWhereUniqueInput[]
    delete?: WorkflowTriggerWhereUniqueInput | WorkflowTriggerWhereUniqueInput[]
    connect?: WorkflowTriggerWhereUniqueInput | WorkflowTriggerWhereUniqueInput[]
    update?: WorkflowTriggerUpdateWithWhereUniqueWithoutWorkflowInput | WorkflowTriggerUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: WorkflowTriggerUpdateManyWithWhereWithoutWorkflowInput | WorkflowTriggerUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: WorkflowTriggerScalarWhereInput | WorkflowTriggerScalarWhereInput[]
  }

  export type WorkflowNodeUncheckedUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<WorkflowNodeCreateWithoutWorkflowInput, WorkflowNodeUncheckedCreateWithoutWorkflowInput> | WorkflowNodeCreateWithoutWorkflowInput[] | WorkflowNodeUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowNodeCreateOrConnectWithoutWorkflowInput | WorkflowNodeCreateOrConnectWithoutWorkflowInput[]
    upsert?: WorkflowNodeUpsertWithWhereUniqueWithoutWorkflowInput | WorkflowNodeUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: WorkflowNodeCreateManyWorkflowInputEnvelope
    set?: WorkflowNodeWhereUniqueInput | WorkflowNodeWhereUniqueInput[]
    disconnect?: WorkflowNodeWhereUniqueInput | WorkflowNodeWhereUniqueInput[]
    delete?: WorkflowNodeWhereUniqueInput | WorkflowNodeWhereUniqueInput[]
    connect?: WorkflowNodeWhereUniqueInput | WorkflowNodeWhereUniqueInput[]
    update?: WorkflowNodeUpdateWithWhereUniqueWithoutWorkflowInput | WorkflowNodeUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: WorkflowNodeUpdateManyWithWhereWithoutWorkflowInput | WorkflowNodeUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: WorkflowNodeScalarWhereInput | WorkflowNodeScalarWhereInput[]
  }

  export type WorkflowTriggerUncheckedUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<WorkflowTriggerCreateWithoutWorkflowInput, WorkflowTriggerUncheckedCreateWithoutWorkflowInput> | WorkflowTriggerCreateWithoutWorkflowInput[] | WorkflowTriggerUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowTriggerCreateOrConnectWithoutWorkflowInput | WorkflowTriggerCreateOrConnectWithoutWorkflowInput[]
    upsert?: WorkflowTriggerUpsertWithWhereUniqueWithoutWorkflowInput | WorkflowTriggerUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: WorkflowTriggerCreateManyWorkflowInputEnvelope
    set?: WorkflowTriggerWhereUniqueInput | WorkflowTriggerWhereUniqueInput[]
    disconnect?: WorkflowTriggerWhereUniqueInput | WorkflowTriggerWhereUniqueInput[]
    delete?: WorkflowTriggerWhereUniqueInput | WorkflowTriggerWhereUniqueInput[]
    connect?: WorkflowTriggerWhereUniqueInput | WorkflowTriggerWhereUniqueInput[]
    update?: WorkflowTriggerUpdateWithWhereUniqueWithoutWorkflowInput | WorkflowTriggerUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: WorkflowTriggerUpdateManyWithWhereWithoutWorkflowInput | WorkflowTriggerUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: WorkflowTriggerScalarWhereInput | WorkflowTriggerScalarWhereInput[]
  }

  export type WorkflowCreateNestedOneWithoutNodesInput = {
    create?: XOR<WorkflowCreateWithoutNodesInput, WorkflowUncheckedCreateWithoutNodesInput>
    connectOrCreate?: WorkflowCreateOrConnectWithoutNodesInput
    connect?: WorkflowWhereUniqueInput
  }

  export type ConnectionCreateNestedManyWithoutSourceInput = {
    create?: XOR<ConnectionCreateWithoutSourceInput, ConnectionUncheckedCreateWithoutSourceInput> | ConnectionCreateWithoutSourceInput[] | ConnectionUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutSourceInput | ConnectionCreateOrConnectWithoutSourceInput[]
    createMany?: ConnectionCreateManySourceInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type ConnectionCreateNestedManyWithoutTargetInput = {
    create?: XOR<ConnectionCreateWithoutTargetInput, ConnectionUncheckedCreateWithoutTargetInput> | ConnectionCreateWithoutTargetInput[] | ConnectionUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutTargetInput | ConnectionCreateOrConnectWithoutTargetInput[]
    createMany?: ConnectionCreateManyTargetInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type ConnectionUncheckedCreateNestedManyWithoutSourceInput = {
    create?: XOR<ConnectionCreateWithoutSourceInput, ConnectionUncheckedCreateWithoutSourceInput> | ConnectionCreateWithoutSourceInput[] | ConnectionUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutSourceInput | ConnectionCreateOrConnectWithoutSourceInput[]
    createMany?: ConnectionCreateManySourceInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type ConnectionUncheckedCreateNestedManyWithoutTargetInput = {
    create?: XOR<ConnectionCreateWithoutTargetInput, ConnectionUncheckedCreateWithoutTargetInput> | ConnectionCreateWithoutTargetInput[] | ConnectionUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutTargetInput | ConnectionCreateOrConnectWithoutTargetInput[]
    createMany?: ConnectionCreateManyTargetInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type EnumWorkflowNodeTypeFieldUpdateOperationsInput = {
    set?: $Enums.WorkflowNodeType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WorkflowUpdateOneRequiredWithoutNodesNestedInput = {
    create?: XOR<WorkflowCreateWithoutNodesInput, WorkflowUncheckedCreateWithoutNodesInput>
    connectOrCreate?: WorkflowCreateOrConnectWithoutNodesInput
    upsert?: WorkflowUpsertWithoutNodesInput
    connect?: WorkflowWhereUniqueInput
    update?: XOR<XOR<WorkflowUpdateToOneWithWhereWithoutNodesInput, WorkflowUpdateWithoutNodesInput>, WorkflowUncheckedUpdateWithoutNodesInput>
  }

  export type ConnectionUpdateManyWithoutSourceNestedInput = {
    create?: XOR<ConnectionCreateWithoutSourceInput, ConnectionUncheckedCreateWithoutSourceInput> | ConnectionCreateWithoutSourceInput[] | ConnectionUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutSourceInput | ConnectionCreateOrConnectWithoutSourceInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutSourceInput | ConnectionUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: ConnectionCreateManySourceInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutSourceInput | ConnectionUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutSourceInput | ConnectionUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type ConnectionUpdateManyWithoutTargetNestedInput = {
    create?: XOR<ConnectionCreateWithoutTargetInput, ConnectionUncheckedCreateWithoutTargetInput> | ConnectionCreateWithoutTargetInput[] | ConnectionUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutTargetInput | ConnectionCreateOrConnectWithoutTargetInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutTargetInput | ConnectionUpsertWithWhereUniqueWithoutTargetInput[]
    createMany?: ConnectionCreateManyTargetInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutTargetInput | ConnectionUpdateWithWhereUniqueWithoutTargetInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutTargetInput | ConnectionUpdateManyWithWhereWithoutTargetInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type ConnectionUncheckedUpdateManyWithoutSourceNestedInput = {
    create?: XOR<ConnectionCreateWithoutSourceInput, ConnectionUncheckedCreateWithoutSourceInput> | ConnectionCreateWithoutSourceInput[] | ConnectionUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutSourceInput | ConnectionCreateOrConnectWithoutSourceInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutSourceInput | ConnectionUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: ConnectionCreateManySourceInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutSourceInput | ConnectionUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutSourceInput | ConnectionUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type ConnectionUncheckedUpdateManyWithoutTargetNestedInput = {
    create?: XOR<ConnectionCreateWithoutTargetInput, ConnectionUncheckedCreateWithoutTargetInput> | ConnectionCreateWithoutTargetInput[] | ConnectionUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutTargetInput | ConnectionCreateOrConnectWithoutTargetInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutTargetInput | ConnectionUpsertWithWhereUniqueWithoutTargetInput[]
    createMany?: ConnectionCreateManyTargetInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutTargetInput | ConnectionUpdateWithWhereUniqueWithoutTargetInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutTargetInput | ConnectionUpdateManyWithWhereWithoutTargetInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type WorkflowNodeCreateNestedOneWithoutOutgoingInput = {
    create?: XOR<WorkflowNodeCreateWithoutOutgoingInput, WorkflowNodeUncheckedCreateWithoutOutgoingInput>
    connectOrCreate?: WorkflowNodeCreateOrConnectWithoutOutgoingInput
    connect?: WorkflowNodeWhereUniqueInput
  }

  export type WorkflowNodeCreateNestedOneWithoutIncomingInput = {
    create?: XOR<WorkflowNodeCreateWithoutIncomingInput, WorkflowNodeUncheckedCreateWithoutIncomingInput>
    connectOrCreate?: WorkflowNodeCreateOrConnectWithoutIncomingInput
    connect?: WorkflowNodeWhereUniqueInput
  }

  export type WorkflowNodeUpdateOneRequiredWithoutOutgoingNestedInput = {
    create?: XOR<WorkflowNodeCreateWithoutOutgoingInput, WorkflowNodeUncheckedCreateWithoutOutgoingInput>
    connectOrCreate?: WorkflowNodeCreateOrConnectWithoutOutgoingInput
    upsert?: WorkflowNodeUpsertWithoutOutgoingInput
    connect?: WorkflowNodeWhereUniqueInput
    update?: XOR<XOR<WorkflowNodeUpdateToOneWithWhereWithoutOutgoingInput, WorkflowNodeUpdateWithoutOutgoingInput>, WorkflowNodeUncheckedUpdateWithoutOutgoingInput>
  }

  export type WorkflowNodeUpdateOneRequiredWithoutIncomingNestedInput = {
    create?: XOR<WorkflowNodeCreateWithoutIncomingInput, WorkflowNodeUncheckedCreateWithoutIncomingInput>
    connectOrCreate?: WorkflowNodeCreateOrConnectWithoutIncomingInput
    upsert?: WorkflowNodeUpsertWithoutIncomingInput
    connect?: WorkflowNodeWhereUniqueInput
    update?: XOR<XOR<WorkflowNodeUpdateToOneWithWhereWithoutIncomingInput, WorkflowNodeUpdateWithoutIncomingInput>, WorkflowNodeUncheckedUpdateWithoutIncomingInput>
  }

  export type WorkflowCreateNestedOneWithoutTriggersInput = {
    create?: XOR<WorkflowCreateWithoutTriggersInput, WorkflowUncheckedCreateWithoutTriggersInput>
    connectOrCreate?: WorkflowCreateOrConnectWithoutTriggersInput
    connect?: WorkflowWhereUniqueInput
  }

  export type EnumTriggerTypeFieldUpdateOperationsInput = {
    set?: $Enums.TriggerType
  }

  export type WorkflowUpdateOneRequiredWithoutTriggersNestedInput = {
    create?: XOR<WorkflowCreateWithoutTriggersInput, WorkflowUncheckedCreateWithoutTriggersInput>
    connectOrCreate?: WorkflowCreateOrConnectWithoutTriggersInput
    upsert?: WorkflowUpsertWithoutTriggersInput
    connect?: WorkflowWhereUniqueInput
    update?: XOR<XOR<WorkflowUpdateToOneWithWhereWithoutTriggersInput, WorkflowUpdateWithoutTriggersInput>, WorkflowUncheckedUpdateWithoutTriggersInput>
  }

  export type EnumEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.EntityType
  }

  export type EnumAnalyticsPeriodFieldUpdateOperationsInput = {
    set?: $Enums.AnalyticsPeriod
  }

  export type EnumIntegrationTypeFieldUpdateOperationsInput = {
    set?: $Enums.IntegrationType
  }

  export type EnumConnectionStatusFieldUpdateOperationsInput = {
    set?: $Enums.ConnectionStatus
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumContactStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactStatus | EnumContactStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContactStatusFilter<$PrismaModel> | $Enums.ContactStatus
  }

  export type NestedEnumContactStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactStatus | EnumContactStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContactStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContactStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactStatusFilter<$PrismaModel>
    _max?: NestedEnumContactStatusFilter<$PrismaModel>
  }

  export type NestedEnumListTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ListType | EnumListTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ListType[] | ListEnumListTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListType[] | ListEnumListTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumListTypeFilter<$PrismaModel> | $Enums.ListType
  }

  export type NestedEnumListTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListType | EnumListTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ListType[] | ListEnumListTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListType[] | ListEnumListTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumListTypeWithAggregatesFilter<$PrismaModel> | $Enums.ListType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumListTypeFilter<$PrismaModel>
    _max?: NestedEnumListTypeFilter<$PrismaModel>
  }

  export type NestedEnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type NestedEnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type NestedEnumWATemplateStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WATemplateStatus | EnumWATemplateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WATemplateStatus[] | ListEnumWATemplateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WATemplateStatus[] | ListEnumWATemplateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWATemplateStatusFilter<$PrismaModel> | $Enums.WATemplateStatus
  }

  export type NestedEnumWATemplateStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WATemplateStatus | EnumWATemplateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WATemplateStatus[] | ListEnumWATemplateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WATemplateStatus[] | ListEnumWATemplateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWATemplateStatusWithAggregatesFilter<$PrismaModel> | $Enums.WATemplateStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWATemplateStatusFilter<$PrismaModel>
    _max?: NestedEnumWATemplateStatusFilter<$PrismaModel>
  }

  export type NestedEnumWorkflowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusFilter<$PrismaModel> | $Enums.WorkflowStatus
  }

  export type NestedEnumWorkflowStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkflowStatusFilter<$PrismaModel>
  }

  export type NestedEnumWorkflowNodeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowNodeType | EnumWorkflowNodeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowNodeType[] | ListEnumWorkflowNodeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowNodeType[] | ListEnumWorkflowNodeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowNodeTypeFilter<$PrismaModel> | $Enums.WorkflowNodeType
  }

  export type NestedEnumWorkflowNodeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowNodeType | EnumWorkflowNodeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowNodeType[] | ListEnumWorkflowNodeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowNodeType[] | ListEnumWorkflowNodeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowNodeTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowNodeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowNodeTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkflowNodeTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumTriggerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerType | EnumTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TriggerType[] | ListEnumTriggerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TriggerType[] | ListEnumTriggerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTriggerTypeFilter<$PrismaModel> | $Enums.TriggerType
  }

  export type NestedEnumTriggerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerType | EnumTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TriggerType[] | ListEnumTriggerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TriggerType[] | ListEnumTriggerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTriggerTypeWithAggregatesFilter<$PrismaModel> | $Enums.TriggerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTriggerTypeFilter<$PrismaModel>
    _max?: NestedEnumTriggerTypeFilter<$PrismaModel>
  }

  export type NestedEnumEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEntityTypeFilter<$PrismaModel> | $Enums.EntityType
  }

  export type NestedEnumAnalyticsPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalyticsPeriod | EnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.AnalyticsPeriod[] | ListEnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalyticsPeriod[] | ListEnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalyticsPeriodFilter<$PrismaModel> | $Enums.AnalyticsPeriod
  }

  export type NestedEnumEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.EntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumEntityTypeFilter<$PrismaModel>
  }

  export type NestedEnumAnalyticsPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalyticsPeriod | EnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.AnalyticsPeriod[] | ListEnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalyticsPeriod[] | ListEnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalyticsPeriodWithAggregatesFilter<$PrismaModel> | $Enums.AnalyticsPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnalyticsPeriodFilter<$PrismaModel>
    _max?: NestedEnumAnalyticsPeriodFilter<$PrismaModel>
  }

  export type NestedEnumIntegrationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationType | EnumIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationTypeFilter<$PrismaModel> | $Enums.IntegrationType
  }

  export type NestedEnumConnectionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConnectionStatus | EnumConnectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConnectionStatus[] | ListEnumConnectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConnectionStatus[] | ListEnumConnectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConnectionStatusFilter<$PrismaModel> | $Enums.ConnectionStatus
  }

  export type NestedEnumIntegrationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationType | EnumIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationTypeWithAggregatesFilter<$PrismaModel> | $Enums.IntegrationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIntegrationTypeFilter<$PrismaModel>
    _max?: NestedEnumIntegrationTypeFilter<$PrismaModel>
  }

  export type NestedEnumConnectionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConnectionStatus | EnumConnectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConnectionStatus[] | ListEnumConnectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConnectionStatus[] | ListEnumConnectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConnectionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConnectionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConnectionStatusFilter<$PrismaModel>
    _max?: NestedEnumConnectionStatusFilter<$PrismaModel>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutCreatedByInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    jobTitle?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    notes?: string | null
    tagsString?: string | null
    source?: string | null
    status?: $Enums.ContactStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    listMembers?: ListMemberCreateNestedManyWithoutContactInput
    emailActivities?: EmailActivityCreateNestedManyWithoutContactInput
    smsActivities?: SMSActivityCreateNestedManyWithoutContactInput
    waActivities?: WhatsAppActivityCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutCreatedByInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    jobTitle?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    notes?: string | null
    tagsString?: string | null
    source?: string | null
    status?: $Enums.ContactStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    listMembers?: ListMemberUncheckedCreateNestedManyWithoutContactInput
    emailActivities?: EmailActivityUncheckedCreateNestedManyWithoutContactInput
    smsActivities?: SMSActivityUncheckedCreateNestedManyWithoutContactInput
    waActivities?: WhatsAppActivityUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutCreatedByInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutCreatedByInput, ContactUncheckedCreateWithoutCreatedByInput>
  }

  export type ContactCreateManyCreatedByInputEnvelope = {
    data: ContactCreateManyCreatedByInput | ContactCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type EmailCampaignCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    subject: string
    from: string
    replyTo?: string | null
    content?: string | null
    design?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: EmailTemplateCreateNestedOneWithoutCampaignsInput
    lists?: ListCreateNestedManyWithoutEmailCampaignsInput
    segments?: SegmentCreateNestedManyWithoutEmailCampaignsInput
    activities?: EmailActivityCreateNestedManyWithoutCampaignInput
  }

  export type EmailCampaignUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    subject: string
    from: string
    replyTo?: string | null
    templateId?: string | null
    content?: string | null
    design?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lists?: ListUncheckedCreateNestedManyWithoutEmailCampaignsInput
    segments?: SegmentUncheckedCreateNestedManyWithoutEmailCampaignsInput
    activities?: EmailActivityUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type EmailCampaignCreateOrConnectWithoutCreatedByInput = {
    where: EmailCampaignWhereUniqueInput
    create: XOR<EmailCampaignCreateWithoutCreatedByInput, EmailCampaignUncheckedCreateWithoutCreatedByInput>
  }

  export type EmailCampaignCreateManyCreatedByInputEnvelope = {
    data: EmailCampaignCreateManyCreatedByInput | EmailCampaignCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type EmailTemplateCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    subject: string
    content: string
    design?: string | null
    previewText?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: EmailCampaignCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    subject: string
    content: string
    design?: string | null
    previewText?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: EmailCampaignUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateCreateOrConnectWithoutCreatedByInput = {
    where: EmailTemplateWhereUniqueInput
    create: XOR<EmailTemplateCreateWithoutCreatedByInput, EmailTemplateUncheckedCreateWithoutCreatedByInput>
  }

  export type EmailTemplateCreateManyCreatedByInputEnvelope = {
    data: EmailTemplateCreateManyCreatedByInput | EmailTemplateCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type SMSCampaignCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: SMSTemplateCreateNestedOneWithoutCampaignsInput
    lists?: ListCreateNestedManyWithoutSmsCampaignsInput
    segments?: SegmentCreateNestedManyWithoutSmsCampaignsInput
    activities?: SMSActivityCreateNestedManyWithoutCampaignInput
  }

  export type SMSCampaignUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    templateId?: string | null
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lists?: ListUncheckedCreateNestedManyWithoutSmsCampaignsInput
    segments?: SegmentUncheckedCreateNestedManyWithoutSmsCampaignsInput
    activities?: SMSActivityUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type SMSCampaignCreateOrConnectWithoutCreatedByInput = {
    where: SMSCampaignWhereUniqueInput
    create: XOR<SMSCampaignCreateWithoutCreatedByInput, SMSCampaignUncheckedCreateWithoutCreatedByInput>
  }

  export type SMSCampaignCreateManyCreatedByInputEnvelope = {
    data: SMSCampaignCreateManyCreatedByInput | SMSCampaignCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type SMSTemplateCreateWithoutCreatedByInput = {
    id?: string
    name: string
    content: string
    variables: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: SMSCampaignCreateNestedManyWithoutTemplateInput
  }

  export type SMSTemplateUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    content: string
    variables: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: SMSCampaignUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type SMSTemplateCreateOrConnectWithoutCreatedByInput = {
    where: SMSTemplateWhereUniqueInput
    create: XOR<SMSTemplateCreateWithoutCreatedByInput, SMSTemplateUncheckedCreateWithoutCreatedByInput>
  }

  export type SMSTemplateCreateManyCreatedByInputEnvelope = {
    data: SMSTemplateCreateManyCreatedByInput | SMSTemplateCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppCampaignCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: WhatsAppTemplateCreateNestedOneWithoutCampaignsInput
    lists?: ListCreateNestedManyWithoutWaCampaignsInput
    segments?: SegmentCreateNestedManyWithoutWaCampaignsInput
    activities?: WhatsAppActivityCreateNestedManyWithoutCampaignInput
  }

  export type WhatsAppCampaignUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    templateId?: string | null
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lists?: ListUncheckedCreateNestedManyWithoutWaCampaignsInput
    segments?: SegmentUncheckedCreateNestedManyWithoutWaCampaignsInput
    activities?: WhatsAppActivityUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type WhatsAppCampaignCreateOrConnectWithoutCreatedByInput = {
    where: WhatsAppCampaignWhereUniqueInput
    create: XOR<WhatsAppCampaignCreateWithoutCreatedByInput, WhatsAppCampaignUncheckedCreateWithoutCreatedByInput>
  }

  export type WhatsAppCampaignCreateManyCreatedByInputEnvelope = {
    data: WhatsAppCampaignCreateManyCreatedByInput | WhatsAppCampaignCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppTemplateCreateWithoutCreatedByInput = {
    id?: string
    name: string
    content: string
    variables: string
    category?: string | null
    status?: $Enums.WATemplateStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: WhatsAppCampaignCreateNestedManyWithoutTemplateInput
  }

  export type WhatsAppTemplateUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    content: string
    variables: string
    category?: string | null
    status?: $Enums.WATemplateStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type WhatsAppTemplateCreateOrConnectWithoutCreatedByInput = {
    where: WhatsAppTemplateWhereUniqueInput
    create: XOR<WhatsAppTemplateCreateWithoutCreatedByInput, WhatsAppTemplateUncheckedCreateWithoutCreatedByInput>
  }

  export type WhatsAppTemplateCreateManyCreatedByInputEnvelope = {
    data: WhatsAppTemplateCreateManyCreatedByInput | WhatsAppTemplateCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.WorkflowStatus
    definition: string
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: WorkflowNodeCreateNestedManyWithoutWorkflowInput
    triggers?: WorkflowTriggerCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.WorkflowStatus
    definition: string
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: WorkflowNodeUncheckedCreateNestedManyWithoutWorkflowInput
    triggers?: WorkflowTriggerUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowCreateOrConnectWithoutCreatedByInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutCreatedByInput, WorkflowUncheckedCreateWithoutCreatedByInput>
  }

  export type WorkflowCreateManyCreatedByInputEnvelope = {
    data: WorkflowCreateManyCreatedByInput | WorkflowCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ListCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    type?: $Enums.ListType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ListMemberCreateNestedManyWithoutListInput
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutListsInput
    smsCampaigns?: SMSCampaignCreateNestedManyWithoutListsInput
    waCampaigns?: WhatsAppCampaignCreateNestedManyWithoutListsInput
  }

  export type ListUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    type?: $Enums.ListType
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ListMemberUncheckedCreateNestedManyWithoutListInput
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutListsInput
    smsCampaigns?: SMSCampaignUncheckedCreateNestedManyWithoutListsInput
    waCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutListsInput
  }

  export type ListCreateOrConnectWithoutCreatedByInput = {
    where: ListWhereUniqueInput
    create: XOR<ListCreateWithoutCreatedByInput, ListUncheckedCreateWithoutCreatedByInput>
  }

  export type ListCreateManyCreatedByInputEnvelope = {
    data: ListCreateManyCreatedByInput | ListCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type SegmentCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    rules: string
    createdAt?: Date | string
    updatedAt?: Date | string
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutSegmentsInput
    smsCampaigns?: SMSCampaignCreateNestedManyWithoutSegmentsInput
    waCampaigns?: WhatsAppCampaignCreateNestedManyWithoutSegmentsInput
  }

  export type SegmentUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    rules: string
    createdAt?: Date | string
    updatedAt?: Date | string
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutSegmentsInput
    smsCampaigns?: SMSCampaignUncheckedCreateNestedManyWithoutSegmentsInput
    waCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutSegmentsInput
  }

  export type SegmentCreateOrConnectWithoutCreatedByInput = {
    where: SegmentWhereUniqueInput
    create: XOR<SegmentCreateWithoutCreatedByInput, SegmentUncheckedCreateWithoutCreatedByInput>
  }

  export type SegmentCreateManyCreatedByInputEnvelope = {
    data: SegmentCreateManyCreatedByInput | SegmentCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type ContactUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutCreatedByInput, ContactUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ContactCreateWithoutCreatedByInput, ContactUncheckedCreateWithoutCreatedByInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutCreatedByInput, ContactUncheckedUpdateWithoutCreatedByInput>
  }

  export type ContactUpdateManyWithWhereWithoutCreatedByInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    email?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    firstName?: StringNullableFilter<"Contact"> | string | null
    lastName?: StringNullableFilter<"Contact"> | string | null
    company?: StringNullableFilter<"Contact"> | string | null
    jobTitle?: StringNullableFilter<"Contact"> | string | null
    address?: StringNullableFilter<"Contact"> | string | null
    city?: StringNullableFilter<"Contact"> | string | null
    state?: StringNullableFilter<"Contact"> | string | null
    country?: StringNullableFilter<"Contact"> | string | null
    postalCode?: StringNullableFilter<"Contact"> | string | null
    notes?: StringNullableFilter<"Contact"> | string | null
    tagsString?: StringNullableFilter<"Contact"> | string | null
    source?: StringNullableFilter<"Contact"> | string | null
    status?: EnumContactStatusFilter<"Contact"> | $Enums.ContactStatus
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    createdById?: StringFilter<"Contact"> | string
  }

  export type EmailCampaignUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: EmailCampaignWhereUniqueInput
    update: XOR<EmailCampaignUpdateWithoutCreatedByInput, EmailCampaignUncheckedUpdateWithoutCreatedByInput>
    create: XOR<EmailCampaignCreateWithoutCreatedByInput, EmailCampaignUncheckedCreateWithoutCreatedByInput>
  }

  export type EmailCampaignUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: EmailCampaignWhereUniqueInput
    data: XOR<EmailCampaignUpdateWithoutCreatedByInput, EmailCampaignUncheckedUpdateWithoutCreatedByInput>
  }

  export type EmailCampaignUpdateManyWithWhereWithoutCreatedByInput = {
    where: EmailCampaignScalarWhereInput
    data: XOR<EmailCampaignUpdateManyMutationInput, EmailCampaignUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type EmailCampaignScalarWhereInput = {
    AND?: EmailCampaignScalarWhereInput | EmailCampaignScalarWhereInput[]
    OR?: EmailCampaignScalarWhereInput[]
    NOT?: EmailCampaignScalarWhereInput | EmailCampaignScalarWhereInput[]
    id?: StringFilter<"EmailCampaign"> | string
    name?: StringFilter<"EmailCampaign"> | string
    description?: StringNullableFilter<"EmailCampaign"> | string | null
    subject?: StringFilter<"EmailCampaign"> | string
    from?: StringFilter<"EmailCampaign"> | string
    replyTo?: StringNullableFilter<"EmailCampaign"> | string | null
    templateId?: StringNullableFilter<"EmailCampaign"> | string | null
    content?: StringNullableFilter<"EmailCampaign"> | string | null
    design?: StringNullableFilter<"EmailCampaign"> | string | null
    status?: EnumCampaignStatusFilter<"EmailCampaign"> | $Enums.CampaignStatus
    scheduledFor?: DateTimeNullableFilter<"EmailCampaign"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"EmailCampaign"> | Date | string | null
    createdAt?: DateTimeFilter<"EmailCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"EmailCampaign"> | Date | string
    createdById?: StringFilter<"EmailCampaign"> | string
  }

  export type EmailTemplateUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: EmailTemplateWhereUniqueInput
    update: XOR<EmailTemplateUpdateWithoutCreatedByInput, EmailTemplateUncheckedUpdateWithoutCreatedByInput>
    create: XOR<EmailTemplateCreateWithoutCreatedByInput, EmailTemplateUncheckedCreateWithoutCreatedByInput>
  }

  export type EmailTemplateUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: EmailTemplateWhereUniqueInput
    data: XOR<EmailTemplateUpdateWithoutCreatedByInput, EmailTemplateUncheckedUpdateWithoutCreatedByInput>
  }

  export type EmailTemplateUpdateManyWithWhereWithoutCreatedByInput = {
    where: EmailTemplateScalarWhereInput
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type EmailTemplateScalarWhereInput = {
    AND?: EmailTemplateScalarWhereInput | EmailTemplateScalarWhereInput[]
    OR?: EmailTemplateScalarWhereInput[]
    NOT?: EmailTemplateScalarWhereInput | EmailTemplateScalarWhereInput[]
    id?: StringFilter<"EmailTemplate"> | string
    name?: StringFilter<"EmailTemplate"> | string
    description?: StringNullableFilter<"EmailTemplate"> | string | null
    subject?: StringFilter<"EmailTemplate"> | string
    content?: StringFilter<"EmailTemplate"> | string
    design?: StringNullableFilter<"EmailTemplate"> | string | null
    previewText?: StringNullableFilter<"EmailTemplate"> | string | null
    category?: StringNullableFilter<"EmailTemplate"> | string | null
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    createdById?: StringFilter<"EmailTemplate"> | string
  }

  export type SMSCampaignUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: SMSCampaignWhereUniqueInput
    update: XOR<SMSCampaignUpdateWithoutCreatedByInput, SMSCampaignUncheckedUpdateWithoutCreatedByInput>
    create: XOR<SMSCampaignCreateWithoutCreatedByInput, SMSCampaignUncheckedCreateWithoutCreatedByInput>
  }

  export type SMSCampaignUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: SMSCampaignWhereUniqueInput
    data: XOR<SMSCampaignUpdateWithoutCreatedByInput, SMSCampaignUncheckedUpdateWithoutCreatedByInput>
  }

  export type SMSCampaignUpdateManyWithWhereWithoutCreatedByInput = {
    where: SMSCampaignScalarWhereInput
    data: XOR<SMSCampaignUpdateManyMutationInput, SMSCampaignUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type SMSCampaignScalarWhereInput = {
    AND?: SMSCampaignScalarWhereInput | SMSCampaignScalarWhereInput[]
    OR?: SMSCampaignScalarWhereInput[]
    NOT?: SMSCampaignScalarWhereInput | SMSCampaignScalarWhereInput[]
    id?: StringFilter<"SMSCampaign"> | string
    name?: StringFilter<"SMSCampaign"> | string
    description?: StringNullableFilter<"SMSCampaign"> | string | null
    from?: StringFilter<"SMSCampaign"> | string
    templateId?: StringNullableFilter<"SMSCampaign"> | string | null
    content?: StringNullableFilter<"SMSCampaign"> | string | null
    status?: EnumCampaignStatusFilter<"SMSCampaign"> | $Enums.CampaignStatus
    scheduledFor?: DateTimeNullableFilter<"SMSCampaign"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"SMSCampaign"> | Date | string | null
    createdAt?: DateTimeFilter<"SMSCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"SMSCampaign"> | Date | string
    createdById?: StringFilter<"SMSCampaign"> | string
  }

  export type SMSTemplateUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: SMSTemplateWhereUniqueInput
    update: XOR<SMSTemplateUpdateWithoutCreatedByInput, SMSTemplateUncheckedUpdateWithoutCreatedByInput>
    create: XOR<SMSTemplateCreateWithoutCreatedByInput, SMSTemplateUncheckedCreateWithoutCreatedByInput>
  }

  export type SMSTemplateUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: SMSTemplateWhereUniqueInput
    data: XOR<SMSTemplateUpdateWithoutCreatedByInput, SMSTemplateUncheckedUpdateWithoutCreatedByInput>
  }

  export type SMSTemplateUpdateManyWithWhereWithoutCreatedByInput = {
    where: SMSTemplateScalarWhereInput
    data: XOR<SMSTemplateUpdateManyMutationInput, SMSTemplateUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type SMSTemplateScalarWhereInput = {
    AND?: SMSTemplateScalarWhereInput | SMSTemplateScalarWhereInput[]
    OR?: SMSTemplateScalarWhereInput[]
    NOT?: SMSTemplateScalarWhereInput | SMSTemplateScalarWhereInput[]
    id?: StringFilter<"SMSTemplate"> | string
    name?: StringFilter<"SMSTemplate"> | string
    content?: StringFilter<"SMSTemplate"> | string
    variables?: StringFilter<"SMSTemplate"> | string
    category?: StringNullableFilter<"SMSTemplate"> | string | null
    createdAt?: DateTimeFilter<"SMSTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"SMSTemplate"> | Date | string
    createdById?: StringFilter<"SMSTemplate"> | string
  }

  export type WhatsAppCampaignUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: WhatsAppCampaignWhereUniqueInput
    update: XOR<WhatsAppCampaignUpdateWithoutCreatedByInput, WhatsAppCampaignUncheckedUpdateWithoutCreatedByInput>
    create: XOR<WhatsAppCampaignCreateWithoutCreatedByInput, WhatsAppCampaignUncheckedCreateWithoutCreatedByInput>
  }

  export type WhatsAppCampaignUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: WhatsAppCampaignWhereUniqueInput
    data: XOR<WhatsAppCampaignUpdateWithoutCreatedByInput, WhatsAppCampaignUncheckedUpdateWithoutCreatedByInput>
  }

  export type WhatsAppCampaignUpdateManyWithWhereWithoutCreatedByInput = {
    where: WhatsAppCampaignScalarWhereInput
    data: XOR<WhatsAppCampaignUpdateManyMutationInput, WhatsAppCampaignUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type WhatsAppCampaignScalarWhereInput = {
    AND?: WhatsAppCampaignScalarWhereInput | WhatsAppCampaignScalarWhereInput[]
    OR?: WhatsAppCampaignScalarWhereInput[]
    NOT?: WhatsAppCampaignScalarWhereInput | WhatsAppCampaignScalarWhereInput[]
    id?: StringFilter<"WhatsAppCampaign"> | string
    name?: StringFilter<"WhatsAppCampaign"> | string
    description?: StringNullableFilter<"WhatsAppCampaign"> | string | null
    from?: StringFilter<"WhatsAppCampaign"> | string
    templateId?: StringNullableFilter<"WhatsAppCampaign"> | string | null
    content?: StringNullableFilter<"WhatsAppCampaign"> | string | null
    status?: EnumCampaignStatusFilter<"WhatsAppCampaign"> | $Enums.CampaignStatus
    scheduledFor?: DateTimeNullableFilter<"WhatsAppCampaign"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"WhatsAppCampaign"> | Date | string | null
    createdAt?: DateTimeFilter<"WhatsAppCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppCampaign"> | Date | string
    createdById?: StringFilter<"WhatsAppCampaign"> | string
  }

  export type WhatsAppTemplateUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: WhatsAppTemplateWhereUniqueInput
    update: XOR<WhatsAppTemplateUpdateWithoutCreatedByInput, WhatsAppTemplateUncheckedUpdateWithoutCreatedByInput>
    create: XOR<WhatsAppTemplateCreateWithoutCreatedByInput, WhatsAppTemplateUncheckedCreateWithoutCreatedByInput>
  }

  export type WhatsAppTemplateUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: WhatsAppTemplateWhereUniqueInput
    data: XOR<WhatsAppTemplateUpdateWithoutCreatedByInput, WhatsAppTemplateUncheckedUpdateWithoutCreatedByInput>
  }

  export type WhatsAppTemplateUpdateManyWithWhereWithoutCreatedByInput = {
    where: WhatsAppTemplateScalarWhereInput
    data: XOR<WhatsAppTemplateUpdateManyMutationInput, WhatsAppTemplateUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type WhatsAppTemplateScalarWhereInput = {
    AND?: WhatsAppTemplateScalarWhereInput | WhatsAppTemplateScalarWhereInput[]
    OR?: WhatsAppTemplateScalarWhereInput[]
    NOT?: WhatsAppTemplateScalarWhereInput | WhatsAppTemplateScalarWhereInput[]
    id?: StringFilter<"WhatsAppTemplate"> | string
    name?: StringFilter<"WhatsAppTemplate"> | string
    content?: StringFilter<"WhatsAppTemplate"> | string
    variables?: StringFilter<"WhatsAppTemplate"> | string
    category?: StringNullableFilter<"WhatsAppTemplate"> | string | null
    status?: EnumWATemplateStatusFilter<"WhatsAppTemplate"> | $Enums.WATemplateStatus
    createdAt?: DateTimeFilter<"WhatsAppTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppTemplate"> | Date | string
    createdById?: StringFilter<"WhatsAppTemplate"> | string
  }

  export type WorkflowUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: WorkflowWhereUniqueInput
    update: XOR<WorkflowUpdateWithoutCreatedByInput, WorkflowUncheckedUpdateWithoutCreatedByInput>
    create: XOR<WorkflowCreateWithoutCreatedByInput, WorkflowUncheckedCreateWithoutCreatedByInput>
  }

  export type WorkflowUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: WorkflowWhereUniqueInput
    data: XOR<WorkflowUpdateWithoutCreatedByInput, WorkflowUncheckedUpdateWithoutCreatedByInput>
  }

  export type WorkflowUpdateManyWithWhereWithoutCreatedByInput = {
    where: WorkflowScalarWhereInput
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type WorkflowScalarWhereInput = {
    AND?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
    OR?: WorkflowScalarWhereInput[]
    NOT?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
    id?: StringFilter<"Workflow"> | string
    name?: StringFilter<"Workflow"> | string
    description?: StringNullableFilter<"Workflow"> | string | null
    status?: EnumWorkflowStatusFilter<"Workflow"> | $Enums.WorkflowStatus
    definition?: StringFilter<"Workflow"> | string
    createdAt?: DateTimeFilter<"Workflow"> | Date | string
    updatedAt?: DateTimeFilter<"Workflow"> | Date | string
    createdById?: StringFilter<"Workflow"> | string
  }

  export type ListUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ListWhereUniqueInput
    update: XOR<ListUpdateWithoutCreatedByInput, ListUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ListCreateWithoutCreatedByInput, ListUncheckedCreateWithoutCreatedByInput>
  }

  export type ListUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ListWhereUniqueInput
    data: XOR<ListUpdateWithoutCreatedByInput, ListUncheckedUpdateWithoutCreatedByInput>
  }

  export type ListUpdateManyWithWhereWithoutCreatedByInput = {
    where: ListScalarWhereInput
    data: XOR<ListUpdateManyMutationInput, ListUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ListScalarWhereInput = {
    AND?: ListScalarWhereInput | ListScalarWhereInput[]
    OR?: ListScalarWhereInput[]
    NOT?: ListScalarWhereInput | ListScalarWhereInput[]
    id?: StringFilter<"List"> | string
    name?: StringFilter<"List"> | string
    description?: StringNullableFilter<"List"> | string | null
    type?: EnumListTypeFilter<"List"> | $Enums.ListType
    createdAt?: DateTimeFilter<"List"> | Date | string
    updatedAt?: DateTimeFilter<"List"> | Date | string
    createdById?: StringFilter<"List"> | string
  }

  export type SegmentUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: SegmentWhereUniqueInput
    update: XOR<SegmentUpdateWithoutCreatedByInput, SegmentUncheckedUpdateWithoutCreatedByInput>
    create: XOR<SegmentCreateWithoutCreatedByInput, SegmentUncheckedCreateWithoutCreatedByInput>
  }

  export type SegmentUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: SegmentWhereUniqueInput
    data: XOR<SegmentUpdateWithoutCreatedByInput, SegmentUncheckedUpdateWithoutCreatedByInput>
  }

  export type SegmentUpdateManyWithWhereWithoutCreatedByInput = {
    where: SegmentScalarWhereInput
    data: XOR<SegmentUpdateManyMutationInput, SegmentUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type SegmentScalarWhereInput = {
    AND?: SegmentScalarWhereInput | SegmentScalarWhereInput[]
    OR?: SegmentScalarWhereInput[]
    NOT?: SegmentScalarWhereInput | SegmentScalarWhereInput[]
    id?: StringFilter<"Segment"> | string
    name?: StringFilter<"Segment"> | string
    description?: StringNullableFilter<"Segment"> | string | null
    rules?: StringFilter<"Segment"> | string
    createdAt?: DateTimeFilter<"Segment"> | Date | string
    updatedAt?: DateTimeFilter<"Segment"> | Date | string
    createdById?: StringFilter<"Segment"> | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    sessions?: SessionCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutCreatedByInput
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutCreatedByInput
    emailTemplates?: EmailTemplateCreateNestedManyWithoutCreatedByInput
    smsCampaigns?: SMSCampaignCreateNestedManyWithoutCreatedByInput
    smsTemplates?: SMSTemplateCreateNestedManyWithoutCreatedByInput
    waCampaigns?: WhatsAppCampaignCreateNestedManyWithoutCreatedByInput
    waTemplates?: WhatsAppTemplateCreateNestedManyWithoutCreatedByInput
    workflows?: WorkflowCreateNestedManyWithoutCreatedByInput
    lists?: ListCreateNestedManyWithoutCreatedByInput
    segments?: SegmentCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCreatedByInput
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    emailTemplates?: EmailTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    smsCampaigns?: SMSCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    smsTemplates?: SMSTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    waCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    waTemplates?: WhatsAppTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutCreatedByInput
    lists?: ListUncheckedCreateNestedManyWithoutCreatedByInput
    segments?: SegmentUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    sessions?: SessionUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutCreatedByNestedInput
    emailCampaigns?: EmailCampaignUpdateManyWithoutCreatedByNestedInput
    emailTemplates?: EmailTemplateUpdateManyWithoutCreatedByNestedInput
    smsCampaigns?: SMSCampaignUpdateManyWithoutCreatedByNestedInput
    smsTemplates?: SMSTemplateUpdateManyWithoutCreatedByNestedInput
    waCampaigns?: WhatsAppCampaignUpdateManyWithoutCreatedByNestedInput
    waTemplates?: WhatsAppTemplateUpdateManyWithoutCreatedByNestedInput
    workflows?: WorkflowUpdateManyWithoutCreatedByNestedInput
    lists?: ListUpdateManyWithoutCreatedByNestedInput
    segments?: SegmentUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCreatedByNestedInput
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    emailTemplates?: EmailTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    smsCampaigns?: SMSCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    smsTemplates?: SMSTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    waCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    waTemplates?: WhatsAppTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput
    lists?: ListUncheckedUpdateManyWithoutCreatedByNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    accounts?: AccountCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutCreatedByInput
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutCreatedByInput
    emailTemplates?: EmailTemplateCreateNestedManyWithoutCreatedByInput
    smsCampaigns?: SMSCampaignCreateNestedManyWithoutCreatedByInput
    smsTemplates?: SMSTemplateCreateNestedManyWithoutCreatedByInput
    waCampaigns?: WhatsAppCampaignCreateNestedManyWithoutCreatedByInput
    waTemplates?: WhatsAppTemplateCreateNestedManyWithoutCreatedByInput
    workflows?: WorkflowCreateNestedManyWithoutCreatedByInput
    lists?: ListCreateNestedManyWithoutCreatedByInput
    segments?: SegmentCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCreatedByInput
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    emailTemplates?: EmailTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    smsCampaigns?: SMSCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    smsTemplates?: SMSTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    waCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    waTemplates?: WhatsAppTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutCreatedByInput
    lists?: ListUncheckedCreateNestedManyWithoutCreatedByInput
    segments?: SegmentUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutCreatedByNestedInput
    emailCampaigns?: EmailCampaignUpdateManyWithoutCreatedByNestedInput
    emailTemplates?: EmailTemplateUpdateManyWithoutCreatedByNestedInput
    smsCampaigns?: SMSCampaignUpdateManyWithoutCreatedByNestedInput
    smsTemplates?: SMSTemplateUpdateManyWithoutCreatedByNestedInput
    waCampaigns?: WhatsAppCampaignUpdateManyWithoutCreatedByNestedInput
    waTemplates?: WhatsAppTemplateUpdateManyWithoutCreatedByNestedInput
    workflows?: WorkflowUpdateManyWithoutCreatedByNestedInput
    lists?: ListUpdateManyWithoutCreatedByNestedInput
    segments?: SegmentUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCreatedByNestedInput
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    emailTemplates?: EmailTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    smsCampaigns?: SMSCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    smsTemplates?: SMSTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    waCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    waTemplates?: WhatsAppTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput
    lists?: ListUncheckedUpdateManyWithoutCreatedByNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateWithoutContactsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutCreatedByInput
    emailTemplates?: EmailTemplateCreateNestedManyWithoutCreatedByInput
    smsCampaigns?: SMSCampaignCreateNestedManyWithoutCreatedByInput
    smsTemplates?: SMSTemplateCreateNestedManyWithoutCreatedByInput
    waCampaigns?: WhatsAppCampaignCreateNestedManyWithoutCreatedByInput
    waTemplates?: WhatsAppTemplateCreateNestedManyWithoutCreatedByInput
    workflows?: WorkflowCreateNestedManyWithoutCreatedByInput
    lists?: ListCreateNestedManyWithoutCreatedByInput
    segments?: SegmentCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutContactsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    emailTemplates?: EmailTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    smsCampaigns?: SMSCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    smsTemplates?: SMSTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    waCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    waTemplates?: WhatsAppTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutCreatedByInput
    lists?: ListUncheckedCreateNestedManyWithoutCreatedByInput
    segments?: SegmentUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutContactsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
  }

  export type ListMemberCreateWithoutContactInput = {
    id?: string
    addedAt?: Date | string
    list: ListCreateNestedOneWithoutMembersInput
  }

  export type ListMemberUncheckedCreateWithoutContactInput = {
    id?: string
    listId: string
    addedAt?: Date | string
  }

  export type ListMemberCreateOrConnectWithoutContactInput = {
    where: ListMemberWhereUniqueInput
    create: XOR<ListMemberCreateWithoutContactInput, ListMemberUncheckedCreateWithoutContactInput>
  }

  export type ListMemberCreateManyContactInputEnvelope = {
    data: ListMemberCreateManyContactInput | ListMemberCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type EmailActivityCreateWithoutContactInput = {
    id?: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
    campaign: EmailCampaignCreateNestedOneWithoutActivitiesInput
  }

  export type EmailActivityUncheckedCreateWithoutContactInput = {
    id?: string
    campaignId: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
  }

  export type EmailActivityCreateOrConnectWithoutContactInput = {
    where: EmailActivityWhereUniqueInput
    create: XOR<EmailActivityCreateWithoutContactInput, EmailActivityUncheckedCreateWithoutContactInput>
  }

  export type EmailActivityCreateManyContactInputEnvelope = {
    data: EmailActivityCreateManyContactInput | EmailActivityCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type SMSActivityCreateWithoutContactInput = {
    id?: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
    campaign: SMSCampaignCreateNestedOneWithoutActivitiesInput
  }

  export type SMSActivityUncheckedCreateWithoutContactInput = {
    id?: string
    campaignId: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
  }

  export type SMSActivityCreateOrConnectWithoutContactInput = {
    where: SMSActivityWhereUniqueInput
    create: XOR<SMSActivityCreateWithoutContactInput, SMSActivityUncheckedCreateWithoutContactInput>
  }

  export type SMSActivityCreateManyContactInputEnvelope = {
    data: SMSActivityCreateManyContactInput | SMSActivityCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppActivityCreateWithoutContactInput = {
    id?: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
    campaign: WhatsAppCampaignCreateNestedOneWithoutActivitiesInput
  }

  export type WhatsAppActivityUncheckedCreateWithoutContactInput = {
    id?: string
    campaignId: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
  }

  export type WhatsAppActivityCreateOrConnectWithoutContactInput = {
    where: WhatsAppActivityWhereUniqueInput
    create: XOR<WhatsAppActivityCreateWithoutContactInput, WhatsAppActivityUncheckedCreateWithoutContactInput>
  }

  export type WhatsAppActivityCreateManyContactInputEnvelope = {
    data: WhatsAppActivityCreateManyContactInput | WhatsAppActivityCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutContactsInput = {
    update: XOR<UserUpdateWithoutContactsInput, UserUncheckedUpdateWithoutContactsInput>
    create: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContactsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContactsInput, UserUncheckedUpdateWithoutContactsInput>
  }

  export type UserUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    emailCampaigns?: EmailCampaignUpdateManyWithoutCreatedByNestedInput
    emailTemplates?: EmailTemplateUpdateManyWithoutCreatedByNestedInput
    smsCampaigns?: SMSCampaignUpdateManyWithoutCreatedByNestedInput
    smsTemplates?: SMSTemplateUpdateManyWithoutCreatedByNestedInput
    waCampaigns?: WhatsAppCampaignUpdateManyWithoutCreatedByNestedInput
    waTemplates?: WhatsAppTemplateUpdateManyWithoutCreatedByNestedInput
    workflows?: WorkflowUpdateManyWithoutCreatedByNestedInput
    lists?: ListUpdateManyWithoutCreatedByNestedInput
    segments?: SegmentUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    emailTemplates?: EmailTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    smsCampaigns?: SMSCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    smsTemplates?: SMSTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    waCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    waTemplates?: WhatsAppTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput
    lists?: ListUncheckedUpdateManyWithoutCreatedByNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ListMemberUpsertWithWhereUniqueWithoutContactInput = {
    where: ListMemberWhereUniqueInput
    update: XOR<ListMemberUpdateWithoutContactInput, ListMemberUncheckedUpdateWithoutContactInput>
    create: XOR<ListMemberCreateWithoutContactInput, ListMemberUncheckedCreateWithoutContactInput>
  }

  export type ListMemberUpdateWithWhereUniqueWithoutContactInput = {
    where: ListMemberWhereUniqueInput
    data: XOR<ListMemberUpdateWithoutContactInput, ListMemberUncheckedUpdateWithoutContactInput>
  }

  export type ListMemberUpdateManyWithWhereWithoutContactInput = {
    where: ListMemberScalarWhereInput
    data: XOR<ListMemberUpdateManyMutationInput, ListMemberUncheckedUpdateManyWithoutContactInput>
  }

  export type ListMemberScalarWhereInput = {
    AND?: ListMemberScalarWhereInput | ListMemberScalarWhereInput[]
    OR?: ListMemberScalarWhereInput[]
    NOT?: ListMemberScalarWhereInput | ListMemberScalarWhereInput[]
    id?: StringFilter<"ListMember"> | string
    listId?: StringFilter<"ListMember"> | string
    contactId?: StringFilter<"ListMember"> | string
    addedAt?: DateTimeFilter<"ListMember"> | Date | string
  }

  export type EmailActivityUpsertWithWhereUniqueWithoutContactInput = {
    where: EmailActivityWhereUniqueInput
    update: XOR<EmailActivityUpdateWithoutContactInput, EmailActivityUncheckedUpdateWithoutContactInput>
    create: XOR<EmailActivityCreateWithoutContactInput, EmailActivityUncheckedCreateWithoutContactInput>
  }

  export type EmailActivityUpdateWithWhereUniqueWithoutContactInput = {
    where: EmailActivityWhereUniqueInput
    data: XOR<EmailActivityUpdateWithoutContactInput, EmailActivityUncheckedUpdateWithoutContactInput>
  }

  export type EmailActivityUpdateManyWithWhereWithoutContactInput = {
    where: EmailActivityScalarWhereInput
    data: XOR<EmailActivityUpdateManyMutationInput, EmailActivityUncheckedUpdateManyWithoutContactInput>
  }

  export type EmailActivityScalarWhereInput = {
    AND?: EmailActivityScalarWhereInput | EmailActivityScalarWhereInput[]
    OR?: EmailActivityScalarWhereInput[]
    NOT?: EmailActivityScalarWhereInput | EmailActivityScalarWhereInput[]
    id?: StringFilter<"EmailActivity"> | string
    campaignId?: StringFilter<"EmailActivity"> | string
    contactId?: StringFilter<"EmailActivity"> | string
    type?: EnumActivityTypeFilter<"EmailActivity"> | $Enums.ActivityType
    timestamp?: DateTimeFilter<"EmailActivity"> | Date | string
    metadata?: StringNullableFilter<"EmailActivity"> | string | null
  }

  export type SMSActivityUpsertWithWhereUniqueWithoutContactInput = {
    where: SMSActivityWhereUniqueInput
    update: XOR<SMSActivityUpdateWithoutContactInput, SMSActivityUncheckedUpdateWithoutContactInput>
    create: XOR<SMSActivityCreateWithoutContactInput, SMSActivityUncheckedCreateWithoutContactInput>
  }

  export type SMSActivityUpdateWithWhereUniqueWithoutContactInput = {
    where: SMSActivityWhereUniqueInput
    data: XOR<SMSActivityUpdateWithoutContactInput, SMSActivityUncheckedUpdateWithoutContactInput>
  }

  export type SMSActivityUpdateManyWithWhereWithoutContactInput = {
    where: SMSActivityScalarWhereInput
    data: XOR<SMSActivityUpdateManyMutationInput, SMSActivityUncheckedUpdateManyWithoutContactInput>
  }

  export type SMSActivityScalarWhereInput = {
    AND?: SMSActivityScalarWhereInput | SMSActivityScalarWhereInput[]
    OR?: SMSActivityScalarWhereInput[]
    NOT?: SMSActivityScalarWhereInput | SMSActivityScalarWhereInput[]
    id?: StringFilter<"SMSActivity"> | string
    campaignId?: StringFilter<"SMSActivity"> | string
    contactId?: StringFilter<"SMSActivity"> | string
    type?: EnumActivityTypeFilter<"SMSActivity"> | $Enums.ActivityType
    timestamp?: DateTimeFilter<"SMSActivity"> | Date | string
    metadata?: StringNullableFilter<"SMSActivity"> | string | null
  }

  export type WhatsAppActivityUpsertWithWhereUniqueWithoutContactInput = {
    where: WhatsAppActivityWhereUniqueInput
    update: XOR<WhatsAppActivityUpdateWithoutContactInput, WhatsAppActivityUncheckedUpdateWithoutContactInput>
    create: XOR<WhatsAppActivityCreateWithoutContactInput, WhatsAppActivityUncheckedCreateWithoutContactInput>
  }

  export type WhatsAppActivityUpdateWithWhereUniqueWithoutContactInput = {
    where: WhatsAppActivityWhereUniqueInput
    data: XOR<WhatsAppActivityUpdateWithoutContactInput, WhatsAppActivityUncheckedUpdateWithoutContactInput>
  }

  export type WhatsAppActivityUpdateManyWithWhereWithoutContactInput = {
    where: WhatsAppActivityScalarWhereInput
    data: XOR<WhatsAppActivityUpdateManyMutationInput, WhatsAppActivityUncheckedUpdateManyWithoutContactInput>
  }

  export type WhatsAppActivityScalarWhereInput = {
    AND?: WhatsAppActivityScalarWhereInput | WhatsAppActivityScalarWhereInput[]
    OR?: WhatsAppActivityScalarWhereInput[]
    NOT?: WhatsAppActivityScalarWhereInput | WhatsAppActivityScalarWhereInput[]
    id?: StringFilter<"WhatsAppActivity"> | string
    campaignId?: StringFilter<"WhatsAppActivity"> | string
    contactId?: StringFilter<"WhatsAppActivity"> | string
    type?: EnumActivityTypeFilter<"WhatsAppActivity"> | $Enums.ActivityType
    timestamp?: DateTimeFilter<"WhatsAppActivity"> | Date | string
    metadata?: StringNullableFilter<"WhatsAppActivity"> | string | null
  }

  export type UserCreateWithoutListsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutCreatedByInput
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutCreatedByInput
    emailTemplates?: EmailTemplateCreateNestedManyWithoutCreatedByInput
    smsCampaigns?: SMSCampaignCreateNestedManyWithoutCreatedByInput
    smsTemplates?: SMSTemplateCreateNestedManyWithoutCreatedByInput
    waCampaigns?: WhatsAppCampaignCreateNestedManyWithoutCreatedByInput
    waTemplates?: WhatsAppTemplateCreateNestedManyWithoutCreatedByInput
    workflows?: WorkflowCreateNestedManyWithoutCreatedByInput
    segments?: SegmentCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutListsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCreatedByInput
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    emailTemplates?: EmailTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    smsCampaigns?: SMSCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    smsTemplates?: SMSTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    waCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    waTemplates?: WhatsAppTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutCreatedByInput
    segments?: SegmentUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutListsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutListsInput, UserUncheckedCreateWithoutListsInput>
  }

  export type ListMemberCreateWithoutListInput = {
    id?: string
    addedAt?: Date | string
    contact: ContactCreateNestedOneWithoutListMembersInput
  }

  export type ListMemberUncheckedCreateWithoutListInput = {
    id?: string
    contactId: string
    addedAt?: Date | string
  }

  export type ListMemberCreateOrConnectWithoutListInput = {
    where: ListMemberWhereUniqueInput
    create: XOR<ListMemberCreateWithoutListInput, ListMemberUncheckedCreateWithoutListInput>
  }

  export type ListMemberCreateManyListInputEnvelope = {
    data: ListMemberCreateManyListInput | ListMemberCreateManyListInput[]
    skipDuplicates?: boolean
  }

  export type EmailCampaignCreateWithoutListsInput = {
    id?: string
    name: string
    description?: string | null
    subject: string
    from: string
    replyTo?: string | null
    content?: string | null
    design?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutEmailCampaignsInput
    template?: EmailTemplateCreateNestedOneWithoutCampaignsInput
    segments?: SegmentCreateNestedManyWithoutEmailCampaignsInput
    activities?: EmailActivityCreateNestedManyWithoutCampaignInput
  }

  export type EmailCampaignUncheckedCreateWithoutListsInput = {
    id?: string
    name: string
    description?: string | null
    subject: string
    from: string
    replyTo?: string | null
    templateId?: string | null
    content?: string | null
    design?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    segments?: SegmentUncheckedCreateNestedManyWithoutEmailCampaignsInput
    activities?: EmailActivityUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type EmailCampaignCreateOrConnectWithoutListsInput = {
    where: EmailCampaignWhereUniqueInput
    create: XOR<EmailCampaignCreateWithoutListsInput, EmailCampaignUncheckedCreateWithoutListsInput>
  }

  export type SMSCampaignCreateWithoutListsInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutSmsCampaignsInput
    template?: SMSTemplateCreateNestedOneWithoutCampaignsInput
    segments?: SegmentCreateNestedManyWithoutSmsCampaignsInput
    activities?: SMSActivityCreateNestedManyWithoutCampaignInput
  }

  export type SMSCampaignUncheckedCreateWithoutListsInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    templateId?: string | null
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    segments?: SegmentUncheckedCreateNestedManyWithoutSmsCampaignsInput
    activities?: SMSActivityUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type SMSCampaignCreateOrConnectWithoutListsInput = {
    where: SMSCampaignWhereUniqueInput
    create: XOR<SMSCampaignCreateWithoutListsInput, SMSCampaignUncheckedCreateWithoutListsInput>
  }

  export type WhatsAppCampaignCreateWithoutListsInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutWaCampaignsInput
    template?: WhatsAppTemplateCreateNestedOneWithoutCampaignsInput
    segments?: SegmentCreateNestedManyWithoutWaCampaignsInput
    activities?: WhatsAppActivityCreateNestedManyWithoutCampaignInput
  }

  export type WhatsAppCampaignUncheckedCreateWithoutListsInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    templateId?: string | null
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    segments?: SegmentUncheckedCreateNestedManyWithoutWaCampaignsInput
    activities?: WhatsAppActivityUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type WhatsAppCampaignCreateOrConnectWithoutListsInput = {
    where: WhatsAppCampaignWhereUniqueInput
    create: XOR<WhatsAppCampaignCreateWithoutListsInput, WhatsAppCampaignUncheckedCreateWithoutListsInput>
  }

  export type UserUpsertWithoutListsInput = {
    update: XOR<UserUpdateWithoutListsInput, UserUncheckedUpdateWithoutListsInput>
    create: XOR<UserCreateWithoutListsInput, UserUncheckedCreateWithoutListsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutListsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutListsInput, UserUncheckedUpdateWithoutListsInput>
  }

  export type UserUpdateWithoutListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutCreatedByNestedInput
    emailCampaigns?: EmailCampaignUpdateManyWithoutCreatedByNestedInput
    emailTemplates?: EmailTemplateUpdateManyWithoutCreatedByNestedInput
    smsCampaigns?: SMSCampaignUpdateManyWithoutCreatedByNestedInput
    smsTemplates?: SMSTemplateUpdateManyWithoutCreatedByNestedInput
    waCampaigns?: WhatsAppCampaignUpdateManyWithoutCreatedByNestedInput
    waTemplates?: WhatsAppTemplateUpdateManyWithoutCreatedByNestedInput
    workflows?: WorkflowUpdateManyWithoutCreatedByNestedInput
    segments?: SegmentUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCreatedByNestedInput
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    emailTemplates?: EmailTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    smsCampaigns?: SMSCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    smsTemplates?: SMSTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    waCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    waTemplates?: WhatsAppTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ListMemberUpsertWithWhereUniqueWithoutListInput = {
    where: ListMemberWhereUniqueInput
    update: XOR<ListMemberUpdateWithoutListInput, ListMemberUncheckedUpdateWithoutListInput>
    create: XOR<ListMemberCreateWithoutListInput, ListMemberUncheckedCreateWithoutListInput>
  }

  export type ListMemberUpdateWithWhereUniqueWithoutListInput = {
    where: ListMemberWhereUniqueInput
    data: XOR<ListMemberUpdateWithoutListInput, ListMemberUncheckedUpdateWithoutListInput>
  }

  export type ListMemberUpdateManyWithWhereWithoutListInput = {
    where: ListMemberScalarWhereInput
    data: XOR<ListMemberUpdateManyMutationInput, ListMemberUncheckedUpdateManyWithoutListInput>
  }

  export type EmailCampaignUpsertWithWhereUniqueWithoutListsInput = {
    where: EmailCampaignWhereUniqueInput
    update: XOR<EmailCampaignUpdateWithoutListsInput, EmailCampaignUncheckedUpdateWithoutListsInput>
    create: XOR<EmailCampaignCreateWithoutListsInput, EmailCampaignUncheckedCreateWithoutListsInput>
  }

  export type EmailCampaignUpdateWithWhereUniqueWithoutListsInput = {
    where: EmailCampaignWhereUniqueInput
    data: XOR<EmailCampaignUpdateWithoutListsInput, EmailCampaignUncheckedUpdateWithoutListsInput>
  }

  export type EmailCampaignUpdateManyWithWhereWithoutListsInput = {
    where: EmailCampaignScalarWhereInput
    data: XOR<EmailCampaignUpdateManyMutationInput, EmailCampaignUncheckedUpdateManyWithoutListsInput>
  }

  export type SMSCampaignUpsertWithWhereUniqueWithoutListsInput = {
    where: SMSCampaignWhereUniqueInput
    update: XOR<SMSCampaignUpdateWithoutListsInput, SMSCampaignUncheckedUpdateWithoutListsInput>
    create: XOR<SMSCampaignCreateWithoutListsInput, SMSCampaignUncheckedCreateWithoutListsInput>
  }

  export type SMSCampaignUpdateWithWhereUniqueWithoutListsInput = {
    where: SMSCampaignWhereUniqueInput
    data: XOR<SMSCampaignUpdateWithoutListsInput, SMSCampaignUncheckedUpdateWithoutListsInput>
  }

  export type SMSCampaignUpdateManyWithWhereWithoutListsInput = {
    where: SMSCampaignScalarWhereInput
    data: XOR<SMSCampaignUpdateManyMutationInput, SMSCampaignUncheckedUpdateManyWithoutListsInput>
  }

  export type WhatsAppCampaignUpsertWithWhereUniqueWithoutListsInput = {
    where: WhatsAppCampaignWhereUniqueInput
    update: XOR<WhatsAppCampaignUpdateWithoutListsInput, WhatsAppCampaignUncheckedUpdateWithoutListsInput>
    create: XOR<WhatsAppCampaignCreateWithoutListsInput, WhatsAppCampaignUncheckedCreateWithoutListsInput>
  }

  export type WhatsAppCampaignUpdateWithWhereUniqueWithoutListsInput = {
    where: WhatsAppCampaignWhereUniqueInput
    data: XOR<WhatsAppCampaignUpdateWithoutListsInput, WhatsAppCampaignUncheckedUpdateWithoutListsInput>
  }

  export type WhatsAppCampaignUpdateManyWithWhereWithoutListsInput = {
    where: WhatsAppCampaignScalarWhereInput
    data: XOR<WhatsAppCampaignUpdateManyMutationInput, WhatsAppCampaignUncheckedUpdateManyWithoutListsInput>
  }

  export type ListCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    type?: $Enums.ListType
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutListsInput
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutListsInput
    smsCampaigns?: SMSCampaignCreateNestedManyWithoutListsInput
    waCampaigns?: WhatsAppCampaignCreateNestedManyWithoutListsInput
  }

  export type ListUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    type?: $Enums.ListType
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutListsInput
    smsCampaigns?: SMSCampaignUncheckedCreateNestedManyWithoutListsInput
    waCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutListsInput
  }

  export type ListCreateOrConnectWithoutMembersInput = {
    where: ListWhereUniqueInput
    create: XOR<ListCreateWithoutMembersInput, ListUncheckedCreateWithoutMembersInput>
  }

  export type ContactCreateWithoutListMembersInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    jobTitle?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    notes?: string | null
    tagsString?: string | null
    source?: string | null
    status?: $Enums.ContactStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutContactsInput
    emailActivities?: EmailActivityCreateNestedManyWithoutContactInput
    smsActivities?: SMSActivityCreateNestedManyWithoutContactInput
    waActivities?: WhatsAppActivityCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutListMembersInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    jobTitle?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    notes?: string | null
    tagsString?: string | null
    source?: string | null
    status?: $Enums.ContactStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    emailActivities?: EmailActivityUncheckedCreateNestedManyWithoutContactInput
    smsActivities?: SMSActivityUncheckedCreateNestedManyWithoutContactInput
    waActivities?: WhatsAppActivityUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutListMembersInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutListMembersInput, ContactUncheckedCreateWithoutListMembersInput>
  }

  export type ListUpsertWithoutMembersInput = {
    update: XOR<ListUpdateWithoutMembersInput, ListUncheckedUpdateWithoutMembersInput>
    create: XOR<ListCreateWithoutMembersInput, ListUncheckedCreateWithoutMembersInput>
    where?: ListWhereInput
  }

  export type ListUpdateToOneWithWhereWithoutMembersInput = {
    where?: ListWhereInput
    data: XOR<ListUpdateWithoutMembersInput, ListUncheckedUpdateWithoutMembersInput>
  }

  export type ListUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutListsNestedInput
    emailCampaigns?: EmailCampaignUpdateManyWithoutListsNestedInput
    smsCampaigns?: SMSCampaignUpdateManyWithoutListsNestedInput
    waCampaigns?: WhatsAppCampaignUpdateManyWithoutListsNestedInput
  }

  export type ListUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutListsNestedInput
    smsCampaigns?: SMSCampaignUncheckedUpdateManyWithoutListsNestedInput
    waCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutListsNestedInput
  }

  export type ContactUpsertWithoutListMembersInput = {
    update: XOR<ContactUpdateWithoutListMembersInput, ContactUncheckedUpdateWithoutListMembersInput>
    create: XOR<ContactCreateWithoutListMembersInput, ContactUncheckedCreateWithoutListMembersInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutListMembersInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutListMembersInput, ContactUncheckedUpdateWithoutListMembersInput>
  }

  export type ContactUpdateWithoutListMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tagsString?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutContactsNestedInput
    emailActivities?: EmailActivityUpdateManyWithoutContactNestedInput
    smsActivities?: SMSActivityUpdateManyWithoutContactNestedInput
    waActivities?: WhatsAppActivityUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutListMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tagsString?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    emailActivities?: EmailActivityUncheckedUpdateManyWithoutContactNestedInput
    smsActivities?: SMSActivityUncheckedUpdateManyWithoutContactNestedInput
    waActivities?: WhatsAppActivityUncheckedUpdateManyWithoutContactNestedInput
  }

  export type UserCreateWithoutSegmentsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutCreatedByInput
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutCreatedByInput
    emailTemplates?: EmailTemplateCreateNestedManyWithoutCreatedByInput
    smsCampaigns?: SMSCampaignCreateNestedManyWithoutCreatedByInput
    smsTemplates?: SMSTemplateCreateNestedManyWithoutCreatedByInput
    waCampaigns?: WhatsAppCampaignCreateNestedManyWithoutCreatedByInput
    waTemplates?: WhatsAppTemplateCreateNestedManyWithoutCreatedByInput
    workflows?: WorkflowCreateNestedManyWithoutCreatedByInput
    lists?: ListCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutSegmentsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCreatedByInput
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    emailTemplates?: EmailTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    smsCampaigns?: SMSCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    smsTemplates?: SMSTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    waCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    waTemplates?: WhatsAppTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutCreatedByInput
    lists?: ListUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutSegmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSegmentsInput, UserUncheckedCreateWithoutSegmentsInput>
  }

  export type EmailCampaignCreateWithoutSegmentsInput = {
    id?: string
    name: string
    description?: string | null
    subject: string
    from: string
    replyTo?: string | null
    content?: string | null
    design?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutEmailCampaignsInput
    template?: EmailTemplateCreateNestedOneWithoutCampaignsInput
    lists?: ListCreateNestedManyWithoutEmailCampaignsInput
    activities?: EmailActivityCreateNestedManyWithoutCampaignInput
  }

  export type EmailCampaignUncheckedCreateWithoutSegmentsInput = {
    id?: string
    name: string
    description?: string | null
    subject: string
    from: string
    replyTo?: string | null
    templateId?: string | null
    content?: string | null
    design?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    lists?: ListUncheckedCreateNestedManyWithoutEmailCampaignsInput
    activities?: EmailActivityUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type EmailCampaignCreateOrConnectWithoutSegmentsInput = {
    where: EmailCampaignWhereUniqueInput
    create: XOR<EmailCampaignCreateWithoutSegmentsInput, EmailCampaignUncheckedCreateWithoutSegmentsInput>
  }

  export type SMSCampaignCreateWithoutSegmentsInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutSmsCampaignsInput
    template?: SMSTemplateCreateNestedOneWithoutCampaignsInput
    lists?: ListCreateNestedManyWithoutSmsCampaignsInput
    activities?: SMSActivityCreateNestedManyWithoutCampaignInput
  }

  export type SMSCampaignUncheckedCreateWithoutSegmentsInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    templateId?: string | null
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    lists?: ListUncheckedCreateNestedManyWithoutSmsCampaignsInput
    activities?: SMSActivityUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type SMSCampaignCreateOrConnectWithoutSegmentsInput = {
    where: SMSCampaignWhereUniqueInput
    create: XOR<SMSCampaignCreateWithoutSegmentsInput, SMSCampaignUncheckedCreateWithoutSegmentsInput>
  }

  export type WhatsAppCampaignCreateWithoutSegmentsInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutWaCampaignsInput
    template?: WhatsAppTemplateCreateNestedOneWithoutCampaignsInput
    lists?: ListCreateNestedManyWithoutWaCampaignsInput
    activities?: WhatsAppActivityCreateNestedManyWithoutCampaignInput
  }

  export type WhatsAppCampaignUncheckedCreateWithoutSegmentsInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    templateId?: string | null
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    lists?: ListUncheckedCreateNestedManyWithoutWaCampaignsInput
    activities?: WhatsAppActivityUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type WhatsAppCampaignCreateOrConnectWithoutSegmentsInput = {
    where: WhatsAppCampaignWhereUniqueInput
    create: XOR<WhatsAppCampaignCreateWithoutSegmentsInput, WhatsAppCampaignUncheckedCreateWithoutSegmentsInput>
  }

  export type UserUpsertWithoutSegmentsInput = {
    update: XOR<UserUpdateWithoutSegmentsInput, UserUncheckedUpdateWithoutSegmentsInput>
    create: XOR<UserCreateWithoutSegmentsInput, UserUncheckedCreateWithoutSegmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSegmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSegmentsInput, UserUncheckedUpdateWithoutSegmentsInput>
  }

  export type UserUpdateWithoutSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutCreatedByNestedInput
    emailCampaigns?: EmailCampaignUpdateManyWithoutCreatedByNestedInput
    emailTemplates?: EmailTemplateUpdateManyWithoutCreatedByNestedInput
    smsCampaigns?: SMSCampaignUpdateManyWithoutCreatedByNestedInput
    smsTemplates?: SMSTemplateUpdateManyWithoutCreatedByNestedInput
    waCampaigns?: WhatsAppCampaignUpdateManyWithoutCreatedByNestedInput
    waTemplates?: WhatsAppTemplateUpdateManyWithoutCreatedByNestedInput
    workflows?: WorkflowUpdateManyWithoutCreatedByNestedInput
    lists?: ListUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCreatedByNestedInput
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    emailTemplates?: EmailTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    smsCampaigns?: SMSCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    smsTemplates?: SMSTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    waCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    waTemplates?: WhatsAppTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput
    lists?: ListUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type EmailCampaignUpsertWithWhereUniqueWithoutSegmentsInput = {
    where: EmailCampaignWhereUniqueInput
    update: XOR<EmailCampaignUpdateWithoutSegmentsInput, EmailCampaignUncheckedUpdateWithoutSegmentsInput>
    create: XOR<EmailCampaignCreateWithoutSegmentsInput, EmailCampaignUncheckedCreateWithoutSegmentsInput>
  }

  export type EmailCampaignUpdateWithWhereUniqueWithoutSegmentsInput = {
    where: EmailCampaignWhereUniqueInput
    data: XOR<EmailCampaignUpdateWithoutSegmentsInput, EmailCampaignUncheckedUpdateWithoutSegmentsInput>
  }

  export type EmailCampaignUpdateManyWithWhereWithoutSegmentsInput = {
    where: EmailCampaignScalarWhereInput
    data: XOR<EmailCampaignUpdateManyMutationInput, EmailCampaignUncheckedUpdateManyWithoutSegmentsInput>
  }

  export type SMSCampaignUpsertWithWhereUniqueWithoutSegmentsInput = {
    where: SMSCampaignWhereUniqueInput
    update: XOR<SMSCampaignUpdateWithoutSegmentsInput, SMSCampaignUncheckedUpdateWithoutSegmentsInput>
    create: XOR<SMSCampaignCreateWithoutSegmentsInput, SMSCampaignUncheckedCreateWithoutSegmentsInput>
  }

  export type SMSCampaignUpdateWithWhereUniqueWithoutSegmentsInput = {
    where: SMSCampaignWhereUniqueInput
    data: XOR<SMSCampaignUpdateWithoutSegmentsInput, SMSCampaignUncheckedUpdateWithoutSegmentsInput>
  }

  export type SMSCampaignUpdateManyWithWhereWithoutSegmentsInput = {
    where: SMSCampaignScalarWhereInput
    data: XOR<SMSCampaignUpdateManyMutationInput, SMSCampaignUncheckedUpdateManyWithoutSegmentsInput>
  }

  export type WhatsAppCampaignUpsertWithWhereUniqueWithoutSegmentsInput = {
    where: WhatsAppCampaignWhereUniqueInput
    update: XOR<WhatsAppCampaignUpdateWithoutSegmentsInput, WhatsAppCampaignUncheckedUpdateWithoutSegmentsInput>
    create: XOR<WhatsAppCampaignCreateWithoutSegmentsInput, WhatsAppCampaignUncheckedCreateWithoutSegmentsInput>
  }

  export type WhatsAppCampaignUpdateWithWhereUniqueWithoutSegmentsInput = {
    where: WhatsAppCampaignWhereUniqueInput
    data: XOR<WhatsAppCampaignUpdateWithoutSegmentsInput, WhatsAppCampaignUncheckedUpdateWithoutSegmentsInput>
  }

  export type WhatsAppCampaignUpdateManyWithWhereWithoutSegmentsInput = {
    where: WhatsAppCampaignScalarWhereInput
    data: XOR<WhatsAppCampaignUpdateManyMutationInput, WhatsAppCampaignUncheckedUpdateManyWithoutSegmentsInput>
  }

  export type UserCreateWithoutEmailTemplatesInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutCreatedByInput
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutCreatedByInput
    smsCampaigns?: SMSCampaignCreateNestedManyWithoutCreatedByInput
    smsTemplates?: SMSTemplateCreateNestedManyWithoutCreatedByInput
    waCampaigns?: WhatsAppCampaignCreateNestedManyWithoutCreatedByInput
    waTemplates?: WhatsAppTemplateCreateNestedManyWithoutCreatedByInput
    workflows?: WorkflowCreateNestedManyWithoutCreatedByInput
    lists?: ListCreateNestedManyWithoutCreatedByInput
    segments?: SegmentCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutEmailTemplatesInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCreatedByInput
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    smsCampaigns?: SMSCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    smsTemplates?: SMSTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    waCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    waTemplates?: WhatsAppTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutCreatedByInput
    lists?: ListUncheckedCreateNestedManyWithoutCreatedByInput
    segments?: SegmentUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutEmailTemplatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailTemplatesInput, UserUncheckedCreateWithoutEmailTemplatesInput>
  }

  export type EmailCampaignCreateWithoutTemplateInput = {
    id?: string
    name: string
    description?: string | null
    subject: string
    from: string
    replyTo?: string | null
    content?: string | null
    design?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutEmailCampaignsInput
    lists?: ListCreateNestedManyWithoutEmailCampaignsInput
    segments?: SegmentCreateNestedManyWithoutEmailCampaignsInput
    activities?: EmailActivityCreateNestedManyWithoutCampaignInput
  }

  export type EmailCampaignUncheckedCreateWithoutTemplateInput = {
    id?: string
    name: string
    description?: string | null
    subject: string
    from: string
    replyTo?: string | null
    content?: string | null
    design?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    lists?: ListUncheckedCreateNestedManyWithoutEmailCampaignsInput
    segments?: SegmentUncheckedCreateNestedManyWithoutEmailCampaignsInput
    activities?: EmailActivityUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type EmailCampaignCreateOrConnectWithoutTemplateInput = {
    where: EmailCampaignWhereUniqueInput
    create: XOR<EmailCampaignCreateWithoutTemplateInput, EmailCampaignUncheckedCreateWithoutTemplateInput>
  }

  export type EmailCampaignCreateManyTemplateInputEnvelope = {
    data: EmailCampaignCreateManyTemplateInput | EmailCampaignCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEmailTemplatesInput = {
    update: XOR<UserUpdateWithoutEmailTemplatesInput, UserUncheckedUpdateWithoutEmailTemplatesInput>
    create: XOR<UserCreateWithoutEmailTemplatesInput, UserUncheckedCreateWithoutEmailTemplatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailTemplatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailTemplatesInput, UserUncheckedUpdateWithoutEmailTemplatesInput>
  }

  export type UserUpdateWithoutEmailTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutCreatedByNestedInput
    emailCampaigns?: EmailCampaignUpdateManyWithoutCreatedByNestedInput
    smsCampaigns?: SMSCampaignUpdateManyWithoutCreatedByNestedInput
    smsTemplates?: SMSTemplateUpdateManyWithoutCreatedByNestedInput
    waCampaigns?: WhatsAppCampaignUpdateManyWithoutCreatedByNestedInput
    waTemplates?: WhatsAppTemplateUpdateManyWithoutCreatedByNestedInput
    workflows?: WorkflowUpdateManyWithoutCreatedByNestedInput
    lists?: ListUpdateManyWithoutCreatedByNestedInput
    segments?: SegmentUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCreatedByNestedInput
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    smsCampaigns?: SMSCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    smsTemplates?: SMSTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    waCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    waTemplates?: WhatsAppTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput
    lists?: ListUncheckedUpdateManyWithoutCreatedByNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type EmailCampaignUpsertWithWhereUniqueWithoutTemplateInput = {
    where: EmailCampaignWhereUniqueInput
    update: XOR<EmailCampaignUpdateWithoutTemplateInput, EmailCampaignUncheckedUpdateWithoutTemplateInput>
    create: XOR<EmailCampaignCreateWithoutTemplateInput, EmailCampaignUncheckedCreateWithoutTemplateInput>
  }

  export type EmailCampaignUpdateWithWhereUniqueWithoutTemplateInput = {
    where: EmailCampaignWhereUniqueInput
    data: XOR<EmailCampaignUpdateWithoutTemplateInput, EmailCampaignUncheckedUpdateWithoutTemplateInput>
  }

  export type EmailCampaignUpdateManyWithWhereWithoutTemplateInput = {
    where: EmailCampaignScalarWhereInput
    data: XOR<EmailCampaignUpdateManyMutationInput, EmailCampaignUncheckedUpdateManyWithoutTemplateInput>
  }

  export type UserCreateWithoutEmailCampaignsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutCreatedByInput
    emailTemplates?: EmailTemplateCreateNestedManyWithoutCreatedByInput
    smsCampaigns?: SMSCampaignCreateNestedManyWithoutCreatedByInput
    smsTemplates?: SMSTemplateCreateNestedManyWithoutCreatedByInput
    waCampaigns?: WhatsAppCampaignCreateNestedManyWithoutCreatedByInput
    waTemplates?: WhatsAppTemplateCreateNestedManyWithoutCreatedByInput
    workflows?: WorkflowCreateNestedManyWithoutCreatedByInput
    lists?: ListCreateNestedManyWithoutCreatedByInput
    segments?: SegmentCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutEmailCampaignsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCreatedByInput
    emailTemplates?: EmailTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    smsCampaigns?: SMSCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    smsTemplates?: SMSTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    waCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    waTemplates?: WhatsAppTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutCreatedByInput
    lists?: ListUncheckedCreateNestedManyWithoutCreatedByInput
    segments?: SegmentUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutEmailCampaignsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailCampaignsInput, UserUncheckedCreateWithoutEmailCampaignsInput>
  }

  export type EmailTemplateCreateWithoutCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    subject: string
    content: string
    design?: string | null
    previewText?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutEmailTemplatesInput
  }

  export type EmailTemplateUncheckedCreateWithoutCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    subject: string
    content: string
    design?: string | null
    previewText?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type EmailTemplateCreateOrConnectWithoutCampaignsInput = {
    where: EmailTemplateWhereUniqueInput
    create: XOR<EmailTemplateCreateWithoutCampaignsInput, EmailTemplateUncheckedCreateWithoutCampaignsInput>
  }

  export type ListCreateWithoutEmailCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    type?: $Enums.ListType
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutListsInput
    members?: ListMemberCreateNestedManyWithoutListInput
    smsCampaigns?: SMSCampaignCreateNestedManyWithoutListsInput
    waCampaigns?: WhatsAppCampaignCreateNestedManyWithoutListsInput
  }

  export type ListUncheckedCreateWithoutEmailCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    type?: $Enums.ListType
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    members?: ListMemberUncheckedCreateNestedManyWithoutListInput
    smsCampaigns?: SMSCampaignUncheckedCreateNestedManyWithoutListsInput
    waCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutListsInput
  }

  export type ListCreateOrConnectWithoutEmailCampaignsInput = {
    where: ListWhereUniqueInput
    create: XOR<ListCreateWithoutEmailCampaignsInput, ListUncheckedCreateWithoutEmailCampaignsInput>
  }

  export type SegmentCreateWithoutEmailCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    rules: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutSegmentsInput
    smsCampaigns?: SMSCampaignCreateNestedManyWithoutSegmentsInput
    waCampaigns?: WhatsAppCampaignCreateNestedManyWithoutSegmentsInput
  }

  export type SegmentUncheckedCreateWithoutEmailCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    rules: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    smsCampaigns?: SMSCampaignUncheckedCreateNestedManyWithoutSegmentsInput
    waCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutSegmentsInput
  }

  export type SegmentCreateOrConnectWithoutEmailCampaignsInput = {
    where: SegmentWhereUniqueInput
    create: XOR<SegmentCreateWithoutEmailCampaignsInput, SegmentUncheckedCreateWithoutEmailCampaignsInput>
  }

  export type EmailActivityCreateWithoutCampaignInput = {
    id?: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
    contact: ContactCreateNestedOneWithoutEmailActivitiesInput
  }

  export type EmailActivityUncheckedCreateWithoutCampaignInput = {
    id?: string
    contactId: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
  }

  export type EmailActivityCreateOrConnectWithoutCampaignInput = {
    where: EmailActivityWhereUniqueInput
    create: XOR<EmailActivityCreateWithoutCampaignInput, EmailActivityUncheckedCreateWithoutCampaignInput>
  }

  export type EmailActivityCreateManyCampaignInputEnvelope = {
    data: EmailActivityCreateManyCampaignInput | EmailActivityCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEmailCampaignsInput = {
    update: XOR<UserUpdateWithoutEmailCampaignsInput, UserUncheckedUpdateWithoutEmailCampaignsInput>
    create: XOR<UserCreateWithoutEmailCampaignsInput, UserUncheckedCreateWithoutEmailCampaignsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailCampaignsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailCampaignsInput, UserUncheckedUpdateWithoutEmailCampaignsInput>
  }

  export type UserUpdateWithoutEmailCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutCreatedByNestedInput
    emailTemplates?: EmailTemplateUpdateManyWithoutCreatedByNestedInput
    smsCampaigns?: SMSCampaignUpdateManyWithoutCreatedByNestedInput
    smsTemplates?: SMSTemplateUpdateManyWithoutCreatedByNestedInput
    waCampaigns?: WhatsAppCampaignUpdateManyWithoutCreatedByNestedInput
    waTemplates?: WhatsAppTemplateUpdateManyWithoutCreatedByNestedInput
    workflows?: WorkflowUpdateManyWithoutCreatedByNestedInput
    lists?: ListUpdateManyWithoutCreatedByNestedInput
    segments?: SegmentUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCreatedByNestedInput
    emailTemplates?: EmailTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    smsCampaigns?: SMSCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    smsTemplates?: SMSTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    waCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    waTemplates?: WhatsAppTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput
    lists?: ListUncheckedUpdateManyWithoutCreatedByNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type EmailTemplateUpsertWithoutCampaignsInput = {
    update: XOR<EmailTemplateUpdateWithoutCampaignsInput, EmailTemplateUncheckedUpdateWithoutCampaignsInput>
    create: XOR<EmailTemplateCreateWithoutCampaignsInput, EmailTemplateUncheckedCreateWithoutCampaignsInput>
    where?: EmailTemplateWhereInput
  }

  export type EmailTemplateUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: EmailTemplateWhereInput
    data: XOR<EmailTemplateUpdateWithoutCampaignsInput, EmailTemplateUncheckedUpdateWithoutCampaignsInput>
  }

  export type EmailTemplateUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    design?: NullableStringFieldUpdateOperationsInput | string | null
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutEmailTemplatesNestedInput
  }

  export type EmailTemplateUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    design?: NullableStringFieldUpdateOperationsInput | string | null
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type ListUpsertWithWhereUniqueWithoutEmailCampaignsInput = {
    where: ListWhereUniqueInput
    update: XOR<ListUpdateWithoutEmailCampaignsInput, ListUncheckedUpdateWithoutEmailCampaignsInput>
    create: XOR<ListCreateWithoutEmailCampaignsInput, ListUncheckedCreateWithoutEmailCampaignsInput>
  }

  export type ListUpdateWithWhereUniqueWithoutEmailCampaignsInput = {
    where: ListWhereUniqueInput
    data: XOR<ListUpdateWithoutEmailCampaignsInput, ListUncheckedUpdateWithoutEmailCampaignsInput>
  }

  export type ListUpdateManyWithWhereWithoutEmailCampaignsInput = {
    where: ListScalarWhereInput
    data: XOR<ListUpdateManyMutationInput, ListUncheckedUpdateManyWithoutEmailCampaignsInput>
  }

  export type SegmentUpsertWithWhereUniqueWithoutEmailCampaignsInput = {
    where: SegmentWhereUniqueInput
    update: XOR<SegmentUpdateWithoutEmailCampaignsInput, SegmentUncheckedUpdateWithoutEmailCampaignsInput>
    create: XOR<SegmentCreateWithoutEmailCampaignsInput, SegmentUncheckedCreateWithoutEmailCampaignsInput>
  }

  export type SegmentUpdateWithWhereUniqueWithoutEmailCampaignsInput = {
    where: SegmentWhereUniqueInput
    data: XOR<SegmentUpdateWithoutEmailCampaignsInput, SegmentUncheckedUpdateWithoutEmailCampaignsInput>
  }

  export type SegmentUpdateManyWithWhereWithoutEmailCampaignsInput = {
    where: SegmentScalarWhereInput
    data: XOR<SegmentUpdateManyMutationInput, SegmentUncheckedUpdateManyWithoutEmailCampaignsInput>
  }

  export type EmailActivityUpsertWithWhereUniqueWithoutCampaignInput = {
    where: EmailActivityWhereUniqueInput
    update: XOR<EmailActivityUpdateWithoutCampaignInput, EmailActivityUncheckedUpdateWithoutCampaignInput>
    create: XOR<EmailActivityCreateWithoutCampaignInput, EmailActivityUncheckedCreateWithoutCampaignInput>
  }

  export type EmailActivityUpdateWithWhereUniqueWithoutCampaignInput = {
    where: EmailActivityWhereUniqueInput
    data: XOR<EmailActivityUpdateWithoutCampaignInput, EmailActivityUncheckedUpdateWithoutCampaignInput>
  }

  export type EmailActivityUpdateManyWithWhereWithoutCampaignInput = {
    where: EmailActivityScalarWhereInput
    data: XOR<EmailActivityUpdateManyMutationInput, EmailActivityUncheckedUpdateManyWithoutCampaignInput>
  }

  export type EmailCampaignCreateWithoutActivitiesInput = {
    id?: string
    name: string
    description?: string | null
    subject: string
    from: string
    replyTo?: string | null
    content?: string | null
    design?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutEmailCampaignsInput
    template?: EmailTemplateCreateNestedOneWithoutCampaignsInput
    lists?: ListCreateNestedManyWithoutEmailCampaignsInput
    segments?: SegmentCreateNestedManyWithoutEmailCampaignsInput
  }

  export type EmailCampaignUncheckedCreateWithoutActivitiesInput = {
    id?: string
    name: string
    description?: string | null
    subject: string
    from: string
    replyTo?: string | null
    templateId?: string | null
    content?: string | null
    design?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    lists?: ListUncheckedCreateNestedManyWithoutEmailCampaignsInput
    segments?: SegmentUncheckedCreateNestedManyWithoutEmailCampaignsInput
  }

  export type EmailCampaignCreateOrConnectWithoutActivitiesInput = {
    where: EmailCampaignWhereUniqueInput
    create: XOR<EmailCampaignCreateWithoutActivitiesInput, EmailCampaignUncheckedCreateWithoutActivitiesInput>
  }

  export type ContactCreateWithoutEmailActivitiesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    jobTitle?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    notes?: string | null
    tagsString?: string | null
    source?: string | null
    status?: $Enums.ContactStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutContactsInput
    listMembers?: ListMemberCreateNestedManyWithoutContactInput
    smsActivities?: SMSActivityCreateNestedManyWithoutContactInput
    waActivities?: WhatsAppActivityCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutEmailActivitiesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    jobTitle?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    notes?: string | null
    tagsString?: string | null
    source?: string | null
    status?: $Enums.ContactStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    listMembers?: ListMemberUncheckedCreateNestedManyWithoutContactInput
    smsActivities?: SMSActivityUncheckedCreateNestedManyWithoutContactInput
    waActivities?: WhatsAppActivityUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutEmailActivitiesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutEmailActivitiesInput, ContactUncheckedCreateWithoutEmailActivitiesInput>
  }

  export type EmailCampaignUpsertWithoutActivitiesInput = {
    update: XOR<EmailCampaignUpdateWithoutActivitiesInput, EmailCampaignUncheckedUpdateWithoutActivitiesInput>
    create: XOR<EmailCampaignCreateWithoutActivitiesInput, EmailCampaignUncheckedCreateWithoutActivitiesInput>
    where?: EmailCampaignWhereInput
  }

  export type EmailCampaignUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: EmailCampaignWhereInput
    data: XOR<EmailCampaignUpdateWithoutActivitiesInput, EmailCampaignUncheckedUpdateWithoutActivitiesInput>
  }

  export type EmailCampaignUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutEmailCampaignsNestedInput
    template?: EmailTemplateUpdateOneWithoutCampaignsNestedInput
    lists?: ListUpdateManyWithoutEmailCampaignsNestedInput
    segments?: SegmentUpdateManyWithoutEmailCampaignsNestedInput
  }

  export type EmailCampaignUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    lists?: ListUncheckedUpdateManyWithoutEmailCampaignsNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutEmailCampaignsNestedInput
  }

  export type ContactUpsertWithoutEmailActivitiesInput = {
    update: XOR<ContactUpdateWithoutEmailActivitiesInput, ContactUncheckedUpdateWithoutEmailActivitiesInput>
    create: XOR<ContactCreateWithoutEmailActivitiesInput, ContactUncheckedCreateWithoutEmailActivitiesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutEmailActivitiesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutEmailActivitiesInput, ContactUncheckedUpdateWithoutEmailActivitiesInput>
  }

  export type ContactUpdateWithoutEmailActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tagsString?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutContactsNestedInput
    listMembers?: ListMemberUpdateManyWithoutContactNestedInput
    smsActivities?: SMSActivityUpdateManyWithoutContactNestedInput
    waActivities?: WhatsAppActivityUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutEmailActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tagsString?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    listMembers?: ListMemberUncheckedUpdateManyWithoutContactNestedInput
    smsActivities?: SMSActivityUncheckedUpdateManyWithoutContactNestedInput
    waActivities?: WhatsAppActivityUncheckedUpdateManyWithoutContactNestedInput
  }

  export type UserCreateWithoutSmsTemplatesInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutCreatedByInput
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutCreatedByInput
    emailTemplates?: EmailTemplateCreateNestedManyWithoutCreatedByInput
    smsCampaigns?: SMSCampaignCreateNestedManyWithoutCreatedByInput
    waCampaigns?: WhatsAppCampaignCreateNestedManyWithoutCreatedByInput
    waTemplates?: WhatsAppTemplateCreateNestedManyWithoutCreatedByInput
    workflows?: WorkflowCreateNestedManyWithoutCreatedByInput
    lists?: ListCreateNestedManyWithoutCreatedByInput
    segments?: SegmentCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutSmsTemplatesInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCreatedByInput
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    emailTemplates?: EmailTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    smsCampaigns?: SMSCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    waCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    waTemplates?: WhatsAppTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutCreatedByInput
    lists?: ListUncheckedCreateNestedManyWithoutCreatedByInput
    segments?: SegmentUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutSmsTemplatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSmsTemplatesInput, UserUncheckedCreateWithoutSmsTemplatesInput>
  }

  export type SMSCampaignCreateWithoutTemplateInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutSmsCampaignsInput
    lists?: ListCreateNestedManyWithoutSmsCampaignsInput
    segments?: SegmentCreateNestedManyWithoutSmsCampaignsInput
    activities?: SMSActivityCreateNestedManyWithoutCampaignInput
  }

  export type SMSCampaignUncheckedCreateWithoutTemplateInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    lists?: ListUncheckedCreateNestedManyWithoutSmsCampaignsInput
    segments?: SegmentUncheckedCreateNestedManyWithoutSmsCampaignsInput
    activities?: SMSActivityUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type SMSCampaignCreateOrConnectWithoutTemplateInput = {
    where: SMSCampaignWhereUniqueInput
    create: XOR<SMSCampaignCreateWithoutTemplateInput, SMSCampaignUncheckedCreateWithoutTemplateInput>
  }

  export type SMSCampaignCreateManyTemplateInputEnvelope = {
    data: SMSCampaignCreateManyTemplateInput | SMSCampaignCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSmsTemplatesInput = {
    update: XOR<UserUpdateWithoutSmsTemplatesInput, UserUncheckedUpdateWithoutSmsTemplatesInput>
    create: XOR<UserCreateWithoutSmsTemplatesInput, UserUncheckedCreateWithoutSmsTemplatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSmsTemplatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSmsTemplatesInput, UserUncheckedUpdateWithoutSmsTemplatesInput>
  }

  export type UserUpdateWithoutSmsTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutCreatedByNestedInput
    emailCampaigns?: EmailCampaignUpdateManyWithoutCreatedByNestedInput
    emailTemplates?: EmailTemplateUpdateManyWithoutCreatedByNestedInput
    smsCampaigns?: SMSCampaignUpdateManyWithoutCreatedByNestedInput
    waCampaigns?: WhatsAppCampaignUpdateManyWithoutCreatedByNestedInput
    waTemplates?: WhatsAppTemplateUpdateManyWithoutCreatedByNestedInput
    workflows?: WorkflowUpdateManyWithoutCreatedByNestedInput
    lists?: ListUpdateManyWithoutCreatedByNestedInput
    segments?: SegmentUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSmsTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCreatedByNestedInput
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    emailTemplates?: EmailTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    smsCampaigns?: SMSCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    waCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    waTemplates?: WhatsAppTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput
    lists?: ListUncheckedUpdateManyWithoutCreatedByNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type SMSCampaignUpsertWithWhereUniqueWithoutTemplateInput = {
    where: SMSCampaignWhereUniqueInput
    update: XOR<SMSCampaignUpdateWithoutTemplateInput, SMSCampaignUncheckedUpdateWithoutTemplateInput>
    create: XOR<SMSCampaignCreateWithoutTemplateInput, SMSCampaignUncheckedCreateWithoutTemplateInput>
  }

  export type SMSCampaignUpdateWithWhereUniqueWithoutTemplateInput = {
    where: SMSCampaignWhereUniqueInput
    data: XOR<SMSCampaignUpdateWithoutTemplateInput, SMSCampaignUncheckedUpdateWithoutTemplateInput>
  }

  export type SMSCampaignUpdateManyWithWhereWithoutTemplateInput = {
    where: SMSCampaignScalarWhereInput
    data: XOR<SMSCampaignUpdateManyMutationInput, SMSCampaignUncheckedUpdateManyWithoutTemplateInput>
  }

  export type UserCreateWithoutSmsCampaignsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutCreatedByInput
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutCreatedByInput
    emailTemplates?: EmailTemplateCreateNestedManyWithoutCreatedByInput
    smsTemplates?: SMSTemplateCreateNestedManyWithoutCreatedByInput
    waCampaigns?: WhatsAppCampaignCreateNestedManyWithoutCreatedByInput
    waTemplates?: WhatsAppTemplateCreateNestedManyWithoutCreatedByInput
    workflows?: WorkflowCreateNestedManyWithoutCreatedByInput
    lists?: ListCreateNestedManyWithoutCreatedByInput
    segments?: SegmentCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutSmsCampaignsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCreatedByInput
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    emailTemplates?: EmailTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    smsTemplates?: SMSTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    waCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    waTemplates?: WhatsAppTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutCreatedByInput
    lists?: ListUncheckedCreateNestedManyWithoutCreatedByInput
    segments?: SegmentUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutSmsCampaignsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSmsCampaignsInput, UserUncheckedCreateWithoutSmsCampaignsInput>
  }

  export type SMSTemplateCreateWithoutCampaignsInput = {
    id?: string
    name: string
    content: string
    variables: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutSmsTemplatesInput
  }

  export type SMSTemplateUncheckedCreateWithoutCampaignsInput = {
    id?: string
    name: string
    content: string
    variables: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type SMSTemplateCreateOrConnectWithoutCampaignsInput = {
    where: SMSTemplateWhereUniqueInput
    create: XOR<SMSTemplateCreateWithoutCampaignsInput, SMSTemplateUncheckedCreateWithoutCampaignsInput>
  }

  export type ListCreateWithoutSmsCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    type?: $Enums.ListType
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutListsInput
    members?: ListMemberCreateNestedManyWithoutListInput
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutListsInput
    waCampaigns?: WhatsAppCampaignCreateNestedManyWithoutListsInput
  }

  export type ListUncheckedCreateWithoutSmsCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    type?: $Enums.ListType
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    members?: ListMemberUncheckedCreateNestedManyWithoutListInput
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutListsInput
    waCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutListsInput
  }

  export type ListCreateOrConnectWithoutSmsCampaignsInput = {
    where: ListWhereUniqueInput
    create: XOR<ListCreateWithoutSmsCampaignsInput, ListUncheckedCreateWithoutSmsCampaignsInput>
  }

  export type SegmentCreateWithoutSmsCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    rules: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutSegmentsInput
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutSegmentsInput
    waCampaigns?: WhatsAppCampaignCreateNestedManyWithoutSegmentsInput
  }

  export type SegmentUncheckedCreateWithoutSmsCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    rules: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutSegmentsInput
    waCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutSegmentsInput
  }

  export type SegmentCreateOrConnectWithoutSmsCampaignsInput = {
    where: SegmentWhereUniqueInput
    create: XOR<SegmentCreateWithoutSmsCampaignsInput, SegmentUncheckedCreateWithoutSmsCampaignsInput>
  }

  export type SMSActivityCreateWithoutCampaignInput = {
    id?: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
    contact: ContactCreateNestedOneWithoutSmsActivitiesInput
  }

  export type SMSActivityUncheckedCreateWithoutCampaignInput = {
    id?: string
    contactId: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
  }

  export type SMSActivityCreateOrConnectWithoutCampaignInput = {
    where: SMSActivityWhereUniqueInput
    create: XOR<SMSActivityCreateWithoutCampaignInput, SMSActivityUncheckedCreateWithoutCampaignInput>
  }

  export type SMSActivityCreateManyCampaignInputEnvelope = {
    data: SMSActivityCreateManyCampaignInput | SMSActivityCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSmsCampaignsInput = {
    update: XOR<UserUpdateWithoutSmsCampaignsInput, UserUncheckedUpdateWithoutSmsCampaignsInput>
    create: XOR<UserCreateWithoutSmsCampaignsInput, UserUncheckedCreateWithoutSmsCampaignsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSmsCampaignsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSmsCampaignsInput, UserUncheckedUpdateWithoutSmsCampaignsInput>
  }

  export type UserUpdateWithoutSmsCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutCreatedByNestedInput
    emailCampaigns?: EmailCampaignUpdateManyWithoutCreatedByNestedInput
    emailTemplates?: EmailTemplateUpdateManyWithoutCreatedByNestedInput
    smsTemplates?: SMSTemplateUpdateManyWithoutCreatedByNestedInput
    waCampaigns?: WhatsAppCampaignUpdateManyWithoutCreatedByNestedInput
    waTemplates?: WhatsAppTemplateUpdateManyWithoutCreatedByNestedInput
    workflows?: WorkflowUpdateManyWithoutCreatedByNestedInput
    lists?: ListUpdateManyWithoutCreatedByNestedInput
    segments?: SegmentUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSmsCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCreatedByNestedInput
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    emailTemplates?: EmailTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    smsTemplates?: SMSTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    waCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    waTemplates?: WhatsAppTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput
    lists?: ListUncheckedUpdateManyWithoutCreatedByNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type SMSTemplateUpsertWithoutCampaignsInput = {
    update: XOR<SMSTemplateUpdateWithoutCampaignsInput, SMSTemplateUncheckedUpdateWithoutCampaignsInput>
    create: XOR<SMSTemplateCreateWithoutCampaignsInput, SMSTemplateUncheckedCreateWithoutCampaignsInput>
    where?: SMSTemplateWhereInput
  }

  export type SMSTemplateUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: SMSTemplateWhereInput
    data: XOR<SMSTemplateUpdateWithoutCampaignsInput, SMSTemplateUncheckedUpdateWithoutCampaignsInput>
  }

  export type SMSTemplateUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutSmsTemplatesNestedInput
  }

  export type SMSTemplateUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type ListUpsertWithWhereUniqueWithoutSmsCampaignsInput = {
    where: ListWhereUniqueInput
    update: XOR<ListUpdateWithoutSmsCampaignsInput, ListUncheckedUpdateWithoutSmsCampaignsInput>
    create: XOR<ListCreateWithoutSmsCampaignsInput, ListUncheckedCreateWithoutSmsCampaignsInput>
  }

  export type ListUpdateWithWhereUniqueWithoutSmsCampaignsInput = {
    where: ListWhereUniqueInput
    data: XOR<ListUpdateWithoutSmsCampaignsInput, ListUncheckedUpdateWithoutSmsCampaignsInput>
  }

  export type ListUpdateManyWithWhereWithoutSmsCampaignsInput = {
    where: ListScalarWhereInput
    data: XOR<ListUpdateManyMutationInput, ListUncheckedUpdateManyWithoutSmsCampaignsInput>
  }

  export type SegmentUpsertWithWhereUniqueWithoutSmsCampaignsInput = {
    where: SegmentWhereUniqueInput
    update: XOR<SegmentUpdateWithoutSmsCampaignsInput, SegmentUncheckedUpdateWithoutSmsCampaignsInput>
    create: XOR<SegmentCreateWithoutSmsCampaignsInput, SegmentUncheckedCreateWithoutSmsCampaignsInput>
  }

  export type SegmentUpdateWithWhereUniqueWithoutSmsCampaignsInput = {
    where: SegmentWhereUniqueInput
    data: XOR<SegmentUpdateWithoutSmsCampaignsInput, SegmentUncheckedUpdateWithoutSmsCampaignsInput>
  }

  export type SegmentUpdateManyWithWhereWithoutSmsCampaignsInput = {
    where: SegmentScalarWhereInput
    data: XOR<SegmentUpdateManyMutationInput, SegmentUncheckedUpdateManyWithoutSmsCampaignsInput>
  }

  export type SMSActivityUpsertWithWhereUniqueWithoutCampaignInput = {
    where: SMSActivityWhereUniqueInput
    update: XOR<SMSActivityUpdateWithoutCampaignInput, SMSActivityUncheckedUpdateWithoutCampaignInput>
    create: XOR<SMSActivityCreateWithoutCampaignInput, SMSActivityUncheckedCreateWithoutCampaignInput>
  }

  export type SMSActivityUpdateWithWhereUniqueWithoutCampaignInput = {
    where: SMSActivityWhereUniqueInput
    data: XOR<SMSActivityUpdateWithoutCampaignInput, SMSActivityUncheckedUpdateWithoutCampaignInput>
  }

  export type SMSActivityUpdateManyWithWhereWithoutCampaignInput = {
    where: SMSActivityScalarWhereInput
    data: XOR<SMSActivityUpdateManyMutationInput, SMSActivityUncheckedUpdateManyWithoutCampaignInput>
  }

  export type SMSCampaignCreateWithoutActivitiesInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutSmsCampaignsInput
    template?: SMSTemplateCreateNestedOneWithoutCampaignsInput
    lists?: ListCreateNestedManyWithoutSmsCampaignsInput
    segments?: SegmentCreateNestedManyWithoutSmsCampaignsInput
  }

  export type SMSCampaignUncheckedCreateWithoutActivitiesInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    templateId?: string | null
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    lists?: ListUncheckedCreateNestedManyWithoutSmsCampaignsInput
    segments?: SegmentUncheckedCreateNestedManyWithoutSmsCampaignsInput
  }

  export type SMSCampaignCreateOrConnectWithoutActivitiesInput = {
    where: SMSCampaignWhereUniqueInput
    create: XOR<SMSCampaignCreateWithoutActivitiesInput, SMSCampaignUncheckedCreateWithoutActivitiesInput>
  }

  export type ContactCreateWithoutSmsActivitiesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    jobTitle?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    notes?: string | null
    tagsString?: string | null
    source?: string | null
    status?: $Enums.ContactStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutContactsInput
    listMembers?: ListMemberCreateNestedManyWithoutContactInput
    emailActivities?: EmailActivityCreateNestedManyWithoutContactInput
    waActivities?: WhatsAppActivityCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutSmsActivitiesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    jobTitle?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    notes?: string | null
    tagsString?: string | null
    source?: string | null
    status?: $Enums.ContactStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    listMembers?: ListMemberUncheckedCreateNestedManyWithoutContactInput
    emailActivities?: EmailActivityUncheckedCreateNestedManyWithoutContactInput
    waActivities?: WhatsAppActivityUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutSmsActivitiesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutSmsActivitiesInput, ContactUncheckedCreateWithoutSmsActivitiesInput>
  }

  export type SMSCampaignUpsertWithoutActivitiesInput = {
    update: XOR<SMSCampaignUpdateWithoutActivitiesInput, SMSCampaignUncheckedUpdateWithoutActivitiesInput>
    create: XOR<SMSCampaignCreateWithoutActivitiesInput, SMSCampaignUncheckedCreateWithoutActivitiesInput>
    where?: SMSCampaignWhereInput
  }

  export type SMSCampaignUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: SMSCampaignWhereInput
    data: XOR<SMSCampaignUpdateWithoutActivitiesInput, SMSCampaignUncheckedUpdateWithoutActivitiesInput>
  }

  export type SMSCampaignUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutSmsCampaignsNestedInput
    template?: SMSTemplateUpdateOneWithoutCampaignsNestedInput
    lists?: ListUpdateManyWithoutSmsCampaignsNestedInput
    segments?: SegmentUpdateManyWithoutSmsCampaignsNestedInput
  }

  export type SMSCampaignUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    lists?: ListUncheckedUpdateManyWithoutSmsCampaignsNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutSmsCampaignsNestedInput
  }

  export type ContactUpsertWithoutSmsActivitiesInput = {
    update: XOR<ContactUpdateWithoutSmsActivitiesInput, ContactUncheckedUpdateWithoutSmsActivitiesInput>
    create: XOR<ContactCreateWithoutSmsActivitiesInput, ContactUncheckedCreateWithoutSmsActivitiesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutSmsActivitiesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutSmsActivitiesInput, ContactUncheckedUpdateWithoutSmsActivitiesInput>
  }

  export type ContactUpdateWithoutSmsActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tagsString?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutContactsNestedInput
    listMembers?: ListMemberUpdateManyWithoutContactNestedInput
    emailActivities?: EmailActivityUpdateManyWithoutContactNestedInput
    waActivities?: WhatsAppActivityUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutSmsActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tagsString?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    listMembers?: ListMemberUncheckedUpdateManyWithoutContactNestedInput
    emailActivities?: EmailActivityUncheckedUpdateManyWithoutContactNestedInput
    waActivities?: WhatsAppActivityUncheckedUpdateManyWithoutContactNestedInput
  }

  export type UserCreateWithoutWaTemplatesInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutCreatedByInput
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutCreatedByInput
    emailTemplates?: EmailTemplateCreateNestedManyWithoutCreatedByInput
    smsCampaigns?: SMSCampaignCreateNestedManyWithoutCreatedByInput
    smsTemplates?: SMSTemplateCreateNestedManyWithoutCreatedByInput
    waCampaigns?: WhatsAppCampaignCreateNestedManyWithoutCreatedByInput
    workflows?: WorkflowCreateNestedManyWithoutCreatedByInput
    lists?: ListCreateNestedManyWithoutCreatedByInput
    segments?: SegmentCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutWaTemplatesInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCreatedByInput
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    emailTemplates?: EmailTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    smsCampaigns?: SMSCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    smsTemplates?: SMSTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    waCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutCreatedByInput
    lists?: ListUncheckedCreateNestedManyWithoutCreatedByInput
    segments?: SegmentUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutWaTemplatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWaTemplatesInput, UserUncheckedCreateWithoutWaTemplatesInput>
  }

  export type WhatsAppCampaignCreateWithoutTemplateInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutWaCampaignsInput
    lists?: ListCreateNestedManyWithoutWaCampaignsInput
    segments?: SegmentCreateNestedManyWithoutWaCampaignsInput
    activities?: WhatsAppActivityCreateNestedManyWithoutCampaignInput
  }

  export type WhatsAppCampaignUncheckedCreateWithoutTemplateInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    lists?: ListUncheckedCreateNestedManyWithoutWaCampaignsInput
    segments?: SegmentUncheckedCreateNestedManyWithoutWaCampaignsInput
    activities?: WhatsAppActivityUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type WhatsAppCampaignCreateOrConnectWithoutTemplateInput = {
    where: WhatsAppCampaignWhereUniqueInput
    create: XOR<WhatsAppCampaignCreateWithoutTemplateInput, WhatsAppCampaignUncheckedCreateWithoutTemplateInput>
  }

  export type WhatsAppCampaignCreateManyTemplateInputEnvelope = {
    data: WhatsAppCampaignCreateManyTemplateInput | WhatsAppCampaignCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWaTemplatesInput = {
    update: XOR<UserUpdateWithoutWaTemplatesInput, UserUncheckedUpdateWithoutWaTemplatesInput>
    create: XOR<UserCreateWithoutWaTemplatesInput, UserUncheckedCreateWithoutWaTemplatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWaTemplatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWaTemplatesInput, UserUncheckedUpdateWithoutWaTemplatesInput>
  }

  export type UserUpdateWithoutWaTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutCreatedByNestedInput
    emailCampaigns?: EmailCampaignUpdateManyWithoutCreatedByNestedInput
    emailTemplates?: EmailTemplateUpdateManyWithoutCreatedByNestedInput
    smsCampaigns?: SMSCampaignUpdateManyWithoutCreatedByNestedInput
    smsTemplates?: SMSTemplateUpdateManyWithoutCreatedByNestedInput
    waCampaigns?: WhatsAppCampaignUpdateManyWithoutCreatedByNestedInput
    workflows?: WorkflowUpdateManyWithoutCreatedByNestedInput
    lists?: ListUpdateManyWithoutCreatedByNestedInput
    segments?: SegmentUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutWaTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCreatedByNestedInput
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    emailTemplates?: EmailTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    smsCampaigns?: SMSCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    smsTemplates?: SMSTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    waCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput
    lists?: ListUncheckedUpdateManyWithoutCreatedByNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type WhatsAppCampaignUpsertWithWhereUniqueWithoutTemplateInput = {
    where: WhatsAppCampaignWhereUniqueInput
    update: XOR<WhatsAppCampaignUpdateWithoutTemplateInput, WhatsAppCampaignUncheckedUpdateWithoutTemplateInput>
    create: XOR<WhatsAppCampaignCreateWithoutTemplateInput, WhatsAppCampaignUncheckedCreateWithoutTemplateInput>
  }

  export type WhatsAppCampaignUpdateWithWhereUniqueWithoutTemplateInput = {
    where: WhatsAppCampaignWhereUniqueInput
    data: XOR<WhatsAppCampaignUpdateWithoutTemplateInput, WhatsAppCampaignUncheckedUpdateWithoutTemplateInput>
  }

  export type WhatsAppCampaignUpdateManyWithWhereWithoutTemplateInput = {
    where: WhatsAppCampaignScalarWhereInput
    data: XOR<WhatsAppCampaignUpdateManyMutationInput, WhatsAppCampaignUncheckedUpdateManyWithoutTemplateInput>
  }

  export type UserCreateWithoutWaCampaignsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutCreatedByInput
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutCreatedByInput
    emailTemplates?: EmailTemplateCreateNestedManyWithoutCreatedByInput
    smsCampaigns?: SMSCampaignCreateNestedManyWithoutCreatedByInput
    smsTemplates?: SMSTemplateCreateNestedManyWithoutCreatedByInput
    waTemplates?: WhatsAppTemplateCreateNestedManyWithoutCreatedByInput
    workflows?: WorkflowCreateNestedManyWithoutCreatedByInput
    lists?: ListCreateNestedManyWithoutCreatedByInput
    segments?: SegmentCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutWaCampaignsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCreatedByInput
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    emailTemplates?: EmailTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    smsCampaigns?: SMSCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    smsTemplates?: SMSTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    waTemplates?: WhatsAppTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutCreatedByInput
    lists?: ListUncheckedCreateNestedManyWithoutCreatedByInput
    segments?: SegmentUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutWaCampaignsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWaCampaignsInput, UserUncheckedCreateWithoutWaCampaignsInput>
  }

  export type WhatsAppTemplateCreateWithoutCampaignsInput = {
    id?: string
    name: string
    content: string
    variables: string
    category?: string | null
    status?: $Enums.WATemplateStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutWaTemplatesInput
  }

  export type WhatsAppTemplateUncheckedCreateWithoutCampaignsInput = {
    id?: string
    name: string
    content: string
    variables: string
    category?: string | null
    status?: $Enums.WATemplateStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type WhatsAppTemplateCreateOrConnectWithoutCampaignsInput = {
    where: WhatsAppTemplateWhereUniqueInput
    create: XOR<WhatsAppTemplateCreateWithoutCampaignsInput, WhatsAppTemplateUncheckedCreateWithoutCampaignsInput>
  }

  export type ListCreateWithoutWaCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    type?: $Enums.ListType
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutListsInput
    members?: ListMemberCreateNestedManyWithoutListInput
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutListsInput
    smsCampaigns?: SMSCampaignCreateNestedManyWithoutListsInput
  }

  export type ListUncheckedCreateWithoutWaCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    type?: $Enums.ListType
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    members?: ListMemberUncheckedCreateNestedManyWithoutListInput
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutListsInput
    smsCampaigns?: SMSCampaignUncheckedCreateNestedManyWithoutListsInput
  }

  export type ListCreateOrConnectWithoutWaCampaignsInput = {
    where: ListWhereUniqueInput
    create: XOR<ListCreateWithoutWaCampaignsInput, ListUncheckedCreateWithoutWaCampaignsInput>
  }

  export type SegmentCreateWithoutWaCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    rules: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutSegmentsInput
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutSegmentsInput
    smsCampaigns?: SMSCampaignCreateNestedManyWithoutSegmentsInput
  }

  export type SegmentUncheckedCreateWithoutWaCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    rules: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutSegmentsInput
    smsCampaigns?: SMSCampaignUncheckedCreateNestedManyWithoutSegmentsInput
  }

  export type SegmentCreateOrConnectWithoutWaCampaignsInput = {
    where: SegmentWhereUniqueInput
    create: XOR<SegmentCreateWithoutWaCampaignsInput, SegmentUncheckedCreateWithoutWaCampaignsInput>
  }

  export type WhatsAppActivityCreateWithoutCampaignInput = {
    id?: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
    contact: ContactCreateNestedOneWithoutWaActivitiesInput
  }

  export type WhatsAppActivityUncheckedCreateWithoutCampaignInput = {
    id?: string
    contactId: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
  }

  export type WhatsAppActivityCreateOrConnectWithoutCampaignInput = {
    where: WhatsAppActivityWhereUniqueInput
    create: XOR<WhatsAppActivityCreateWithoutCampaignInput, WhatsAppActivityUncheckedCreateWithoutCampaignInput>
  }

  export type WhatsAppActivityCreateManyCampaignInputEnvelope = {
    data: WhatsAppActivityCreateManyCampaignInput | WhatsAppActivityCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWaCampaignsInput = {
    update: XOR<UserUpdateWithoutWaCampaignsInput, UserUncheckedUpdateWithoutWaCampaignsInput>
    create: XOR<UserCreateWithoutWaCampaignsInput, UserUncheckedCreateWithoutWaCampaignsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWaCampaignsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWaCampaignsInput, UserUncheckedUpdateWithoutWaCampaignsInput>
  }

  export type UserUpdateWithoutWaCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutCreatedByNestedInput
    emailCampaigns?: EmailCampaignUpdateManyWithoutCreatedByNestedInput
    emailTemplates?: EmailTemplateUpdateManyWithoutCreatedByNestedInput
    smsCampaigns?: SMSCampaignUpdateManyWithoutCreatedByNestedInput
    smsTemplates?: SMSTemplateUpdateManyWithoutCreatedByNestedInput
    waTemplates?: WhatsAppTemplateUpdateManyWithoutCreatedByNestedInput
    workflows?: WorkflowUpdateManyWithoutCreatedByNestedInput
    lists?: ListUpdateManyWithoutCreatedByNestedInput
    segments?: SegmentUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutWaCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCreatedByNestedInput
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    emailTemplates?: EmailTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    smsCampaigns?: SMSCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    smsTemplates?: SMSTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    waTemplates?: WhatsAppTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput
    lists?: ListUncheckedUpdateManyWithoutCreatedByNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type WhatsAppTemplateUpsertWithoutCampaignsInput = {
    update: XOR<WhatsAppTemplateUpdateWithoutCampaignsInput, WhatsAppTemplateUncheckedUpdateWithoutCampaignsInput>
    create: XOR<WhatsAppTemplateCreateWithoutCampaignsInput, WhatsAppTemplateUncheckedCreateWithoutCampaignsInput>
    where?: WhatsAppTemplateWhereInput
  }

  export type WhatsAppTemplateUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: WhatsAppTemplateWhereInput
    data: XOR<WhatsAppTemplateUpdateWithoutCampaignsInput, WhatsAppTemplateUncheckedUpdateWithoutCampaignsInput>
  }

  export type WhatsAppTemplateUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWATemplateStatusFieldUpdateOperationsInput | $Enums.WATemplateStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutWaTemplatesNestedInput
  }

  export type WhatsAppTemplateUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWATemplateStatusFieldUpdateOperationsInput | $Enums.WATemplateStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type ListUpsertWithWhereUniqueWithoutWaCampaignsInput = {
    where: ListWhereUniqueInput
    update: XOR<ListUpdateWithoutWaCampaignsInput, ListUncheckedUpdateWithoutWaCampaignsInput>
    create: XOR<ListCreateWithoutWaCampaignsInput, ListUncheckedCreateWithoutWaCampaignsInput>
  }

  export type ListUpdateWithWhereUniqueWithoutWaCampaignsInput = {
    where: ListWhereUniqueInput
    data: XOR<ListUpdateWithoutWaCampaignsInput, ListUncheckedUpdateWithoutWaCampaignsInput>
  }

  export type ListUpdateManyWithWhereWithoutWaCampaignsInput = {
    where: ListScalarWhereInput
    data: XOR<ListUpdateManyMutationInput, ListUncheckedUpdateManyWithoutWaCampaignsInput>
  }

  export type SegmentUpsertWithWhereUniqueWithoutWaCampaignsInput = {
    where: SegmentWhereUniqueInput
    update: XOR<SegmentUpdateWithoutWaCampaignsInput, SegmentUncheckedUpdateWithoutWaCampaignsInput>
    create: XOR<SegmentCreateWithoutWaCampaignsInput, SegmentUncheckedCreateWithoutWaCampaignsInput>
  }

  export type SegmentUpdateWithWhereUniqueWithoutWaCampaignsInput = {
    where: SegmentWhereUniqueInput
    data: XOR<SegmentUpdateWithoutWaCampaignsInput, SegmentUncheckedUpdateWithoutWaCampaignsInput>
  }

  export type SegmentUpdateManyWithWhereWithoutWaCampaignsInput = {
    where: SegmentScalarWhereInput
    data: XOR<SegmentUpdateManyMutationInput, SegmentUncheckedUpdateManyWithoutWaCampaignsInput>
  }

  export type WhatsAppActivityUpsertWithWhereUniqueWithoutCampaignInput = {
    where: WhatsAppActivityWhereUniqueInput
    update: XOR<WhatsAppActivityUpdateWithoutCampaignInput, WhatsAppActivityUncheckedUpdateWithoutCampaignInput>
    create: XOR<WhatsAppActivityCreateWithoutCampaignInput, WhatsAppActivityUncheckedCreateWithoutCampaignInput>
  }

  export type WhatsAppActivityUpdateWithWhereUniqueWithoutCampaignInput = {
    where: WhatsAppActivityWhereUniqueInput
    data: XOR<WhatsAppActivityUpdateWithoutCampaignInput, WhatsAppActivityUncheckedUpdateWithoutCampaignInput>
  }

  export type WhatsAppActivityUpdateManyWithWhereWithoutCampaignInput = {
    where: WhatsAppActivityScalarWhereInput
    data: XOR<WhatsAppActivityUpdateManyMutationInput, WhatsAppActivityUncheckedUpdateManyWithoutCampaignInput>
  }

  export type WhatsAppCampaignCreateWithoutActivitiesInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutWaCampaignsInput
    template?: WhatsAppTemplateCreateNestedOneWithoutCampaignsInput
    lists?: ListCreateNestedManyWithoutWaCampaignsInput
    segments?: SegmentCreateNestedManyWithoutWaCampaignsInput
  }

  export type WhatsAppCampaignUncheckedCreateWithoutActivitiesInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    templateId?: string | null
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    lists?: ListUncheckedCreateNestedManyWithoutWaCampaignsInput
    segments?: SegmentUncheckedCreateNestedManyWithoutWaCampaignsInput
  }

  export type WhatsAppCampaignCreateOrConnectWithoutActivitiesInput = {
    where: WhatsAppCampaignWhereUniqueInput
    create: XOR<WhatsAppCampaignCreateWithoutActivitiesInput, WhatsAppCampaignUncheckedCreateWithoutActivitiesInput>
  }

  export type ContactCreateWithoutWaActivitiesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    jobTitle?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    notes?: string | null
    tagsString?: string | null
    source?: string | null
    status?: $Enums.ContactStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutContactsInput
    listMembers?: ListMemberCreateNestedManyWithoutContactInput
    emailActivities?: EmailActivityCreateNestedManyWithoutContactInput
    smsActivities?: SMSActivityCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutWaActivitiesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    jobTitle?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    notes?: string | null
    tagsString?: string | null
    source?: string | null
    status?: $Enums.ContactStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    listMembers?: ListMemberUncheckedCreateNestedManyWithoutContactInput
    emailActivities?: EmailActivityUncheckedCreateNestedManyWithoutContactInput
    smsActivities?: SMSActivityUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutWaActivitiesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutWaActivitiesInput, ContactUncheckedCreateWithoutWaActivitiesInput>
  }

  export type WhatsAppCampaignUpsertWithoutActivitiesInput = {
    update: XOR<WhatsAppCampaignUpdateWithoutActivitiesInput, WhatsAppCampaignUncheckedUpdateWithoutActivitiesInput>
    create: XOR<WhatsAppCampaignCreateWithoutActivitiesInput, WhatsAppCampaignUncheckedCreateWithoutActivitiesInput>
    where?: WhatsAppCampaignWhereInput
  }

  export type WhatsAppCampaignUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: WhatsAppCampaignWhereInput
    data: XOR<WhatsAppCampaignUpdateWithoutActivitiesInput, WhatsAppCampaignUncheckedUpdateWithoutActivitiesInput>
  }

  export type WhatsAppCampaignUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutWaCampaignsNestedInput
    template?: WhatsAppTemplateUpdateOneWithoutCampaignsNestedInput
    lists?: ListUpdateManyWithoutWaCampaignsNestedInput
    segments?: SegmentUpdateManyWithoutWaCampaignsNestedInput
  }

  export type WhatsAppCampaignUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    lists?: ListUncheckedUpdateManyWithoutWaCampaignsNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutWaCampaignsNestedInput
  }

  export type ContactUpsertWithoutWaActivitiesInput = {
    update: XOR<ContactUpdateWithoutWaActivitiesInput, ContactUncheckedUpdateWithoutWaActivitiesInput>
    create: XOR<ContactCreateWithoutWaActivitiesInput, ContactUncheckedCreateWithoutWaActivitiesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutWaActivitiesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutWaActivitiesInput, ContactUncheckedUpdateWithoutWaActivitiesInput>
  }

  export type ContactUpdateWithoutWaActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tagsString?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutContactsNestedInput
    listMembers?: ListMemberUpdateManyWithoutContactNestedInput
    emailActivities?: EmailActivityUpdateManyWithoutContactNestedInput
    smsActivities?: SMSActivityUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutWaActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tagsString?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    listMembers?: ListMemberUncheckedUpdateManyWithoutContactNestedInput
    emailActivities?: EmailActivityUncheckedUpdateManyWithoutContactNestedInput
    smsActivities?: SMSActivityUncheckedUpdateManyWithoutContactNestedInput
  }

  export type UserCreateWithoutWorkflowsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutCreatedByInput
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutCreatedByInput
    emailTemplates?: EmailTemplateCreateNestedManyWithoutCreatedByInput
    smsCampaigns?: SMSCampaignCreateNestedManyWithoutCreatedByInput
    smsTemplates?: SMSTemplateCreateNestedManyWithoutCreatedByInput
    waCampaigns?: WhatsAppCampaignCreateNestedManyWithoutCreatedByInput
    waTemplates?: WhatsAppTemplateCreateNestedManyWithoutCreatedByInput
    lists?: ListCreateNestedManyWithoutCreatedByInput
    segments?: SegmentCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutWorkflowsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    isActive?: boolean
    role?: $Enums.UserRole
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCreatedByInput
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    emailTemplates?: EmailTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    smsCampaigns?: SMSCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    smsTemplates?: SMSTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    waCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutCreatedByInput
    waTemplates?: WhatsAppTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    lists?: ListUncheckedCreateNestedManyWithoutCreatedByInput
    segments?: SegmentUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutWorkflowsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkflowsInput, UserUncheckedCreateWithoutWorkflowsInput>
  }

  export type WorkflowNodeCreateWithoutWorkflowInput = {
    id?: string
    type: $Enums.WorkflowNodeType
    name?: string | null
    config: string
    positionX?: number | null
    positionY?: number | null
    outgoing?: ConnectionCreateNestedManyWithoutSourceInput
    incoming?: ConnectionCreateNestedManyWithoutTargetInput
  }

  export type WorkflowNodeUncheckedCreateWithoutWorkflowInput = {
    id?: string
    type: $Enums.WorkflowNodeType
    name?: string | null
    config: string
    positionX?: number | null
    positionY?: number | null
    outgoing?: ConnectionUncheckedCreateNestedManyWithoutSourceInput
    incoming?: ConnectionUncheckedCreateNestedManyWithoutTargetInput
  }

  export type WorkflowNodeCreateOrConnectWithoutWorkflowInput = {
    where: WorkflowNodeWhereUniqueInput
    create: XOR<WorkflowNodeCreateWithoutWorkflowInput, WorkflowNodeUncheckedCreateWithoutWorkflowInput>
  }

  export type WorkflowNodeCreateManyWorkflowInputEnvelope = {
    data: WorkflowNodeCreateManyWorkflowInput | WorkflowNodeCreateManyWorkflowInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowTriggerCreateWithoutWorkflowInput = {
    id?: string
    type: $Enums.TriggerType
    config: string
  }

  export type WorkflowTriggerUncheckedCreateWithoutWorkflowInput = {
    id?: string
    type: $Enums.TriggerType
    config: string
  }

  export type WorkflowTriggerCreateOrConnectWithoutWorkflowInput = {
    where: WorkflowTriggerWhereUniqueInput
    create: XOR<WorkflowTriggerCreateWithoutWorkflowInput, WorkflowTriggerUncheckedCreateWithoutWorkflowInput>
  }

  export type WorkflowTriggerCreateManyWorkflowInputEnvelope = {
    data: WorkflowTriggerCreateManyWorkflowInput | WorkflowTriggerCreateManyWorkflowInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWorkflowsInput = {
    update: XOR<UserUpdateWithoutWorkflowsInput, UserUncheckedUpdateWithoutWorkflowsInput>
    create: XOR<UserCreateWithoutWorkflowsInput, UserUncheckedCreateWithoutWorkflowsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkflowsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkflowsInput, UserUncheckedUpdateWithoutWorkflowsInput>
  }

  export type UserUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutCreatedByNestedInput
    emailCampaigns?: EmailCampaignUpdateManyWithoutCreatedByNestedInput
    emailTemplates?: EmailTemplateUpdateManyWithoutCreatedByNestedInput
    smsCampaigns?: SMSCampaignUpdateManyWithoutCreatedByNestedInput
    smsTemplates?: SMSTemplateUpdateManyWithoutCreatedByNestedInput
    waCampaigns?: WhatsAppCampaignUpdateManyWithoutCreatedByNestedInput
    waTemplates?: WhatsAppTemplateUpdateManyWithoutCreatedByNestedInput
    lists?: ListUpdateManyWithoutCreatedByNestedInput
    segments?: SegmentUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCreatedByNestedInput
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    emailTemplates?: EmailTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    smsCampaigns?: SMSCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    smsTemplates?: SMSTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    waCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    waTemplates?: WhatsAppTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    lists?: ListUncheckedUpdateManyWithoutCreatedByNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type WorkflowNodeUpsertWithWhereUniqueWithoutWorkflowInput = {
    where: WorkflowNodeWhereUniqueInput
    update: XOR<WorkflowNodeUpdateWithoutWorkflowInput, WorkflowNodeUncheckedUpdateWithoutWorkflowInput>
    create: XOR<WorkflowNodeCreateWithoutWorkflowInput, WorkflowNodeUncheckedCreateWithoutWorkflowInput>
  }

  export type WorkflowNodeUpdateWithWhereUniqueWithoutWorkflowInput = {
    where: WorkflowNodeWhereUniqueInput
    data: XOR<WorkflowNodeUpdateWithoutWorkflowInput, WorkflowNodeUncheckedUpdateWithoutWorkflowInput>
  }

  export type WorkflowNodeUpdateManyWithWhereWithoutWorkflowInput = {
    where: WorkflowNodeScalarWhereInput
    data: XOR<WorkflowNodeUpdateManyMutationInput, WorkflowNodeUncheckedUpdateManyWithoutWorkflowInput>
  }

  export type WorkflowNodeScalarWhereInput = {
    AND?: WorkflowNodeScalarWhereInput | WorkflowNodeScalarWhereInput[]
    OR?: WorkflowNodeScalarWhereInput[]
    NOT?: WorkflowNodeScalarWhereInput | WorkflowNodeScalarWhereInput[]
    id?: StringFilter<"WorkflowNode"> | string
    workflowId?: StringFilter<"WorkflowNode"> | string
    type?: EnumWorkflowNodeTypeFilter<"WorkflowNode"> | $Enums.WorkflowNodeType
    name?: StringNullableFilter<"WorkflowNode"> | string | null
    config?: StringFilter<"WorkflowNode"> | string
    positionX?: FloatNullableFilter<"WorkflowNode"> | number | null
    positionY?: FloatNullableFilter<"WorkflowNode"> | number | null
  }

  export type WorkflowTriggerUpsertWithWhereUniqueWithoutWorkflowInput = {
    where: WorkflowTriggerWhereUniqueInput
    update: XOR<WorkflowTriggerUpdateWithoutWorkflowInput, WorkflowTriggerUncheckedUpdateWithoutWorkflowInput>
    create: XOR<WorkflowTriggerCreateWithoutWorkflowInput, WorkflowTriggerUncheckedCreateWithoutWorkflowInput>
  }

  export type WorkflowTriggerUpdateWithWhereUniqueWithoutWorkflowInput = {
    where: WorkflowTriggerWhereUniqueInput
    data: XOR<WorkflowTriggerUpdateWithoutWorkflowInput, WorkflowTriggerUncheckedUpdateWithoutWorkflowInput>
  }

  export type WorkflowTriggerUpdateManyWithWhereWithoutWorkflowInput = {
    where: WorkflowTriggerScalarWhereInput
    data: XOR<WorkflowTriggerUpdateManyMutationInput, WorkflowTriggerUncheckedUpdateManyWithoutWorkflowInput>
  }

  export type WorkflowTriggerScalarWhereInput = {
    AND?: WorkflowTriggerScalarWhereInput | WorkflowTriggerScalarWhereInput[]
    OR?: WorkflowTriggerScalarWhereInput[]
    NOT?: WorkflowTriggerScalarWhereInput | WorkflowTriggerScalarWhereInput[]
    id?: StringFilter<"WorkflowTrigger"> | string
    workflowId?: StringFilter<"WorkflowTrigger"> | string
    type?: EnumTriggerTypeFilter<"WorkflowTrigger"> | $Enums.TriggerType
    config?: StringFilter<"WorkflowTrigger"> | string
  }

  export type WorkflowCreateWithoutNodesInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.WorkflowStatus
    definition: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutWorkflowsInput
    triggers?: WorkflowTriggerCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowUncheckedCreateWithoutNodesInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.WorkflowStatus
    definition: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    triggers?: WorkflowTriggerUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowCreateOrConnectWithoutNodesInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutNodesInput, WorkflowUncheckedCreateWithoutNodesInput>
  }

  export type ConnectionCreateWithoutSourceInput = {
    id?: string
    condition?: string | null
    target: WorkflowNodeCreateNestedOneWithoutIncomingInput
  }

  export type ConnectionUncheckedCreateWithoutSourceInput = {
    id?: string
    targetId: string
    condition?: string | null
  }

  export type ConnectionCreateOrConnectWithoutSourceInput = {
    where: ConnectionWhereUniqueInput
    create: XOR<ConnectionCreateWithoutSourceInput, ConnectionUncheckedCreateWithoutSourceInput>
  }

  export type ConnectionCreateManySourceInputEnvelope = {
    data: ConnectionCreateManySourceInput | ConnectionCreateManySourceInput[]
    skipDuplicates?: boolean
  }

  export type ConnectionCreateWithoutTargetInput = {
    id?: string
    condition?: string | null
    source: WorkflowNodeCreateNestedOneWithoutOutgoingInput
  }

  export type ConnectionUncheckedCreateWithoutTargetInput = {
    id?: string
    sourceId: string
    condition?: string | null
  }

  export type ConnectionCreateOrConnectWithoutTargetInput = {
    where: ConnectionWhereUniqueInput
    create: XOR<ConnectionCreateWithoutTargetInput, ConnectionUncheckedCreateWithoutTargetInput>
  }

  export type ConnectionCreateManyTargetInputEnvelope = {
    data: ConnectionCreateManyTargetInput | ConnectionCreateManyTargetInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowUpsertWithoutNodesInput = {
    update: XOR<WorkflowUpdateWithoutNodesInput, WorkflowUncheckedUpdateWithoutNodesInput>
    create: XOR<WorkflowCreateWithoutNodesInput, WorkflowUncheckedCreateWithoutNodesInput>
    where?: WorkflowWhereInput
  }

  export type WorkflowUpdateToOneWithWhereWithoutNodesInput = {
    where?: WorkflowWhereInput
    data: XOR<WorkflowUpdateWithoutNodesInput, WorkflowUncheckedUpdateWithoutNodesInput>
  }

  export type WorkflowUpdateWithoutNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    definition?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutWorkflowsNestedInput
    triggers?: WorkflowTriggerUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    definition?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    triggers?: WorkflowTriggerUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type ConnectionUpsertWithWhereUniqueWithoutSourceInput = {
    where: ConnectionWhereUniqueInput
    update: XOR<ConnectionUpdateWithoutSourceInput, ConnectionUncheckedUpdateWithoutSourceInput>
    create: XOR<ConnectionCreateWithoutSourceInput, ConnectionUncheckedCreateWithoutSourceInput>
  }

  export type ConnectionUpdateWithWhereUniqueWithoutSourceInput = {
    where: ConnectionWhereUniqueInput
    data: XOR<ConnectionUpdateWithoutSourceInput, ConnectionUncheckedUpdateWithoutSourceInput>
  }

  export type ConnectionUpdateManyWithWhereWithoutSourceInput = {
    where: ConnectionScalarWhereInput
    data: XOR<ConnectionUpdateManyMutationInput, ConnectionUncheckedUpdateManyWithoutSourceInput>
  }

  export type ConnectionScalarWhereInput = {
    AND?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
    OR?: ConnectionScalarWhereInput[]
    NOT?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
    id?: StringFilter<"Connection"> | string
    sourceId?: StringFilter<"Connection"> | string
    targetId?: StringFilter<"Connection"> | string
    condition?: StringNullableFilter<"Connection"> | string | null
  }

  export type ConnectionUpsertWithWhereUniqueWithoutTargetInput = {
    where: ConnectionWhereUniqueInput
    update: XOR<ConnectionUpdateWithoutTargetInput, ConnectionUncheckedUpdateWithoutTargetInput>
    create: XOR<ConnectionCreateWithoutTargetInput, ConnectionUncheckedCreateWithoutTargetInput>
  }

  export type ConnectionUpdateWithWhereUniqueWithoutTargetInput = {
    where: ConnectionWhereUniqueInput
    data: XOR<ConnectionUpdateWithoutTargetInput, ConnectionUncheckedUpdateWithoutTargetInput>
  }

  export type ConnectionUpdateManyWithWhereWithoutTargetInput = {
    where: ConnectionScalarWhereInput
    data: XOR<ConnectionUpdateManyMutationInput, ConnectionUncheckedUpdateManyWithoutTargetInput>
  }

  export type WorkflowNodeCreateWithoutOutgoingInput = {
    id?: string
    type: $Enums.WorkflowNodeType
    name?: string | null
    config: string
    positionX?: number | null
    positionY?: number | null
    workflow: WorkflowCreateNestedOneWithoutNodesInput
    incoming?: ConnectionCreateNestedManyWithoutTargetInput
  }

  export type WorkflowNodeUncheckedCreateWithoutOutgoingInput = {
    id?: string
    workflowId: string
    type: $Enums.WorkflowNodeType
    name?: string | null
    config: string
    positionX?: number | null
    positionY?: number | null
    incoming?: ConnectionUncheckedCreateNestedManyWithoutTargetInput
  }

  export type WorkflowNodeCreateOrConnectWithoutOutgoingInput = {
    where: WorkflowNodeWhereUniqueInput
    create: XOR<WorkflowNodeCreateWithoutOutgoingInput, WorkflowNodeUncheckedCreateWithoutOutgoingInput>
  }

  export type WorkflowNodeCreateWithoutIncomingInput = {
    id?: string
    type: $Enums.WorkflowNodeType
    name?: string | null
    config: string
    positionX?: number | null
    positionY?: number | null
    workflow: WorkflowCreateNestedOneWithoutNodesInput
    outgoing?: ConnectionCreateNestedManyWithoutSourceInput
  }

  export type WorkflowNodeUncheckedCreateWithoutIncomingInput = {
    id?: string
    workflowId: string
    type: $Enums.WorkflowNodeType
    name?: string | null
    config: string
    positionX?: number | null
    positionY?: number | null
    outgoing?: ConnectionUncheckedCreateNestedManyWithoutSourceInput
  }

  export type WorkflowNodeCreateOrConnectWithoutIncomingInput = {
    where: WorkflowNodeWhereUniqueInput
    create: XOR<WorkflowNodeCreateWithoutIncomingInput, WorkflowNodeUncheckedCreateWithoutIncomingInput>
  }

  export type WorkflowNodeUpsertWithoutOutgoingInput = {
    update: XOR<WorkflowNodeUpdateWithoutOutgoingInput, WorkflowNodeUncheckedUpdateWithoutOutgoingInput>
    create: XOR<WorkflowNodeCreateWithoutOutgoingInput, WorkflowNodeUncheckedCreateWithoutOutgoingInput>
    where?: WorkflowNodeWhereInput
  }

  export type WorkflowNodeUpdateToOneWithWhereWithoutOutgoingInput = {
    where?: WorkflowNodeWhereInput
    data: XOR<WorkflowNodeUpdateWithoutOutgoingInput, WorkflowNodeUncheckedUpdateWithoutOutgoingInput>
  }

  export type WorkflowNodeUpdateWithoutOutgoingInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowNodeTypeFieldUpdateOperationsInput | $Enums.WorkflowNodeType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    workflow?: WorkflowUpdateOneRequiredWithoutNodesNestedInput
    incoming?: ConnectionUpdateManyWithoutTargetNestedInput
  }

  export type WorkflowNodeUncheckedUpdateWithoutOutgoingInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowNodeTypeFieldUpdateOperationsInput | $Enums.WorkflowNodeType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    incoming?: ConnectionUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type WorkflowNodeUpsertWithoutIncomingInput = {
    update: XOR<WorkflowNodeUpdateWithoutIncomingInput, WorkflowNodeUncheckedUpdateWithoutIncomingInput>
    create: XOR<WorkflowNodeCreateWithoutIncomingInput, WorkflowNodeUncheckedCreateWithoutIncomingInput>
    where?: WorkflowNodeWhereInput
  }

  export type WorkflowNodeUpdateToOneWithWhereWithoutIncomingInput = {
    where?: WorkflowNodeWhereInput
    data: XOR<WorkflowNodeUpdateWithoutIncomingInput, WorkflowNodeUncheckedUpdateWithoutIncomingInput>
  }

  export type WorkflowNodeUpdateWithoutIncomingInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowNodeTypeFieldUpdateOperationsInput | $Enums.WorkflowNodeType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    workflow?: WorkflowUpdateOneRequiredWithoutNodesNestedInput
    outgoing?: ConnectionUpdateManyWithoutSourceNestedInput
  }

  export type WorkflowNodeUncheckedUpdateWithoutIncomingInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowNodeTypeFieldUpdateOperationsInput | $Enums.WorkflowNodeType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    outgoing?: ConnectionUncheckedUpdateManyWithoutSourceNestedInput
  }

  export type WorkflowCreateWithoutTriggersInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.WorkflowStatus
    definition: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutWorkflowsInput
    nodes?: WorkflowNodeCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowUncheckedCreateWithoutTriggersInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.WorkflowStatus
    definition: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    nodes?: WorkflowNodeUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowCreateOrConnectWithoutTriggersInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutTriggersInput, WorkflowUncheckedCreateWithoutTriggersInput>
  }

  export type WorkflowUpsertWithoutTriggersInput = {
    update: XOR<WorkflowUpdateWithoutTriggersInput, WorkflowUncheckedUpdateWithoutTriggersInput>
    create: XOR<WorkflowCreateWithoutTriggersInput, WorkflowUncheckedCreateWithoutTriggersInput>
    where?: WorkflowWhereInput
  }

  export type WorkflowUpdateToOneWithWhereWithoutTriggersInput = {
    where?: WorkflowWhereInput
    data: XOR<WorkflowUpdateWithoutTriggersInput, WorkflowUncheckedUpdateWithoutTriggersInput>
  }

  export type WorkflowUpdateWithoutTriggersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    definition?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutWorkflowsNestedInput
    nodes?: WorkflowNodeUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutTriggersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    definition?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    nodes?: WorkflowNodeUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type ContactCreateManyCreatedByInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    jobTitle?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    notes?: string | null
    tagsString?: string | null
    source?: string | null
    status?: $Enums.ContactStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailCampaignCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    subject: string
    from: string
    replyTo?: string | null
    templateId?: string | null
    content?: string | null
    design?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    subject: string
    content: string
    design?: string | null
    previewText?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SMSCampaignCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    templateId?: string | null
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SMSTemplateCreateManyCreatedByInput = {
    id?: string
    name: string
    content: string
    variables: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppCampaignCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    templateId?: string | null
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppTemplateCreateManyCreatedByInput = {
    id?: string
    name: string
    content: string
    variables: string
    category?: string | null
    status?: $Enums.WATemplateStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.WorkflowStatus
    definition: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ListCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    type?: $Enums.ListType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SegmentCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    rules: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tagsString?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listMembers?: ListMemberUpdateManyWithoutContactNestedInput
    emailActivities?: EmailActivityUpdateManyWithoutContactNestedInput
    smsActivities?: SMSActivityUpdateManyWithoutContactNestedInput
    waActivities?: WhatsAppActivityUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tagsString?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listMembers?: ListMemberUncheckedUpdateManyWithoutContactNestedInput
    emailActivities?: EmailActivityUncheckedUpdateManyWithoutContactNestedInput
    smsActivities?: SMSActivityUncheckedUpdateManyWithoutContactNestedInput
    waActivities?: WhatsAppActivityUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tagsString?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailCampaignUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: EmailTemplateUpdateOneWithoutCampaignsNestedInput
    lists?: ListUpdateManyWithoutEmailCampaignsNestedInput
    segments?: SegmentUpdateManyWithoutEmailCampaignsNestedInput
    activities?: EmailActivityUpdateManyWithoutCampaignNestedInput
  }

  export type EmailCampaignUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lists?: ListUncheckedUpdateManyWithoutEmailCampaignsNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutEmailCampaignsNestedInput
    activities?: EmailActivityUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type EmailCampaignUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    design?: NullableStringFieldUpdateOperationsInput | string | null
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: EmailCampaignUpdateManyWithoutTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    design?: NullableStringFieldUpdateOperationsInput | string | null
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: EmailCampaignUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    design?: NullableStringFieldUpdateOperationsInput | string | null
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SMSCampaignUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: SMSTemplateUpdateOneWithoutCampaignsNestedInput
    lists?: ListUpdateManyWithoutSmsCampaignsNestedInput
    segments?: SegmentUpdateManyWithoutSmsCampaignsNestedInput
    activities?: SMSActivityUpdateManyWithoutCampaignNestedInput
  }

  export type SMSCampaignUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lists?: ListUncheckedUpdateManyWithoutSmsCampaignsNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutSmsCampaignsNestedInput
    activities?: SMSActivityUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type SMSCampaignUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SMSTemplateUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: SMSCampaignUpdateManyWithoutTemplateNestedInput
  }

  export type SMSTemplateUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: SMSCampaignUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type SMSTemplateUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppCampaignUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: WhatsAppTemplateUpdateOneWithoutCampaignsNestedInput
    lists?: ListUpdateManyWithoutWaCampaignsNestedInput
    segments?: SegmentUpdateManyWithoutWaCampaignsNestedInput
    activities?: WhatsAppActivityUpdateManyWithoutCampaignNestedInput
  }

  export type WhatsAppCampaignUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lists?: ListUncheckedUpdateManyWithoutWaCampaignsNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutWaCampaignsNestedInput
    activities?: WhatsAppActivityUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type WhatsAppCampaignUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppTemplateUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWATemplateStatusFieldUpdateOperationsInput | $Enums.WATemplateStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: WhatsAppCampaignUpdateManyWithoutTemplateNestedInput
  }

  export type WhatsAppTemplateUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWATemplateStatusFieldUpdateOperationsInput | $Enums.WATemplateStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type WhatsAppTemplateUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWATemplateStatusFieldUpdateOperationsInput | $Enums.WATemplateStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    definition?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: WorkflowNodeUpdateManyWithoutWorkflowNestedInput
    triggers?: WorkflowTriggerUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    definition?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: WorkflowNodeUncheckedUpdateManyWithoutWorkflowNestedInput
    triggers?: WorkflowTriggerUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    definition?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ListMemberUpdateManyWithoutListNestedInput
    emailCampaigns?: EmailCampaignUpdateManyWithoutListsNestedInput
    smsCampaigns?: SMSCampaignUpdateManyWithoutListsNestedInput
    waCampaigns?: WhatsAppCampaignUpdateManyWithoutListsNestedInput
  }

  export type ListUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ListMemberUncheckedUpdateManyWithoutListNestedInput
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutListsNestedInput
    smsCampaigns?: SMSCampaignUncheckedUpdateManyWithoutListsNestedInput
    waCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutListsNestedInput
  }

  export type ListUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SegmentUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailCampaigns?: EmailCampaignUpdateManyWithoutSegmentsNestedInput
    smsCampaigns?: SMSCampaignUpdateManyWithoutSegmentsNestedInput
    waCampaigns?: WhatsAppCampaignUpdateManyWithoutSegmentsNestedInput
  }

  export type SegmentUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutSegmentsNestedInput
    smsCampaigns?: SMSCampaignUncheckedUpdateManyWithoutSegmentsNestedInput
    waCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutSegmentsNestedInput
  }

  export type SegmentUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListMemberCreateManyContactInput = {
    id?: string
    listId: string
    addedAt?: Date | string
  }

  export type EmailActivityCreateManyContactInput = {
    id?: string
    campaignId: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
  }

  export type SMSActivityCreateManyContactInput = {
    id?: string
    campaignId: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
  }

  export type WhatsAppActivityCreateManyContactInput = {
    id?: string
    campaignId: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
  }

  export type ListMemberUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    list?: ListUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ListMemberUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    listId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListMemberUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    listId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailActivityUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: EmailCampaignUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type EmailActivityUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailActivityUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SMSActivityUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: SMSCampaignUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type SMSActivityUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SMSActivityUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WhatsAppActivityUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: WhatsAppCampaignUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type WhatsAppActivityUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WhatsAppActivityUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ListMemberCreateManyListInput = {
    id?: string
    contactId: string
    addedAt?: Date | string
  }

  export type ListMemberUpdateWithoutListInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutListMembersNestedInput
  }

  export type ListMemberUncheckedUpdateWithoutListInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListMemberUncheckedUpdateManyWithoutListInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailCampaignUpdateWithoutListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutEmailCampaignsNestedInput
    template?: EmailTemplateUpdateOneWithoutCampaignsNestedInput
    segments?: SegmentUpdateManyWithoutEmailCampaignsNestedInput
    activities?: EmailActivityUpdateManyWithoutCampaignNestedInput
  }

  export type EmailCampaignUncheckedUpdateWithoutListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    segments?: SegmentUncheckedUpdateManyWithoutEmailCampaignsNestedInput
    activities?: EmailActivityUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type EmailCampaignUncheckedUpdateManyWithoutListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type SMSCampaignUpdateWithoutListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutSmsCampaignsNestedInput
    template?: SMSTemplateUpdateOneWithoutCampaignsNestedInput
    segments?: SegmentUpdateManyWithoutSmsCampaignsNestedInput
    activities?: SMSActivityUpdateManyWithoutCampaignNestedInput
  }

  export type SMSCampaignUncheckedUpdateWithoutListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    segments?: SegmentUncheckedUpdateManyWithoutSmsCampaignsNestedInput
    activities?: SMSActivityUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type SMSCampaignUncheckedUpdateManyWithoutListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type WhatsAppCampaignUpdateWithoutListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutWaCampaignsNestedInput
    template?: WhatsAppTemplateUpdateOneWithoutCampaignsNestedInput
    segments?: SegmentUpdateManyWithoutWaCampaignsNestedInput
    activities?: WhatsAppActivityUpdateManyWithoutCampaignNestedInput
  }

  export type WhatsAppCampaignUncheckedUpdateWithoutListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    segments?: SegmentUncheckedUpdateManyWithoutWaCampaignsNestedInput
    activities?: WhatsAppActivityUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type WhatsAppCampaignUncheckedUpdateManyWithoutListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type EmailCampaignUpdateWithoutSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutEmailCampaignsNestedInput
    template?: EmailTemplateUpdateOneWithoutCampaignsNestedInput
    lists?: ListUpdateManyWithoutEmailCampaignsNestedInput
    activities?: EmailActivityUpdateManyWithoutCampaignNestedInput
  }

  export type EmailCampaignUncheckedUpdateWithoutSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    lists?: ListUncheckedUpdateManyWithoutEmailCampaignsNestedInput
    activities?: EmailActivityUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type EmailCampaignUncheckedUpdateManyWithoutSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type SMSCampaignUpdateWithoutSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutSmsCampaignsNestedInput
    template?: SMSTemplateUpdateOneWithoutCampaignsNestedInput
    lists?: ListUpdateManyWithoutSmsCampaignsNestedInput
    activities?: SMSActivityUpdateManyWithoutCampaignNestedInput
  }

  export type SMSCampaignUncheckedUpdateWithoutSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    lists?: ListUncheckedUpdateManyWithoutSmsCampaignsNestedInput
    activities?: SMSActivityUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type SMSCampaignUncheckedUpdateManyWithoutSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type WhatsAppCampaignUpdateWithoutSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutWaCampaignsNestedInput
    template?: WhatsAppTemplateUpdateOneWithoutCampaignsNestedInput
    lists?: ListUpdateManyWithoutWaCampaignsNestedInput
    activities?: WhatsAppActivityUpdateManyWithoutCampaignNestedInput
  }

  export type WhatsAppCampaignUncheckedUpdateWithoutSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    lists?: ListUncheckedUpdateManyWithoutWaCampaignsNestedInput
    activities?: WhatsAppActivityUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type WhatsAppCampaignUncheckedUpdateManyWithoutSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type EmailCampaignCreateManyTemplateInput = {
    id?: string
    name: string
    description?: string | null
    subject: string
    from: string
    replyTo?: string | null
    content?: string | null
    design?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type EmailCampaignUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutEmailCampaignsNestedInput
    lists?: ListUpdateManyWithoutEmailCampaignsNestedInput
    segments?: SegmentUpdateManyWithoutEmailCampaignsNestedInput
    activities?: EmailActivityUpdateManyWithoutCampaignNestedInput
  }

  export type EmailCampaignUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    lists?: ListUncheckedUpdateManyWithoutEmailCampaignsNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutEmailCampaignsNestedInput
    activities?: EmailActivityUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type EmailCampaignUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type EmailActivityCreateManyCampaignInput = {
    id?: string
    contactId: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
  }

  export type ListUpdateWithoutEmailCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutListsNestedInput
    members?: ListMemberUpdateManyWithoutListNestedInput
    smsCampaigns?: SMSCampaignUpdateManyWithoutListsNestedInput
    waCampaigns?: WhatsAppCampaignUpdateManyWithoutListsNestedInput
  }

  export type ListUncheckedUpdateWithoutEmailCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    members?: ListMemberUncheckedUpdateManyWithoutListNestedInput
    smsCampaigns?: SMSCampaignUncheckedUpdateManyWithoutListsNestedInput
    waCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutListsNestedInput
  }

  export type ListUncheckedUpdateManyWithoutEmailCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type SegmentUpdateWithoutEmailCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutSegmentsNestedInput
    smsCampaigns?: SMSCampaignUpdateManyWithoutSegmentsNestedInput
    waCampaigns?: WhatsAppCampaignUpdateManyWithoutSegmentsNestedInput
  }

  export type SegmentUncheckedUpdateWithoutEmailCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    smsCampaigns?: SMSCampaignUncheckedUpdateManyWithoutSegmentsNestedInput
    waCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutSegmentsNestedInput
  }

  export type SegmentUncheckedUpdateManyWithoutEmailCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type EmailActivityUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: ContactUpdateOneRequiredWithoutEmailActivitiesNestedInput
  }

  export type EmailActivityUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailActivityUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SMSCampaignCreateManyTemplateInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type SMSCampaignUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutSmsCampaignsNestedInput
    lists?: ListUpdateManyWithoutSmsCampaignsNestedInput
    segments?: SegmentUpdateManyWithoutSmsCampaignsNestedInput
    activities?: SMSActivityUpdateManyWithoutCampaignNestedInput
  }

  export type SMSCampaignUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    lists?: ListUncheckedUpdateManyWithoutSmsCampaignsNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutSmsCampaignsNestedInput
    activities?: SMSActivityUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type SMSCampaignUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type SMSActivityCreateManyCampaignInput = {
    id?: string
    contactId: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
  }

  export type ListUpdateWithoutSmsCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutListsNestedInput
    members?: ListMemberUpdateManyWithoutListNestedInput
    emailCampaigns?: EmailCampaignUpdateManyWithoutListsNestedInput
    waCampaigns?: WhatsAppCampaignUpdateManyWithoutListsNestedInput
  }

  export type ListUncheckedUpdateWithoutSmsCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    members?: ListMemberUncheckedUpdateManyWithoutListNestedInput
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutListsNestedInput
    waCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutListsNestedInput
  }

  export type ListUncheckedUpdateManyWithoutSmsCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type SegmentUpdateWithoutSmsCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutSegmentsNestedInput
    emailCampaigns?: EmailCampaignUpdateManyWithoutSegmentsNestedInput
    waCampaigns?: WhatsAppCampaignUpdateManyWithoutSegmentsNestedInput
  }

  export type SegmentUncheckedUpdateWithoutSmsCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutSegmentsNestedInput
    waCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutSegmentsNestedInput
  }

  export type SegmentUncheckedUpdateManyWithoutSmsCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type SMSActivityUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: ContactUpdateOneRequiredWithoutSmsActivitiesNestedInput
  }

  export type SMSActivityUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SMSActivityUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WhatsAppCampaignCreateManyTemplateInput = {
    id?: string
    name: string
    description?: string | null
    from: string
    content?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type WhatsAppCampaignUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutWaCampaignsNestedInput
    lists?: ListUpdateManyWithoutWaCampaignsNestedInput
    segments?: SegmentUpdateManyWithoutWaCampaignsNestedInput
    activities?: WhatsAppActivityUpdateManyWithoutCampaignNestedInput
  }

  export type WhatsAppCampaignUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    lists?: ListUncheckedUpdateManyWithoutWaCampaignsNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutWaCampaignsNestedInput
    activities?: WhatsAppActivityUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type WhatsAppCampaignUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type WhatsAppActivityCreateManyCampaignInput = {
    id?: string
    contactId: string
    type: $Enums.ActivityType
    timestamp?: Date | string
    metadata?: string | null
  }

  export type ListUpdateWithoutWaCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutListsNestedInput
    members?: ListMemberUpdateManyWithoutListNestedInput
    emailCampaigns?: EmailCampaignUpdateManyWithoutListsNestedInput
    smsCampaigns?: SMSCampaignUpdateManyWithoutListsNestedInput
  }

  export type ListUncheckedUpdateWithoutWaCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    members?: ListMemberUncheckedUpdateManyWithoutListNestedInput
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutListsNestedInput
    smsCampaigns?: SMSCampaignUncheckedUpdateManyWithoutListsNestedInput
  }

  export type ListUncheckedUpdateManyWithoutWaCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type SegmentUpdateWithoutWaCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutSegmentsNestedInput
    emailCampaigns?: EmailCampaignUpdateManyWithoutSegmentsNestedInput
    smsCampaigns?: SMSCampaignUpdateManyWithoutSegmentsNestedInput
  }

  export type SegmentUncheckedUpdateWithoutWaCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutSegmentsNestedInput
    smsCampaigns?: SMSCampaignUncheckedUpdateManyWithoutSegmentsNestedInput
  }

  export type SegmentUncheckedUpdateManyWithoutWaCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type WhatsAppActivityUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: ContactUpdateOneRequiredWithoutWaActivitiesNestedInput
  }

  export type WhatsAppActivityUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WhatsAppActivityUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkflowNodeCreateManyWorkflowInput = {
    id?: string
    type: $Enums.WorkflowNodeType
    name?: string | null
    config: string
    positionX?: number | null
    positionY?: number | null
  }

  export type WorkflowTriggerCreateManyWorkflowInput = {
    id?: string
    type: $Enums.TriggerType
    config: string
  }

  export type WorkflowNodeUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowNodeTypeFieldUpdateOperationsInput | $Enums.WorkflowNodeType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    outgoing?: ConnectionUpdateManyWithoutSourceNestedInput
    incoming?: ConnectionUpdateManyWithoutTargetNestedInput
  }

  export type WorkflowNodeUncheckedUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowNodeTypeFieldUpdateOperationsInput | $Enums.WorkflowNodeType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    outgoing?: ConnectionUncheckedUpdateManyWithoutSourceNestedInput
    incoming?: ConnectionUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type WorkflowNodeUncheckedUpdateManyWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowNodeTypeFieldUpdateOperationsInput | $Enums.WorkflowNodeType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type WorkflowTriggerUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType
    config?: StringFieldUpdateOperationsInput | string
  }

  export type WorkflowTriggerUncheckedUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType
    config?: StringFieldUpdateOperationsInput | string
  }

  export type WorkflowTriggerUncheckedUpdateManyWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType
    config?: StringFieldUpdateOperationsInput | string
  }

  export type ConnectionCreateManySourceInput = {
    id?: string
    targetId: string
    condition?: string | null
  }

  export type ConnectionCreateManyTargetInput = {
    id?: string
    sourceId: string
    condition?: string | null
  }

  export type ConnectionUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    target?: WorkflowNodeUpdateOneRequiredWithoutIncomingNestedInput
  }

  export type ConnectionUncheckedUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    condition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConnectionUncheckedUpdateManyWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    condition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConnectionUpdateWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    source?: WorkflowNodeUpdateOneRequiredWithoutOutgoingNestedInput
  }

  export type ConnectionUncheckedUpdateWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    condition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConnectionUncheckedUpdateManyWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    condition?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}